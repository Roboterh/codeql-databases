None.classp0JacksonInject$Value{...}JsonAutoDetect$VisibilityJsonAutoDetect$Valuep3p4JsonCreator$ModeJsonFormat$FeatureJsonFormat$ShapeJsonFormat$FeaturesJsonIgnoreProperties$ValueJsonFormat$Valuep5p6JsonInclude$IncludeJsonInclude$ValueJsonIncludeProperties$ValueJsonProperty$AccessJsonSetter$ValueJsonTypeInfo$IdObjectIdGenerator$IdKeyJsonTypeInfo$AsBase64Variant$PaddingReadBehaviourJsonFactory$FeatureJsonGenerator$FeatureJsonParser$FeatureJsonParser$NumberTypeByteQuadsCanonicalizer$TableInfoCharsToNameCanonicalizer$BucketCharsToNameCanonicalizer$TableInfoWritableTypeId$InclusionAnnotationIntrospector$ReferenceProperty$TypeAnnotationIntrospector$ReferencePropertyBeanProperty$StdJsonMappingException$ReferenceMap$EntryJsonSerializable$BaseModule$SetupContextObjectMapper$DefaultTypingp7ObjectWriter$GeneratorSettingsObjectWriter$PrefetchPropertyMetadata$MergeInfoJsonPOJOBuilder$ValueJsonSerialize$InclusionJsonSerialize$Typingp8p9p10p11ConstructorDetector$SingleArgConstructorDataFormatReaders$MatchReadableObjectId$ReferringAccessorNamingStrategy$ProviderAnnotatedClass$CreatorsAnnotatedConstructor$SerializationAnnotatedField$SerializationAnnotatedMethod$SerializationClassIntrospector$MixInResolverPolymorphicTypeValidator$ValidityPropertySerializerMap$SerializerAndMapResultTypeParser$MyTokenizerArrayBuilders$BooleanBuilderArrayBuilders$ByteBuilderPrimitiveArrayBuilder$NodeArrayBuilders$DoubleBuilderArrayBuilders$FloatBuilderArrayBuilders$IntBuilderArrayBuilders$ShortBuilderArrayBuilders$LongBuilderIgnorePropertiesUtil$CheckerTokenBuffer$SegmentTomlMapper$BuilderYAMLGenerator$FeatureYAMLMapper$BuilderYAMLParser$FeatureJavaToken$CategoryParserConfiguration$LanguageLevelCompilationUnit$StorageModifier$KeywordNode$ObserverRegistrationModeNode$TreeTraversalNode$ParsednessCallableDeclaration$SignatureAssignExpr$OperatorBinaryExpr$OperatorUnaryExpr$OperatorAstObserver$ListChangeTypeSwitchEntry$TypeArrayType$OriginArrayType$ArrayBracketPairPrimitiveType$PrimitiveJavadocBlockTag$TypeResolvedTypeParameterDeclaration$BoundResolvedTypeParametersMap$BuilderReflectionProvider$VisitorMapper$ImplicitCollectionMappingAnnotationsTestBase$AnnotationsTesterAnnotationsTestBase$FieldAnnotationScannerAnnotationsTestBase$MethodAnnotationScannerAnnotationsTestBase$MyCollectorAnnotationsTestBase$MyLoaderRequires.classClosure<>.classGenericsTestBase$GenericsTesterGenericsTestBase$MyCollectorGenericsTestBase$MyLoaderGenericsTestData$AbstractGenericsTestData$TestInterfaceJavaClass$NonStaticInnerJavaClass$StaticInner$Inner2JavaClass$StaticInnerJointGroovy$StaticInner$NonStaticInnerJointGroovy$StaticInnerString.classOuterUser$InnerAddress$StreetInteger.classObject.classOuterUser$InnerAddressAutobox$UtilG3839Transform1.classG3839Transform2.classG3839Transform3.classGroovy6653$AGroovy6653$CGroovy8008Bug$Inner$InnerInnerGroovy8008Bug$InnerGroovy8008Bug$TestAnno1Groovy8008Bug$TestAnno2Groovy8164$IGroovy8164$JHashMap$NodeHashMap$TreeNodeLinkedHashMap$EntryBaseReducer$PackagePrivateBaseContextBaseReducer$PackagePrivateStaticBaseContextBaseReducer$PrivateBaseContextBaseReducer$ProtectedBaseContextBaseReducer$ProtectedStaticBaseContextBaseReducer$PublicStaticBaseContextBaseReducer$PublicBaseContextReducable$InterfaceContextReducer$PackagePrivateContextReducer$PackagePrivateStaticContextReducer$ProtectedContextReducer$PrivateContextReducer$ProtectedStaticContextReducer$PublicContextReducer$PublicStaticContextReducer$TypeConsole$CstInspectorConsole$GroovySourceTypeConsole$JavaSourceTypeConsole$SourceTypeCLASS.classConsoleTextEditor$LineNumbersPanelConsoleTextEditor$PrintActionConsoleTextEditor$RedoActionConsoleTextEditor$UndoActionConsoleTextEditor$UpdateCaretListenerFindReplaceUtility$CloseActionFindReplaceUtility$FindActionFindReplaceUtility$ReplaceActionFindReplaceUtility$ReplaceAllActionGroovyFilter$AutoTabActionStructuredSyntaxDocumentFilter$LexerNodeStructuredSyntaxDocumentFilter$MultiLineRunStructuredSyntaxDocumentFilter$MLComparatorTextEditor$FindActionTextEditor$OvertypeCaretTextEditor$ReplaceActionTextEditor$ShiftTabActionTextEditor$TabActionTextUndoManager$StructuredEditEnsuresAnnotationProcessor.classClassInvariantAnnotationProcessor.classRequiresAnnotationProcessor.classInspector$MemberComparatorWithValueInspectorTest$ClassWithPrivateInspector$MemberComparatorJmxBuilderModelMBean$AttributeChangedListenerJmxBuilderModelMBean$NumberSequencerJmxEventEmitter$NumberSequencerDefaultJsonGenerator$ClosureConverterJsonGenerator$ConverterJsonGenerator$OptionsFromString.classClosureSignatureConflictResolver.classJsonOutput$JsonUnescapedBoolean.classMap<>.classStreamingJsonBuilder$StreamingJsonDelegate$StateStreamingJsonBuilder$StreamingJsonDelegateStreamingJsonDelegate.classClosure$WritableClosureDelegatesTo$TargetExpandoMetaClass$CallableExpandoMetaClass$DefiningClosureExpandoMetaClass$ExpandoMetaConstructorExpandoMetaClass$ExpandoMetaPropertyExpandoMetaClass$MixedInAccessorExpandoMetaClass$StaticDefiningClosureExpandoMetaClass$SubClassDefiningClosureDefiningClosure.classSimpleType.classGroovyClassLoader$ClassCollectorGroovyClassLoader$InnerLoaderGroovyClassLoader$TimestampAdderTarget.classGroovyShellTest$PropertyHolderIntRange$IntRangeIteratorMetaClassImpl$DummyMetaMethodMetaClassImpl$IndexMetaClassImpl$InvokeMethodResultMetaClassImpl$MetaConstructorMetaClassImpl$MethodHandleHolderMetaClassImpl$MethodIndexMetaClassImpl$MethodIndexActionMetaClassRegistry$MetaClassCreationHandleNumberRangeTestCase$RecordingClosureObjectRange$StepIteratorNumberRange$StepIteratorScriptTest$DummyGroovyClassLoaderDeadlockTest$RunnerMockProxyMetaClass$FallThroughMarkerSecurityTestSupport$SecurityTestResultPrinterServletBinding$InvalidOutputStreamServletBinding$ServletOutputTemplateServlet$TemplateCacheEntryGroovyResultSetProxy$DummyResultSetSql$AbstractQueryCommandSql$AbstractStatementCommandSql$CreateCallableStatementCommandSql$CreatePreparedStatementCommandSql$CreateStatementCommandSql$PreparedQueryCommandSql$QueryCommandProperties.classSwingBuilder.classDefaultTableModel$MyTableColumnModelGStringTemplateEngine$GStringTemplateSimpleTemplateEngine$SimpleTemplateStreamingTemplateEngine$StreamingTemplate$FinishedReadingExceptionStreamingTemplateEngine$StreamingTemplate$PositionStreamingTemplateEngine$StreamingTemplate$StringSectionStreamingTemplateEngine$StreamingTemplateXmlTemplateEngine$GspPrinterXmlTemplateEngine$XmlTemplateXmlTemplateEngine$XmlWritableBaseTemplate$TagDataMarkupTemplateEngine$CachingTemplateResolverMarkupTemplateEngine$DefaultTemplateResolverMarkupTemplateEngine$MarkupTemplateMakerMarkupTemplateEngine$TemplateGroovyClassLoaderMarkupTemplateEngine$TemplateResourceBaseDuration$FromCompileDynamic$CollectorHelperCollectorHelper.classGroovy10570emu$DataData.classImmutable$CollectorHelperNamedParams.classTypeChecked$TypeCheckingInfoUndefined$CLASSInitializerStrategy$SETInitializerStrategy$UNSETUndefined$EXCEPTIONFirstParam$ComponentFirstParam$FirstGenericTypeFirstParam$SecondGenericTypeFirstParam$ThirdGenericTypeMapEntryOrKeyValue$OptionsSecondParam$ComponentSecondParam$FirstGenericTypeSecondParam$SecondGenericTypeSecondParam$ThirdGenericTypeThirdParam$ComponentThirdParam$SecondGenericTypeThirdParam$FirstGenericTypeThirdParam$ThirdGenericTypeGroovyMain$GroovyCommandVersionProvider.classNoDefaultProvider.classNoOpModelTransformer.classNoOpParameterPreprocessor.classGroovySocketServer$GroovyClientConnectionGroovyMain$VersionProviderGroovyScriptEngine$LocalDataGroovyScriptEngine$ScriptCacheEntryGroovyScriptEngine$ScriptClassLoaderObjectGraphBuilder$ChildPropertySetterObjectGraphBuilder$ClassNameResolverObjectGraphBuilder$DefaultChildPropertySetterObjectGraphBuilder$DefaultClassNameResolverObjectGraphBuilder$DefaultIdentifierResolverObjectGraphBuilder$DefaultNewInstanceResolverObjectGraphBuilder$DefaultReferenceResolverObjectGraphBuilder$DefaultRelationNameResolverObjectGraphBuilder$IdentifierResolverObjectGraphBuilder$NewInstanceResolverObjectGraphBuilder$NodeReferenceObjectGraphBuilder$ObjectBeanFactoryObjectGraphBuilder$ObjectFactoryObjectGraphBuilder$ObjectRefFactoryObjectGraphBuilder$ReflectionClassNameResolverObjectGraphBuilder$RelationNameResolverObservableList$ChangeTypeObservableList$ElementAddedEventObjectGraphBuilder$ReferenceResolverObservableList$ElementClearedEventObservableList$ElementRemovedEventObservableList$ElementUpdatedEventObservableList$MultiElementAddedEventObservableList$ElementEventObservableList$MultiElementRemovedEventObservableList$ObservableIteratorObservableList$ObservableListIteratorObservableMap$ChangeTypeObservableMap$MultiPropertyEventObservableMap$PropertyAddedEventObservableMap$PropertyClearedEventObservableMap$PropertyEventObservableMap$PropertyRemovedEventObservableMap$PropertyUpdatedEventObservableSet$ChangeTypeObservableSet$ElementAddedEventObservableSet$ElementClearedEventObservableSet$ElementEventObservableSet$ElementRemovedEventObservableSet$MultiElementAddedEventObservableSet$MultiElementRemovedEventObservableSet$ObservableIteratorProxyGenerator$CacheKeyProxyGenerator$CacheKey$ClassReferenceCommons$CommonsLoggingStrategyLog$JavaUtilLoggingStrategyLog4j$Log4jLoggingStrategyLog4j2$Log4j2LoggingStrategySlf4j$Slf4jLoggingStrategyMarkupBuilder$CharFilterMarkupBuilder$DefaultXmlEscapingFunctionTestXmlSupport$LoggingDefaultHandlerXmlNodePrinter$NamespaceContextDOMCategory$NodeListsHolderDOMCategory$NodesHolderBaseMarkupBuilder$Document$OutputSinkBaseMarkupBuilder$DocumentBuilder$BuiltAttribute$SetBufferCapabilities$FlipContentsComponent$BaselineResizeBehaviorDesktop$ActionCursor$CursorDisposerDialog$ModalExclusionTypeDialog$ModalityTypeEventFilter$FilterActionGraphicsDevice$WindowTranslucencyJobAttributes$DefaultSelectionTypeJobAttributes$DestinationTypeJobAttributes$DialogTypeJobAttributes$MultipleDocumentHandlingTypeJobAttributes$SidesTypePageAttributes$ColorTypePageAttributes$MediaTypePageAttributes$OrientationRequestedTypePageAttributes$OriginTypePageAttributes$PrintQualityTypeRenderingHints$KeyWindow$TypeWindow$WindowDisposerRecordDropTarget$DropTargetAutoScrollerp12p13Path2D$FloatPoint2D$FloatRectangle2D$FloatObjectInputStream$GetFieldObjectOutputStream$PutFieldObjectStreamClass$ClassDataSlotCharacter$SubsetClassValue$ClassValueMapClassValue$EntryClassValue$VersionWeakHashMap$EntryClassValue$IdentityThread$StateThread$UncaughtExceptionHandlerThreadLocal$ThreadLocalMapBoundMethodHandle$SpeciesDataLambdaForm$BasicTypeLambdaForm$HiddenLambdaForm$NameLambdaForm$NamedFunctionMemberName$FactoryMethodHandle$PolymorphicSignatureMethodHandleImpl$IntrinsicMethodHandles$LookupMethodType$ConcurrentWeakInternSetInetAddress$InetAddressHolderProxy$TypeFileChannel$MapModePipe$SinkChannelPipe$SourceChannelDirectoryStream$FilterWatchEvent$KindWatchEvent$ModifierPolicy$ParametersProtectionDomain$KeyProvider$ServiceAttributedCharacterIterator$AttributeFormat$FieldFormat$FieldDelegateDateTimeFormatterBuilder$CompositePrinterParserDateTimeFormatterBuilder$DateTimePrinterParserZoneOffsetTransitionRule$TimeDefinitionAbstractMap$SimpleEntryAbstractMap$SimpleImmutableEntryLinkedList$NodeLocale$CategoryLocale$FilteringModeLocale$LanguageRangePrimitiveIterator$OfDoublePrimitiveIterator$OfIntPrimitiveIterator$OfLongResourceBundle$ControlSpliterator$OfDoubleSpliterator$OfPrimitiveSpliterator$OfIntSpliterator$OfLongSpliterators$AbstractSpliteratorTreeMap$EntryArrayBlockingQueue$ItrArrayBlockingQueue$ItrsCompletableFuture$AsynchronousCompletionTaskCompletableFuture$AltResultCompletableFuture$BiApplyCompletableFuture$BiCompletionCompletableFuture$UniCompletionCompletableFuture$BiRunCompletableFuture$BiAcceptCompletableFuture$CompletionCompletableFuture$OrAcceptCompletableFuture$OrApplyCompletableFuture$OrRunCompletableFuture$UniApplyCompletableFuture$UniAcceptCompletableFuture$UniComposeCompletableFuture$UniExceptionallyCompletableFuture$UniHandleCompletableFuture$UniRunCompletableFuture$UniWhenCompleteConcurrentHashMap$CollectionViewConcurrentHashMap$KeySetViewConcurrentHashMap$NodeConcurrentLinkedQueue$NodeConcurrentSkipListMap$CSLMSpliteratorConcurrentSkipListMap$IndexConcurrentSkipListMap$NodeConcurrentSkipListMap$EntrySpliteratorConcurrentSkipListMap$KeySpliteratorConcurrentSkipListMap$ValueSpliteratorForkJoinPool$ForkJoinWorkerThreadFactoryForkJoinPool$ManagedBlockerForkJoinPool$WorkQueueLinkedBlockingDeque$NodeLinkedBlockingQueue$NodeAbstractQueuedSynchronizer$ConditionObjectAbstractQueuedSynchronizer$NodeReentrantReadWriteLock$ReadLockReentrantReadWriteLock$SyncReentrantReadWriteLock$WriteLockStampedLock$ReadLockViewStampedLock$ReadWriteLockViewStampedLock$WriteLockViewAttributes$NameManifest$FastInputStreamLogManager$LogNodeLogManager$LoggerContextLogManager$LoggerWeakRefPattern$GroupHeadPattern$NodePattern$TreeInfoCollector$CharacteristicsDoubleStream$BuilderIntStream$BuilderLongStream$BuilderStream$BuilderFilterRegistration$DynamicRegistration$DynamicServletRegistration$DynamicServletSecurity$EmptyRoleSemanticServletSecurity$TransportGuaranteeJComboBox$KeySelectionManagerJInternalFrame$JDesktopIconJList$DropLocationJMenu$WinListenerJRootPane$DefaultActionJTable$DropLocationJTable$PrintModeJTree$DropLocationJTree$TreeSelectionRedirectorJViewport$ViewListenerLayoutStyle$ComponentPlacementRowSorter$SortKeyTimerQueue$DelayedTimerTransferHandler$DropLocationTransferHandler$HasGetTransferHandlerTransferHandler$TransferSupportUIManager$LookAndFeelInfoDocumentEvent$ElementChangeDocumentEvent$EventTypeHyperlinkEvent$EventTypeRowSorterEvent$TypeAbstractDocument$AbstractElementAbstractDocument$AttributeContextAbstractDocument$ContentAbstractDocument$DefaultDocumentEventDefaultCaret$HandlerDefaultStyledDocument$ElementBuffer$ElemChangesDefaultStyledDocument$ElementBufferDefaultStyledDocument$ElementSpecDocumentFilter$FilterBypassGlyphView$GlyphPainterGlyphView$JustificationInfoHighlighter$HighlightHighlighter$HighlightPainterJTextComponent$DropLocationJTextComponent$KeyBindingNavigationFilter$FilterBypassPosition$BiasStyleContext$SmallAttributeSetHTML$AttributeHTML$TagDiagnostic$KindDocumentationTool$DocumentationTaskJavaCompiler$CompilationTaskJavaFileManager$LocationJavaFileObject$KindCodePointBuffer$BuilderCodePointBuffer$TypeATNDeserializer$UnicodeDeserializerATNDeserializer$UnicodeDeserializingModeLexerATNSimulator$SimStatePredictionContext$IdentityHashMapFlexibleHashMap$EntrySemanticContext$PrecedencePredicateSemanticContext$PredicateDFAState$PredPredictionMathArrays$FunctionMathArrays$OrderDirectionMathArrays$PositionLexerFrame$HScrollableTextPaneAstBuilderTransformation$AstBuilderInvocationTrapAnnotationClosureVisitor$ClosureExpressionValidatorAnnotationClosureVisitor$OldPropertyExpressionTransformerAssertStatementCreationUtility$AddAssertionCallStatementToReturnStatementVisitorAssertStatementCreationUtility$AddResultReturnStatementVisitorAssertStatementCreationUtility$ReturnStatementVisitorContractExecutionTracker$ContractExecutionContractExecutionTracker$ContractExecutionThreadLocalExpressionUtils$AssertStatementCollectorLifecycleImplementationLoader$LazyIteratorQueryable$OrderQueryableCollection$BucketQueryableCollection$CandidateQueryableCollection$PartitionCacheKeyQueryableCollection$SortedPartitionCacheKeyQueryableHelper$ThreadPoolHolderExceptions$JsonInternalExceptionFastStringUtils$ServiceHolderFileType.classPickFirstResolver.classAstBuilder$DeclarationListStatementAstBuilder$PropertyExpanderGroovyLangLexer$PositionAdjustingLexerATNSimulatorGroovyLangParser$LightWeightFailedPredicateExceptionGroovyLexer$ParenGroovyParser$AdditiveExprAltContextGroovyParser$AndExprAltContextGroovyParser$AnnotatedQualifiedClassNameContextGroovyParser$AnnotationContextGroovyParser$AnnotationNameContextGroovyParser$AnnotationsOptContextGroovyParser$AnonymousInnerClassDeclarationContextGroovyParser$ArgumentsContextGroovyParser$ArrayInitializerContextGroovyParser$AssertStatementContextGroovyParser$AssertStmtAltContextGroovyParser$AssignmentExprAltContextGroovyParser$BlockContextGroovyParser$BlockStatementContextGroovyParser$BlockStatementsContextGroovyParser$BlockStatementsOptContextGroovyParser$BlockStmtAltContextGroovyParser$BooleanLiteralAltContextGroovyParser$BreakStatementContextGroovyParser$BreakStmtAltContextGroovyParser$BuiltInTypeContextGroovyParser$BuiltInTypePrmrAltContextGroovyParser$CastExprAltContextGroovyParser$CastParExpressionContextGroovyParser$CatchClauseContextGroovyParser$CatchTypeContextGroovyParser$ClassBodyContextGroovyParser$ClassBodyDeclarationContextGroovyParser$ClassDeclarationContextGroovyParser$ClassNameContextGroovyParser$ClassOrInterfaceModifierContextGroovyParser$ClassOrInterfaceModifiersContextGroovyParser$ClassOrInterfaceModifiersOptContextGroovyParser$ClassOrInterfaceTypeContextGroovyParser$ClassicalForControlContextGroovyParser$ClosureContextGroovyParser$ClosureOrLambdaExpressionContextGroovyParser$ClosureOrLambdaExpressionPrmrAltContextGroovyParser$CommandArgumentContextGroovyParser$CommandExprAltContextGroovyParser$CommandExpressionContextGroovyParser$CompactConstructorDeclarationContextGroovyParser$CompilationUnitContextGroovyParser$ConditionalExprAltContextGroovyParser$ConditionalStatementContextGroovyParser$ConditionalStmtAltContextGroovyParser$ContinueStatementContextGroovyParser$ContinueStmtAltContextGroovyParser$CreatedNameContextGroovyParser$CreatorContextGroovyParser$DimContextGroovyParser$DoWhileStmtAltContextGroovyParser$DynamicMemberNameContextGroovyParser$ElementValueArrayInitializerContextGroovyParser$ElementValueContextGroovyParser$ElementValuePairContextGroovyParser$ElementValuePairNameContextGroovyParser$ElementValuePairsContextGroovyParser$ElementValuesContextGroovyParser$EmptyDimsOptContextGroovyParser$EmptyDimsContextGroovyParser$EmptyStmtAltContextGroovyParser$EnhancedArgumentListElementContextGroovyParser$EnhancedArgumentListInParContextGroovyParser$EnhancedForControlContextGroovyParser$EnhancedStatementExpressionContextGroovyParser$EnumConstantContextGroovyParser$EnumConstantsContextGroovyParser$EqualityExprAltContextGroovyParser$ExclusiveOrExprAltContextGroovyParser$ExpressionContextGroovyParser$ExpressionInParContextGroovyParser$ExpressionListContextGroovyParser$ExpressionListElementContextGroovyParser$ExpressionStmtAltContextGroovyParser$FieldDeclarationContextGroovyParser$FinallyBlockContextGroovyParser$FloatingPointLiteralAltContextGroovyParser$ForControlContextGroovyParser$ForInitContextGroovyParser$ForStmtAltContextGroovyParser$ForUpdateContextGroovyParser$FormalParameterContextGroovyParser$FormalParameterListContextGroovyParser$FormalParametersContextGroovyParser$GroovyParserRuleContextGroovyParser$GstringPathContextGroovyParser$GstringContextGroovyParser$GstringValueContextGroovyParser$GstringPrmrAltContextGroovyParser$IdentifierContextGroovyParser$IdentifierPrmrAltContextGroovyParser$IfElseStatementContextGroovyParser$ImportDeclarationContextGroovyParser$IndexPropertyArgsContextGroovyParser$InclusiveOrExprAltContextGroovyParser$IntegerLiteralAltContextGroovyParser$KeywordsContextGroovyParser$LabeledStmtAltContextGroovyParser$LambdaBodyContextGroovyParser$ListContextGroovyParser$ListPrmrAltContextGroovyParser$LiteralContextGroovyParser$LiteralPrmrAltContextGroovyParser$LocalVariableDeclarationContextGroovyParser$LocalVariableDeclarationStmtAltContextGroovyParser$LogicalAndExprAltContextGroovyParser$LogicalOrExprAltContextGroovyParser$LoopStatementContextGroovyParser$LoopStmtAltContextGroovyParser$MapContextGroovyParser$MapEntryLabelContextGroovyParser$MapEntryContextGroovyParser$MapEntryListContextGroovyParser$MapPrmrAltContextGroovyParser$MemberDeclarationContextGroovyParser$MethodBodyContextGroovyParser$MethodDeclarationContextGroovyParser$MethodNameContextGroovyParser$ModifiersContextGroovyParser$ModifierContextGroovyParser$ModifiersOptContextGroovyParser$MultipleAssignmentExprAltContextGroovyParser$MultiplicativeExprAltContextGroovyParser$NamePartContextGroovyParser$NamedPropertyArgsContextGroovyParser$NewPrmrAltContextGroovyParser$NlsContextGroovyParser$NonWildcardTypeArgumentsContextGroovyParser$NullLiteralAltContextGroovyParser$PackageDeclarationContextGroovyParser$ParExpressionContextGroovyParser$ParenPrmrAltContextGroovyParser$PathElementContextGroovyParser$PathExpressionContextGroovyParser$PostfixExprAltContextGroovyParser$PostfixExpressionContextGroovyParser$PowerExprAltContextGroovyParser$PrimaryContextGroovyParser$PrimitiveTypeContextGroovyParser$QualifiedClassNameContextGroovyParser$QualifiedClassNameListContextGroovyParser$QualifiedNameContextGroovyParser$QualifiedNameElementContextGroovyParser$QualifiedNameElementsContextGroovyParser$QualifiedStandardClassNameContextGroovyParser$RelationalExprAltContextGroovyParser$RegexExprAltContextGroovyParser$ResourceContextGroovyParser$ResourceListContextGroovyParser$ResourcesContextGroovyParser$ReturnStmtAltContextGroovyParser$ReturnTypeContextGroovyParser$RparenContextGroovyParser$ScriptStatementContextGroovyParser$ScriptStatementsContextGroovyParser$SepContextGroovyParser$ShiftExprAltContextGroovyParser$StandardLambdaExpressionContextGroovyParser$StandardLambdaParametersContextGroovyParser$StatementContextGroovyParser$StringLiteralAltContextGroovyParser$StatementExpressionContextGroovyParser$StringLiteralContextGroovyParser$SuperPrmrAltContextGroovyParser$SwitchBlockStatementExpressionGroupContextGroovyParser$SwitchBlockStatementGroupContextGroovyParser$SwitchExprAltContextGroovyParser$SwitchExpressionContextGroovyParser$SwitchExpressionLabelContextGroovyParser$SwitchLabelContextGroovyParser$SwitchStatementContextGroovyParser$SynchronizedStmtAltContextGroovyParser$ThisFormalParameterContextGroovyParser$ThisPrmrAltContextGroovyParser$ThrowStmtAltContextGroovyParser$TryCatchStatementContextGroovyParser$TryCatchStmtAltContextGroovyParser$TypeArgumentContextGroovyParser$TypeArgumentsContextGroovyParser$TypeArgumentsOrDiamondContextGroovyParser$TypeBoundContextGroovyParser$TypeContextGroovyParser$TypeDeclarationContextGroovyParser$TypeListContextGroovyParser$TypeNamePairContextGroovyParser$TypeParameterContextGroovyParser$TypeNamePairsContextGroovyParser$TypeParametersContextGroovyParser$UnaryAddExprAltContextGroovyParser$UnaryNotExprAltContextGroovyParser$VariableDeclarationContextGroovyParser$VariableDeclaratorContextGroovyParser$VariableDeclaratorIdContextGroovyParser$VariableDeclaratorsContextGroovyParser$VariableInitializerContextGroovyParser$VariableInitializersContextGroovyParser$VariableModifierContextGroovyParser$VariableModifiersContextGroovyParser$VariableModifiersOptContextGroovyParser$VariableNamesContextGroovyParser$WhileStmtAltContextGroovyParser$YieldStatementContextGroovyParser$YieldStmtAltContextAtnManager$AtnWrapperDefaultRunners$Junit3SuiteRunnerDefaultRunners$Junit3TestRunnerDefaultRunners$Junit4TestRunnerSqlExtensions$ResultSetMetaDataIteratorBindingProxy$ModelBindingPropertyBindingEventTriggerBinding$EventTriggerFullBindingPropertyBinding$PropertyFullBindingPropertyBinding$UpdateStrategyJavaShell$BytesJavaFileManagerJavaShell$BytesJavaFileObjectJavaShell$JavaShellClassLoaderConcurrentReferenceHashMap$CachedEntryIteratorConcurrentReferenceHashMap$EntryIteratorConcurrentReferenceHashMap$EntrySetConcurrentReferenceHashMap$HashEntryConcurrentReferenceHashMap$HashIteratorConcurrentReferenceHashMap$InitializableEntryConcurrentReferenceHashMap$KeyIteratorConcurrentReferenceHashMap$KeyReferenceConcurrentReferenceHashMap$KeySetConcurrentReferenceHashMap$OptionConcurrentReferenceHashMap$ReferenceTypeConcurrentReferenceHashMap$SegmentConcurrentReferenceHashMap$SimpleEntryConcurrentReferenceHashMap$SoftKeyReferenceConcurrentReferenceHashMap$SoftValueReferenceConcurrentReferenceHashMap$ValueIteratorConcurrentReferenceHashMap$ValuesConcurrentReferenceHashMap$WeakKeyReferenceConcurrentReferenceHashMap$WeakValueReferenceConcurrentReferenceHashMap$WriteThroughEntryConcurrentLinkedHashMap$AddTaskConcurrentLinkedHashMap$NodeConcurrentLinkedHashMap$WeightedValueConcurrentLinkedHashMap$BoundedEntryWeigherConcurrentLinkedHashMap$BuilderConcurrentLinkedHashMap$DiscardingListenerConcurrentLinkedHashMap$DiscardingQueueConcurrentLinkedHashMap$DrainStatusConcurrentLinkedHashMap$EntryIteratorConcurrentLinkedHashMap$EntrySetConcurrentLinkedHashMap$KeyIteratorConcurrentLinkedHashMap$KeySetConcurrentLinkedHashMap$RemovalTaskConcurrentLinkedHashMap$SerializationProxyConcurrentLinkedHashMap$UpdateTaskConcurrentLinkedHashMap$ValueIteratorConcurrentLinkedHashMap$ValuesConcurrentLinkedHashMap$WriteThroughEntryLinkedDeque$AbstractLinkedIteratorWeighers$ByteArrayWeigherWeighers$CollectionWeigherWeighers$EntryWeigherViewWeighers$IterableWeigherWeighers$ListWeigherWeighers$MapWeigherWeighers$SetWeigherWeighers$SingletonEntryWeigherWeighers$SingletonWeigherIntrospectionHelper$CreatorLineContains$ContainsReplaceTokens$TokenStripLineComments$CommentTokenFilter$ChainableReaderFilterTokenFilter$ContainsRegexTokenFilter$ContainsStringTokenFilter$DeleteCharactersTokenFilter$FileTokenizerTokenFilter$FilterTokenFilter$IgnoreBlankTokenFilter$ReplaceRegexTokenFilter$ReplaceStringTokenFilter$StringTokenizerTokenFilter$TrimChainReaderHelper$ChainReaderProjectHelper2$AntHandlerProjectHelper2$ElementHandlerProjectHelper2$RootHandlerProjectHelper2$TargetHandlerJavac$ImplementationSpecificArgumentAssertions$BaseAssertionAssertions$DisabledAssertionAssertions$EnabledAssertionCommandline$ArgumentCommandline$MarkerCommandlineJava$SysPropertiesEnvironment$VariableFileList$FileNameFilterSet$FilterFilterSet$FiltersFileFilterSet$OnMissingMapper$MapperTypePath$PathElementPatternSet$NameEntryPermissions$PermissionPropertySet$BuiltinPropertySetNamePropertySet$PropertyRefDateSelector$TimeComparisonsSizeSelector$ByteUnitsSizeSelector$SizeComparisonsTypeSelector$FileTypePresentSelector$FilePresenceModifiedSelector$AlgorithmNameModifiedSelector$CacheNameModifiedSelector$ComparatorNameUberCompileTask$GroovycAdapterUberCompileTask$GenStubsAdapterUberCompileTask$JavacAdapterClassHelper$ClassHelperCacheClassNode$MapOfListsCompileUnit$ConstructedOuterNestedClassNodeGenericsType$GenericsTypeNameGroovy7826$C1Groovy7826$C2AstSpecificationCompiler.classAsmDecompiler$AnnotationReaderAsmDecompiler$DecompilingVisitorAsmDecompilerTestData$Inner$WithDollarAsmDecompilerTestData$InnerAsmDecompilerTestData$InnerStaticAsmDecompilerTestData<>.classAnnotations$DecompiledAnnotationNodeGroovy8632$BuilderGroovy8632$InnerBuilderGroovy8632$InnerPrivateGroovy8632$InnerProtectedGroovy8632Abstract$BuilderGroovy8632Abstract$InnerBuilderGenericsUtils$ParameterizedTypeCacheKeyWideningCategories$LowestUpperBoundClassNodeA_GroovyReflector$ADumpingClassLoader$DebugCollectorFinalVariableAnalyzer$StateMapFinalVariableAnalyzer$VariableNotFinalCallbackFinalVariableAnalyzer$VariableStateReturnAdder$ReturnStatementListenerVariableScopeVisitor$StateStackElementVerifier$DefaultArgsActionVerifier$SwapInitStatementVerifier$SwapInitStatement$SwapInitInstructionAssertionWriter$AssertionTrackerBinaryExpressionMultiTypeDispatcher$BinaryByteExpressionHelperBinaryExpressionMultiTypeDispatcher$BinaryShortExpressionHelperBytecodeHelper$LoadVarHandlerBytecodeHelper$PrimitiveTypeHandlerBytecodeHelper$ReturnVarHandlerBytecodeHelper$StoreVarHandlerBinaryExpressionMultiTypeDispatcher$BinaryCharExpressionHelperClosureWriter$CorrectAccessedVariableVisitorClosureWriter$UseExistingReferenceCompileStack$BlockRecorderCompileStack$ExceptionTableEntryCompileStack$StateStackElementCompileStack$LabelRangeMopWriter$FactoryMopWriter$MopKeyOptimizingStatementWriter$ClassNodeSkipOptimizingStatementWriter$FastPathDataOptimizingStatementWriter$OptVisitorOptimizingStatementWriter$OptimizeFlagsCollector$OptimizeFlagsEntryOptimizingStatementWriter$OptimizeFlagsCollectorOptimizingStatementWriter$StatementMetaIndyStaticTypesMultiTypeDispatcher$GenericArrayAccessGroovy6955Support$RequestStaticInvocationWriter$CheckcastReceiverExpressionStaticPropertyAccessHelper$PoppingListOfExpressionsExpressionStaticPropertyAccessHelper$PoppingMethodCallExpressionGroovy7363Support$AGroovy7363Support$BGroovy7363Support$ABCGroovy7363Support$BCGroovy7363Support$CGroovy7538Support$AbstractAssertGroovy7538Support$AbstractCharSequenceAssertGroovy7538Support$StringAssertStaticTypesClosureWriter$MethodTargetCompletionVisitorClassNodeResolver$LookupResultCompilationUnit$ClassgenCallbackCompilationUnit$GroovyClassOperationCompilationUnit$IGroovyClassOperationCompilationUnit$IPrimaryClassNodeOperationCompilationUnit$ISourceUnitOperationCompilationUnit$PhaseOperationCompilationUnit$PrimaryClassNodeOperationCompilationUnit$ProgressCallbackCompilationUnit$SourceUnitOperationResolveVisitor$ConstructedClassWithPackageResolveVisitor$ConstructedNestedClassResolveVisitor$InterruptResolveVisitor$LowerCaseClassImportCustomizer$ImportImportCustomizer$ImportTypeSecureASTCustomizer$ExpressionCheckerSecureASTCustomizer$SecuringCodeVisitorSecureASTCustomizer$StatementCheckerImportCustomizerFactory$ImportHelperSourceAwareCustomizerFactory$SourceOptionsAbstractReaderSourceTest$AbstractReaderSourceSubclassJSR223SecurityTest$TestFixtureScriptException.classMatchingConstraintsBuilder.classMatchingConstraints.classContextualClassCodeVisitor$MatchByClassConstraintPredicate<>.classImmutablePropertyHandler.classTreeContext$TreeContextKeyTreeContext.classASTNode.classMacroGroovyMethods$MacroValuePlaceholderToken.classMacroValuePlaceholder.classMacroClassTransformation$MacroClassTransformerMacroClassTransformation$MacroClassTransformingCodeVisitorCachedClass$CachedMethodComparatorByNameCachedClass$CachedMethodComparatorWithStringClassInfo$ClassInfoActionClassInfo$GlobalClassSetClassInfo$LazyCachedClassRefClassInfo$LazyClassLoaderRefGeneratedMetaMethod$DgmMethodRecordGeneratedMetaMethod$ProxyGroovyClassValue$ComputeValueGroovyClassValuePreJava7$EntryWithValueManagedConcurrentMap$EntryWithValueManagedConcurrentMap$EntryAbstractConcurrentMap$EntryAbstractConcurrentMapBase$EntryManagedConcurrentMap$SegmentAbstractConcurrentMap$SegmentGroovyClassValuePreJava7$GroovyClassValuePreJava7MapGroovyClassValuePreJava7$GroovyClassValuePreJava7SegmentReflectionUtils$ClassContextHelperSecurityTest$TestClassSecurityTest$TestGroovyClassDefaultGroovyMethods$DropRightIteratorDefaultGroovyMethods$DropWhileIteratorDefaultGroovyMethods$InitIteratorDefaultGroovyMethods$IteratorIterableAdapterDefaultGroovyMethods$NumberAwareValueComparatorDefaultGroovyMethods$TakeIteratorDefaultGroovyMethods$TakeWhileIteratorDefaultGroovyMethods$ToUniqueIteratorDefaultGroovyMethods$ZipPostIteratorDefaultGroovyMethods$ZipPreIteratorComponent.classFirstGenericType.classFirstParam.classMapEntryOrKeyValue.classGroovyCategorySupport$CategoryMethodGroovyCategorySupport$CategoryMethodListGroovyCategorySupport$MyThreadLocalGroovyCategorySupport$ThreadCategoryInfoHandleMetaClass$HolderInterfaceConversionMapTest$SomeInterfaceInvokerHelper$NullScriptInvokerHelperTest$MyList5802MethodRankHelper$NullObjectMethodRankHelper$PairMethodRankHelper$RankableConstructorMethodRankHelper$RankableFieldMethodRankHelper$RankableMethodMethodRankHelperTest$TempClassProcessGroovyMethods$ProcessRunnerProcessGroovyMethods$TextDumperProxyGeneratorAdapter$InnerLoaderProxyGeneratorAdapter$ReturnValueWrappingClosureProcessGroovyMethods$ByteDumperStringGroovyMethods$CharacterIteratorStringGroovyMethods$LineIterableStringGroovyMethods$ReplaceStateStringGroovyMethods$StringIteratorConstructorSite$ConstructorSiteNoUnwrapConstructorSite$ConstructorSiteNoUnwrapNoCoerceConstructorSite$NoParamSiteConstructorSite$NoParamSiteInnerClassPogoMetaMethodSite$PogoCachedMethodSitePogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoercePogoMetaMethodSite$PogoMetaMethodSiteNoUnwrapPogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapPogoMetaMethodSite$PogoMetaMethodSiteNoUnwrapNoCoercePojoMetaMethodSite$PojoCachedMethodSitePojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapPojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapNoCoercePojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapPojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerceStaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapStaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapNoCoerceNumberNumberDiv$DoubleDoubleNumberNumberDiv$DoubleFloatNumberNumberDiv$DoubleIntegerNumberNumberDiv$DoubleLongNumberNumberDiv$FloatDoubleNumberNumberDiv$FloatFloatNumberNumberDiv$FloatIntegerNumberNumberDiv$FloatLongNumberNumberDiv$IntegerDoubleNumberNumberDiv$IntegerFloatNumberNumberDiv$LongDoubleNumberNumberDiv$LongFloatNumberNumberDiv$NumberNumberNumberNumberMetaMethod$NumberNumberCallSiteNumberNumberMinus$DoubleDoubleNumberNumberMinus$DoubleFloatNumberNumberMinus$DoubleIntegerNumberNumberMinus$DoubleLongNumberNumberMinus$FloatDoubleNumberNumberMinus$FloatFloatNumberNumberMinus$FloatIntegerNumberNumberMinus$FloatLongNumberNumberMinus$IntegerDoubleNumberNumberMinus$IntegerFloatNumberNumberMinus$IntegerIntegerNumberNumberMinus$IntegerLongNumberNumberMinus$LongDoubleNumberNumberMinus$LongFloatNumberNumberMinus$LongIntegerNumberNumberMinus$LongLongNumberNumberMinus$NumberNumberNumberNumberMultiply$DoubleDoubleNumberNumberMultiply$DoubleFloatNumberNumberMultiply$DoubleIntegerNumberNumberMultiply$DoubleLongNumberNumberMultiply$FloatFloatNumberNumberMultiply$FloatIntegerNumberNumberMultiply$FloatLongNumberNumberMultiply$IntegerDoubleNumberNumberMultiply$IntegerFloatNumberNumberMultiply$IntegerIntegerNumberNumberMultiply$IntegerLongNumberNumberMultiply$LongDoubleNumberNumberMultiply$LongFloatNumberNumberMultiply$FloatDoubleNumberNumberMultiply$LongIntegerNumberNumberMultiply$LongLongNumberNumberMultiply$NumberNumberNumberNumberPlus$DoubleDoubleNumberNumberPlus$DoubleFloatNumberNumberPlus$DoubleIntegerNumberNumberPlus$DoubleLongNumberNumberPlus$FloatDoubleNumberNumberPlus$FloatFloatNumberNumberPlus$FloatIntegerNumberNumberPlus$FloatLongNumberNumberPlus$IntegerDoubleNumberNumberPlus$IntegerFloatNumberNumberPlus$IntegerIntegerNumberNumberPlus$IntegerLongNumberNumberPlus$LongDoubleNumberNumberPlus$LongFloatNumberNumberPlus$LongIntegerNumberNumberPlus$LongLongBooleanArrayGetAtMetaMethod$MyPojoMetaMethodSiteBooleanArrayPutAtMetaMethod$MyPojoMetaMethodSiteByteArrayGetAtMetaMethod$MyPojoMetaMethodSiteByteArrayPutAtMetaMethod$MyPojoMetaMethodSiteCharacterArrayGetAtMetaMethod$MyPojoMetaMethodSiteCharacterArrayPutAtMetaMethod$MyPojoMetaMethodSiteDoubleArrayGetAtMetaMethod$MyPojoMetaMethodSiteDoubleArrayPutAtMetaMethod$MyPojoMetaMethodSiteFloatArrayGetAtMetaMethod$MyPojoMetaMethodSiteFloatArrayPutAtMetaMethod$MyPojoMetaMethodSiteIntegerArrayGetAtMetaMethod$MyPojoMetaMethodSiteIntegerArrayPutAtMetaMethod$MyPojoMetaMethodSiteLongArrayGetAtMetaMethod$MyPojoMetaMethodSiteLongArrayPutAtMetaMethod$MyPojoMetaMethodSiteObjectArrayGetAtMetaMethod$MyPojoMetaMethodSiteObjectArrayPutAtMetaMethod$MyPojoMetaMethodSiteShortArrayGetAtMetaMethod$MyPojoMetaMethodSiteShortArrayPutAtMetaMethod$MyPojoMetaMethodSiteExtensionModuleScanner$ExtensionModuleListenerMemoizeCache$ValueProviderEvictableCache$ActionEvictableCache$EvictionStrategyMemoize$MemoizeFunctionMemoize$MemoizeNullValueMemoize$SoftReferenceMemoizeFunctionClosureMetaClass$MethodChooserClosureMetaClass$NormalMethodChooserClosureMetaClass$StandardClosureChooserClosureMetaMethod$AnonymousMetaMethodClosureMetaMethod$MethodClosureMetaMethodConcurrentReaderHashMap$BarrierLockConcurrentReaderHashMap$EntryConcurrentReaderHashMap$EntrySetConcurrentReaderHashMap$HashIteratorConcurrentReaderHashMap$KeyIteratorConcurrentReaderHashMap$KeySetConcurrentReaderHashMap$ValueIteratorConcurrentReaderHashMap$ValuesDefaultMetaClassInfo$ConstantMetaClassVersioningMetaClassRegistryImpl$DefaultModuleListenerMetaMethodIndex$CacheEntryMetaMethodIndex$EntryMetaMethodIndex$EntryIteratorMetaMethodIndex$HeaderMethodMetaProperty$GetBeanMethodMetaPropertyMethodMetaProperty$GetMethodMetaPropertyThreadManagedMetaBeanProperty$ThreadBoundSetterThreadManagedMetaBeanProperty$ThreadBoundGetterFileSystemCompiler$CompilationOptionsFileSystemCompiler$VersionProviderSimpleGroovyRootDoc$ClassNamedCache$EntrySimpleGroovyRootDoc$ClassNamedCacheExampleVisibilityJ$A1ExampleVisibilityJ$A2ExampleVisibilityJ$BExampleVisibilityJ$CExampleVisibilityJ$DJavaStaticNestedClassWithDiamond$NestedCommandLine$ITypeConverterNoCompletionCandidates.classNullParameterConsumer.classStaticList$ListStaticList$ListAliasIO$VerbosityASTTransformationVisitor$PriorityComparatorAnnotationCollectorTransform$ClassChangerBuilderASTTransformation$AbstractBuilderStrategy$PropertyInfoBuilderASTTransformation$AbstractBuilderStrategyBuilderASTTransformation$BuilderStrategyDelegateASTTransformation$DelegateDescriptionLogASTTransformation$AbstractLoggingStrategyLogASTTransformation$AbstractLoggingStrategyV2LogASTTransformation$LoggingStrategyLogASTTransformation$LoggingStrategyV2NewifyASTTransformation$NewifyClassDataToStringASTTransformation$ToStringElementBooleanExpressionTransformer$OptimizingBooleanExpressionConstructorCallTransformer$MapStyleConstructorCallAbstractTypeCheckingExtension$TypeCheckingScopeGroovyTypeCheckingExtensionSupport$TypeCheckingDSLStaticTypeCheckingSupport$BooleanArrayStaticTypesHelperStaticTypeCheckingSupport$ByteArrayStaticTypesHelperStaticTypeCheckingSupport$CharArrayStaticTypesHelperStaticTypeCheckingSupport$DoubleArrayStaticTypesHelperStaticTypeCheckingSupport$FloatArrayStaticTypesHelperStaticTypeCheckingSupport$IntArrayStaticTypesHelperStaticTypeCheckingSupport$LongArrayStaticTypesHelperStaticTypeCheckingSupport$ObjectArrayStaticTypesHelperStaticTypeCheckingSupport$ShortArrayStaticTypesHelperStaticTypeCheckingVisitor$ExtensionMethodDeclaringClassStaticTypeCheckingVisitor$ParameterVariableExpressionStaticTypeCheckingVisitor$SetterInfoStaticTypeCheckingVisitor$SignatureCodecFactoryStaticTypeCheckingVisitor$VariableExpressionTypeMemoizerTypeCheckingContext$EnclosingClosureTraitASTTransformation$PostTypeCheckingExpressionReplacerTraits$ImplementedTraits$TraitBridgeAbstractConcurrentMapBase$SegmentComplexKeyHashMap$EntryComplexKeyHashMap$EntryIteratorManagedConcurrentLinkedQueue$ElementManagedConcurrentLinkedQueue$ItrManagedLinkedList$ElementManagedLinkedList$IterReferenceManager$CallBackedManagerReferenceManager$ThreadedReferenceManagerReferenceType$HardRefReferenceType$PhantomRefReferenceType$SoftRefReferenceType$WeakRefSingleKeyHashMap$CopierSingleKeyHashMap$EntryTripleKeyHashMap$EntryIndyInterface$CallTypeIndyInterface$FallbackSupplierJava8$LookupHolderMethodHandleWrapper$NullMethodHandleWrapperPluginDefaultGroovyMethods$TransformedFutureSelector$CastSelectorSelector$InitSelectorSelector$MethodSelectorSelector$PropertySelectorDifferenceEngine$DifferenceFoundExceptionAnsi$AttributeAnsi$ColorAnsi$ConsumerAnsi$EraseBuild.classAntBuilder$AntMessagePriorityNamedDomainObjectCollectionSchema$NamedDomainObjectSchemaArtifactView$ViewConfigurationConfiguration$StateResolutionStrategy.classDependencySubstitutions$SubstitutionDependencyArtifact.classResolutionStrategy$SortOrderIvyArtifactRepository$MetadataSourcesMavenArtifactRepository$MetadataSourcesFileCopyDetails.classFileCollection$AntTypeProject.classVersionCatalogBuilder$AliasBuilderVersionCatalogBuilder$PluginAliasBuilderVersionCatalogBuilder$LibraryAliasBuilderBuildOption$ValueGlobal.classPluginManagerInternal$PluginWithIdPotentialPlugin$TypeProjectInternal$DetachedResolverExtensionsSchema$ExtensionSchemaExtraPropertiesExtension$UnknownPropertyExceptionBuildCacheServiceFactory$DescriberIncludedBuildTaskResource$StateTaskIdentifier$TaskBasedTaskIdentifierConfigurationTargetIdentifier$TypeNode$ExecutionStateStartParameterBuildOptions$ConfigurationCacheProblemsOption$ValueStartParameterBuildOptions$ConfigurationCacheProblemsOptionBuildLifecycleController$WorkGraphBuilderFileMetadata$AccessTypeImmutableCollection$BuilderImmutableList$BuilderMultiset$EntryDependencyResolutionManagementInternal$RepositoriesModeInternalDependencyResolutionManagementInternal$RulesModeInternalScope$GlobalScopes$BuildScopes$BuildSessionScopes$BuildTreeScopes$GradleScopes$ProjectScopes$UserHomeChildMap$Entry$PathRelationshipHandlerChildMap$EntryChildMap$NodeHandlerChildMap$InvalidationHandlerChildMap$StoreHandlerFileSystemLocationSnapshot$FileSystemLocationSnapshotTransformerFileSystemLocationSnapshot$FileSystemLocationSnapshotVisitorSnapshotHierarchy$NodeDiffListenerImplementationSnapshot$UnknownReasonWorkerLeaseRegistry$WorkerLeaseWorkerLeaseRegistry$WorkerLeaseCompletionModelNode$StateModelPath$InvalidNameExceptionModelPath$InvalidPathExceptionUnboundRule$BuilderUnboundRuleInput$BuilderInputNormalizationHandlerInternal$CachedStateRuntimeClasspathNormalizationInternal$CachedStateTest$NoneDumperOptions$FlowStyleDumperOptions$LineBreakDumperOptions$NonPrintableStyleDumperOptions$ScalarStyleEvent$IDDumperOptions$VersionToken$IDCommandLine$AbstractHandlerCommandLine$CommandCommandLine$DefaultExceptionHandlerCommandLine$IExceptionHandler2CommandLine$ExecutionExceptionCommandLine$Help$Ansi$IStyleCommandLine$Help$Ansi$TextCommandLine$Help$AnsiCommandLine$ArgGroupCommandLine$Help$ColorScheme$BuilderCommandLine$Help$ColorSchemeCommandLine$Help$Column$OverflowCommandLine$Help$ColumnCommandLine$Help$IOptionRendererCommandLine$Help$IParamLabelRendererCommandLine$Help$IParameterRendererCommandLine$Help$LayoutCommandLine$Help$TextTable$CellCommandLine$Help$TextTableCommandLine$Help$VisibilityCommandLine$HelpCommandLine$IDefaultValueProviderCommandLine$IExceptionHandlerCommandLine$IExecutionExceptionHandlerCommandLine$IExecutionStrategyCommandLine$IExitCodeExceptionMapperCommandLine$IFactoryCommandLine$IHelpFactoryCommandLine$IHelpSectionRendererCommandLine$IModelTransformerCommandLine$INegatableOptionTransformerCommandLine$IParameterConsumerCommandLine$IParameterExceptionHandlerCommandLine$IParameterPreprocessorCommandLine$IParseResultHandlerCommandLine$IParseResultHandler2CommandLine$IVersionProviderCommandLine$Model$ArgGroupSpec$BuilderCommandLine$Model$ArgGroupSpecCommandLine$Model$ArgSpec$BuilderCommandLine$Model$ArgSpecCommandLine$Model$CommandUserObjectCommandLine$Model$CommandSpecCommandLine$Model$IAnnotatedElementCommandLine$Model$IGetterCommandLine$Model$IOrderedCommandLine$Model$IScopeCommandLine$Model$ISetterCommandLine$Model$ITypeInfoCommandLine$Model$InterpolatorCommandLine$Model$MessagesCommandLine$Model$OptionSpec$BuilderCommandLine$Model$OptionSpecCommandLine$Model$ParserSpecCommandLine$Model$PositionalParamSpecCommandLine$Model$PositionalParamSpec$BuilderCommandLine$Model$UnmatchedArgsBindingCommandLine$Model$UsageMessageSpecCommandLine$ModelCommandLine$NoCompletionCandidatesCommandLine$NoDefaultProviderCommandLine$NoOpModelTransformerCommandLine$NullParameterConsumerCommandLine$NoOpParameterPreprocessorCommandLine$OptionCommandLine$ParameterExceptionCommandLine$ParametersCommandLine$ParseResult$BuilderCommandLine$ParseResult$GroupMatchContainerCommandLine$ParseResult$GroupMatchCommandLine$ParseResult$GroupValidationResultCommandLine$ParseResult$GroupValidationResult$TypeCommandLine$ParseResultCommandLine$PicocliExceptionCommandLine$RangeCommandLine$ScopeTypeCommandLine$TraceLevelCommandLine$TracerCommandLine$UnmatchedCausedFocusEvent$CauseSurfaceManager$FlushableCacheDataSurfaceManager$ImageAccessorDisposer$PollDisposableStateTrackable$StateGraphicsPrimitive$GeneralUnaryOpGraphicsPrimitive$GeneralBinaryOpAAShapePipe$TileStatep14URLClassPath$LoaderInternalLocaleBuilder$CaseInsensitiveCharInternalLocaleBuilder$CaseInsensitiveStringReflectorGeneratorTestimport Mapimport NodeMetaDataHandlerimport org.antlr.v4.runtime.atn.*import DFAimport org.antlr.v4.runtime.*import org.antlr.v4.runtime.misc.*import org.antlr.v4.runtime.tree.*import Listimport Iteratorimport ArrayList{ ... }<Expr>;...=...import Dequeimport ArrayDequeimport HashMapimport Setimport HashSetimport Collectionsimport Arraysimport Loggerimport Levelimport EmptyStackExceptionimport Mapsimport static SemanticPredicates.*import Lexerimport CharStreamimport Tokenimport TokenStreamnew ArrayDeque<Paren>(...)makeRuleNames(...)makeLiteralNames(...)makeSymbolicNames(...)new VocabularyImpl(...)for (...;...;...)new String[]_SYMBOLIC_NAMES.lengthint i... < ......++tokenNames.lengthif (...)...[...]getLiteralName(...)... == ...getSymbolicName(...)getLogger(...)getName(...)GroovyLexer.classdeserialize(...)new ATNDeserializer(...)toCharArray(...)int StringLiteral, ...;int RULE_compilationUnit, ...;...[]return ...new int[]sort(...)...[] ruleNames;...[] _LITERAL_NAMES;...[] _SYMBOLIC_NAMES;Vocabulary VOCABULARY;...[] tokenNames;/** @deprecated */createFailedPredicateException(...)new FailedPredicateException(...)int inSwitchExpressionLevel;Map<> metaDataMap;super(...)<obinit>(...)? ...this.metaDataMapGroovySyntaxError.PARSERvar ...;Token tokenLT(...)-...getLine(...)... + ...length(...)getCharPositionInLine(...)getText(...)new ParserATNSimulator(...)getRuleContext(...)NlsContext.classgetToken(...)GroovyParser.EOFPackageDeclarationContext.classScriptStatementsContext.classSepContext.class...instanceof...visitCompilationUnit(...)(...)...int DQ_GSTRING_MODE, ...;...[] channelNames;...[] modeNames;Logger LOGGER;boolean errorIgnored;long tokenIndex;visitChildren(...)int lastTokenType;int invalidDigitCount;/** Record the index and token type of the current token while emitting tokens. */CompilationUnitContext _localctxint tokenTypenew CompilationUnitContext(...)getType(...)getState(...)try ...this.tokenIndexenterRule(...)Token.DEFAULT_CHANNELgetChannel(...)catch (...)this.lastTokenTypeenterOuterAlt(...)switch (...)setState(...)nls(...)sync(...)adaptivePredict(...)case ...getInterpreter(...)rollbackOneChar(...)emit(...)...[] REGEX_CHECK_ARRAY;packageDeclaration(...)binarySearch(...)/** just a hook, which will be overrided by GroovyLangLexer */String text;int line;int column;this.textsep(...)this.linethis.columnscriptStatements(...)match(...)RecognitionException re... * ..._localctx.exceptionhashCode(...)reportError(...)recover(...)exitRule(...)Paren other!...... && ...equals(...)other.textother.lineother.columngetRuleContexts(...)ScriptStatementContext.classDeque<Paren> parenStack;String textenterParenCallback(...)push(...)new Paren(...)Paren parenpeek(...)exitParenCallback(...)pop(...)... || ...... != ...visitScriptStatements(...)getLastTokenType(...)isInsideParens(...)setChannel(...)Token.HIDDEN_CHANNELisFollowedByWhiteSpaces(...)GroovySyntaxError.LEXERpopMode(...)EmptyStackException ignoredisLoggable(...)Level.FINESTfinest(...)asString(...)Integer.MIN_VALUEisJavaIdentifierStart(...)isIdentifierIgnorable(...)isJavaIdentifierPart(...)this.errorIgnorednew LexerATNSimulator(...)validateInputStream(...)GStringLBrace_action(...)RollBackOne_action(...)IntegerLiteral_action(...)FloatingPointLiteral_action(...)SAFE_INDEX_action(...)LPAREN_action(...)RPAREN_action(...)LBRACE_action(...)RBRACE_action(...)LBRACK_action(...)RBRACK_action(...)NL_action(...)ML_COMMENT_action(...)SL_COMMENT_action(...)SH_COMMENT_action(...)UNEXPECTED_CHAR_action(...)enterParen(...)int readCharLA(...)setType(...)require(...)exitParen(...)ignoreTokenInsideParens(...)ignoreMultiLineCommentConditionally(...)ScriptStatementsContext _localctxnew ScriptStatementsContext(...)int _laint _altreplace(...)while (...)scriptStatement(...)ATN.INVALID_ALT_NUMBERStringLiteral_sempred(...)SlashyGStringBegin_sempred(...)DollarSlashyGStringBegin_sempred(...)SlashyGStringPart_sempred(...)DollarSlashyGStringPart_sempred(...)TdqStringCharacter_sempred(...)TsqStringCharacter_sempred(...)SlashyStringCharacter_sempred(...)DollarSlashyStringCharacter_sempred(...)NOT_INSTANCEOF_sempred(...)NOT_IN_sempred(...)ImportDeclarationContext.classCapitalizedIdentifier_sempred(...)JavaLetter_sempred(...)JavaLetterInGString_sempred(...)JavaLetterOrDigit_sempred(...)JavaLetterOrDigitInGString_sempred(...)TypeDeclarationContext.classisRegexAllowed(...)MethodDeclarationContext.classStatementContext.classisFollowedByJavaLetterInGString(...)visitScriptStatement(...)isFollowedBy(...)isUpperCase(...)isJavaIdentifierStartAndNotIdentifierIgnorable(...)toCodePoint(...)isJavaIdentifierPartAndNotIdentifierIgnorable(...)String _serializedATN;ATN _ATN;// Generated from GroovyLexer.g4 by ANTLR 4.9.0// We just care about "(", "[" and "?[", inside which the new lines will be ignored.// Notice: the new lines between "{" and "}" can not be ignored.// we don't treat try-paren(i.e. try (....)) as parenthesis// raised when parens are unmatched: too many ), ], or }// a trick to handle GStrings followed by EOF properlyScriptStatementContext _localctxnew ScriptStatementContext(...)importDeclaration(...)typeDeclaration(...)throw ...isInvalidMethodDeclaration(...)methodDeclaration(...)statement(...)AnnotationsOptContext.classGroovyParser.PACKAGEQualifiedNameContext.classvisitPackageDeclaration(...)PackageDeclarationContext _localctxnew PackageDeclarationContext(...)annotationsOpt(...)qualifiedName(...)IdentifierContext alias;GroovyParser.IMPORTGroovyParser.STATICGroovyParser.DOTGroovyParser.MULGroovyParser.ASIdentifierContext.classvisitImportDeclaration(...)import NotNullimport AbstractParseTreeVisitor/** This class provides an empty implementation of {@link GroovyParserVisitor}, ... *//** {@inheritDoc} ... */GroovyParser.IdentifierPrmrAltContextGroovyParser.LiteralPrmrAltContextGroovyParser.GstringPrmrAltContextGroovyParser.NewPrmrAltContextGroovyParser.ThisPrmrAltContextImportDeclarationContext _localctxGroovyParser.SuperPrmrAltContextGroovyParser.ParenPrmrAltContextGroovyParser.ClosureOrLambdaExpressionPrmrAltContextnew ImportDeclarationContext(...)GroovyParser.ListPrmrAltContextGroovyParser.MapPrmrAltContextGroovyParser.BuiltInTypePrmrAltContextGroovyParser.IntegerLiteralAltContextGroovyParser.FloatingPointLiteralAltContextGroovyParser.StringLiteralAltContextGroovyParser.BooleanLiteralAltContextGroovyParser.NullLiteralAltContext_localctx.aliasGroovyParser.CastExprAltContextidentifier(...)GroovyParser.PostfixExprAltContextGroovyParser.SwitchExprAltContextGroovyParser.UnaryNotExprAltContextGroovyParser.PowerExprAltContextClassOrInterfaceModifiersOptContext.classGroovyParser.UnaryAddExprAltContextClassDeclarationContext.classGroovyParser.MultiplicativeExprAltContextGroovyParser.AdditiveExprAltContextGroovyParser.ShiftExprAltContextvisitTypeDeclaration(...)GroovyParser.RelationalExprAltContextGroovyParser.EqualityExprAltContextGroovyParser.RegexExprAltContextGroovyParser.AndExprAltContextGroovyParser.ExclusiveOrExprAltContextGroovyParser.InclusiveOrExprAltContextGroovyParser.LogicalAndExprAltContextGroovyParser.LogicalOrExprAltContextGroovyParser.ConditionalExprAltContextGroovyParser.MultipleAssignmentExprAltContextGroovyParser.AssignmentExprAltContextGroovyParser.BlockStmtAltContextGroovyParser.ConditionalStmtAltContextGroovyParser.LoopStmtAltContextGroovyParser.TryCatchStmtAltContextGroovyParser.SynchronizedStmtAltContextGroovyParser.ReturnStmtAltContextGroovyParser.ThrowStmtAltContextGroovyParser.BreakStmtAltContextGroovyParser.ContinueStmtAltContextGroovyParser.YieldStmtAltContextGroovyParser.LabeledStmtAltContextGroovyParser.AssertStmtAltContextGroovyParser.LocalVariableDeclarationStmtAltContextGroovyParser.ExpressionStmtAltContextGroovyParser.EmptyStmtAltContextGroovyParser.CommandExprAltContextGroovyParser.ForStmtAltContextGroovyParser.WhileStmtAltContextGroovyParser.DoWhileStmtAltContextGroovyParser.CompilationUnitContextGroovyParser.ScriptStatementsContextGroovyParser.ScriptStatementContextGroovyParser.PackageDeclarationContextGroovyParser.ImportDeclarationContextGroovyParser.TypeDeclarationContextGroovyParser.ModifierContextGroovyParser.ModifiersOptContextGroovyParser.ModifiersContextGroovyParser.ClassOrInterfaceModifiersOptContextGroovyParser.ClassOrInterfaceModifiersContextGroovyParser.ClassOrInterfaceModifierContextGroovyParser.VariableModifierContextGroovyParser.VariableModifiersOptContextGroovyParser.VariableModifiersContextGroovyParser.TypeParametersContextGroovyParser.TypeParameterContextGroovyParser.TypeBoundContextGroovyParser.TypeListContextGroovyParser.ClassDeclarationContextGroovyParser.ClassBodyContextGroovyParser.EnumConstantsContextGroovyParser.EnumConstantContextGroovyParser.ClassBodyDeclarationContextGroovyParser.MemberDeclarationContextGroovyParser.MethodDeclarationContextGroovyParser.CompactConstructorDeclarationContextGroovyParser.MethodNameContextGroovyParser.ReturnTypeContextGroovyParser.FieldDeclarationContextGroovyParser.VariableDeclaratorsContextGroovyParser.VariableDeclaratorContextGroovyParser.VariableDeclaratorIdContextGroovyParser.VariableInitializerContextTypeDeclarationContext _localctxGroovyParser.VariableInitializersContextnew TypeDeclarationContext(...)GroovyParser.EmptyDimsContextGroovyParser.EmptyDimsOptContextclassOrInterfaceModifiersOpt(...)GroovyParser.TypeContextclassDeclaration(...)GroovyParser.ClassOrInterfaceTypeContextGroovyParser.PrimitiveTypeContextGroovyParser.TypeArgumentsContextToken m;GroovyParser.TypeArgumentContextClassOrInterfaceModifierContext.classGroovyParser.AnnotatedQualifiedClassNameContextGroovyParser.NATIVEGroovyParser.QualifiedClassNameListContextGroovyParser.SYNCHRONIZEDGroovyParser.TRANSIENTGroovyParser.FormalParametersContextGroovyParser.VOLATILEGroovyParser.DEFGroovyParser.FormalParameterListContextGroovyParser.VARGroovyParser.ThisFormalParameterContextGroovyParser.FormalParameterContextvisitModifier(...)GroovyParser.MethodBodyContextGroovyParser.QualifiedNameContextGroovyParser.QualifiedNameElementContextGroovyParser.QualifiedNameElementsContextGroovyParser.QualifiedClassNameContextGroovyParser.QualifiedStandardClassNameContextGroovyParser.LiteralContextGroovyParser.GstringContextGroovyParser.GstringValueContextGroovyParser.GstringPathContextGroovyParser.StandardLambdaExpressionContextGroovyParser.StandardLambdaParametersContextGroovyParser.LambdaBodyContextGroovyParser.ClosureContextGroovyParser.ClosureOrLambdaExpressionContextGroovyParser.BlockStatementsOptContextGroovyParser.BlockStatementsContextGroovyParser.AnnotationsOptContextGroovyParser.AnnotationContextGroovyParser.ElementValuesContextGroovyParser.AnnotationNameContextGroovyParser.ElementValuePairsContextGroovyParser.ElementValuePairContextGroovyParser.ElementValuePairNameContextGroovyParser.ElementValueContextGroovyParser.ElementValueArrayInitializerContextGroovyParser.BlockContextGroovyParser.BlockStatementContextGroovyParser.LocalVariableDeclarationContextGroovyParser.VariableDeclarationContextGroovyParser.TypeNamePairsContextGroovyParser.TypeNamePairContextGroovyParser.VariableNamesContextGroovyParser.ConditionalStatementContextGroovyParser.IfElseStatementContextGroovyParser.SwitchStatementContextGroovyParser.LoopStatementContextGroovyParser.ContinueStatementContextGroovyParser.BreakStatementContextGroovyParser.YieldStatementContextGroovyParser.TryCatchStatementContextGroovyParser.AssertStatementContextGroovyParser.StatementContextGroovyParser.CatchClauseContextGroovyParser.CatchTypeContextGroovyParser.FinallyBlockContextGroovyParser.ResourcesContextGroovyParser.ResourceListContextGroovyParser.ResourceContextGroovyParser.SwitchBlockStatementGroupContextGroovyParser.SwitchLabelContextGroovyParser.ForControlContextModifierContext _localctxnew ModifierContext(...)GroovyParser.EnhancedForControlContextGroovyParser.ClassicalForControlContextGroovyParser.ForInitContextGroovyParser.ForUpdateContextGroovyParser.CastParExpressionContextGroovyParser.ParExpressionContextGroovyParser.ExpressionInParContextclassOrInterfaceModifier(...)GroovyParser.ExpressionListContext_localctx.mGroovyParser.ExpressionListElementContextGroovyParser.EnhancedStatementExpressionContext... & ...~...GroovyParser.StatementExpressionContext... << ...... | ...GroovyParser.PostfixExpressionContextrecoverInline(...)GroovyParser.SwitchExpressionContextToken.EOFGroovyParser.SwitchBlockStatementExpressionGroupContextGroovyParser.SwitchExpressionLabelContextreportMatch(...)GroovyParser.ExpressionContextconsume(...)new NoViableAltException(...)GroovyParser.CommandExpressionContextGroovyParser.CommandArgumentContextGroovyParser.PathExpressionContextModifiersContext.classGroovyParser.PathElementContextGroovyParser.NamePartContextGroovyParser.DynamicMemberNameContextGroovyParser.IndexPropertyArgsContextvisitModifiersOpt(...)GroovyParser.NamedPropertyArgsContextGroovyParser.PrimaryContextGroovyParser.ListContextGroovyParser.MapContextGroovyParser.MapEntryListContextGroovyParser.MapEntryContextGroovyParser.MapEntryLabelContextGroovyParser.CreatorContextGroovyParser.DimContextGroovyParser.ArrayInitializerContextGroovyParser.AnonymousInnerClassDeclarationContextGroovyParser.CreatedNameContextGroovyParser.NonWildcardTypeArgumentsContextGroovyParser.TypeArgumentsOrDiamondContextGroovyParser.ArgumentsContextGroovyParser.EnhancedArgumentListInParContextGroovyParser.EnhancedArgumentListElementContextGroovyParser.StringLiteralContextGroovyParser.ClassNameContextGroovyParser.IdentifierContextGroovyParser.BuiltInTypeContextGroovyParser.KeywordsContextGroovyParser.RparenContextGroovyParser.NlsContextGroovyParser.SepContext// Generated from GroovyParser.g4 by ANTLR 4.9.0ModifiersOptContext _localctxnew ModifiersOptContext(...)modifiers(...)ModifierContext.classvisitModifiers(...)import ParseTreeVisitor/** This interface defines a complete generic visitor for a parse tree produced ... *//** Visit a parse tree produced by the {@code identifierPrmrAlt} ... *//** Visit a parse tree produced by the {@code literalPrmrAlt} ... *//** Visit a parse tree produced by the {@code gstringPrmrAlt} ... *//** Visit a parse tree produced by the {@code newPrmrAlt} ... *//** Visit a parse tree produced by the {@code thisPrmrAlt} ... *//** Visit a parse tree produced by the {@code superPrmrAlt} ... *//** Visit a parse tree produced by the {@code parenPrmrAlt} ... *//** Visit a parse tree produced by the {@code closureOrLambdaExpressionPrmrAlt} ... *//** Visit a parse tree produced by the {@code listPrmrAlt} ... *//** Visit a parse tree produced by the {@code mapPrmrAlt} ... *//** Visit a parse tree produced by the {@code builtInTypePrmrAlt} ... *//** Visit a parse tree produced by the {@code integerLiteralAlt} ... *//** Visit a parse tree produced by the {@code floatingPointLiteralAlt} ... *//** Visit a parse tree produced by the {@code stringLiteralAlt} ... *//** Visit a parse tree produced by the {@code booleanLiteralAlt} ... *//** Visit a parse tree produced by the {@code nullLiteralAlt} ... *//** Visit a parse tree produced by the {@code castExprAlt} ... *//** Visit a parse tree produced by the {@code postfixExprAlt} ... *//** Visit a parse tree produced by the {@code switchExprAlt} ... *//** Visit a parse tree produced by the {@code unaryNotExprAlt} ... *//** Visit a parse tree produced by the {@code powerExprAlt} ... *//** Visit a parse tree produced by the {@code unaryAddExprAlt} ... *//** Visit a parse tree produced by the {@code multiplicativeExprAlt} ... *//** Visit a parse tree produced by the {@code additiveExprAlt} ... *//** Visit a parse tree produced by the {@code shiftExprAlt} ... *//** Visit a parse tree produced by the {@code relationalExprAlt} ... *//** Visit a parse tree produced by the {@code equalityExprAlt} ... *//** Visit a parse tree produced by the {@code regexExprAlt} ... *//** Visit a parse tree produced by the {@code andExprAlt} ... *//** Visit a parse tree produced by the {@code exclusiveOrExprAlt} ... *//** Visit a parse tree produced by the {@code inclusiveOrExprAlt} ... *//** Visit a parse tree produced by the {@code logicalAndExprAlt} ... *//** Visit a parse tree produced by the {@code logicalOrExprAlt} ... *//** Visit a parse tree produced by the {@code conditionalExprAlt} ... *//** Visit a parse tree produced by the {@code multipleAssignmentExprAlt} ... *//** Visit a parse tree produced by the {@code assignmentExprAlt} ... *//** Visit a parse tree produced by the {@code blockStmtAlt} ... *//** Visit a parse tree produced by the {@code conditionalStmtAlt} ... *//** Visit a parse tree produced by the {@code loopStmtAlt} ... *//** Visit a parse tree produced by the {@code tryCatchStmtAlt} ... *//** Visit a parse tree produced by the {@code synchronizedStmtAlt} ... *//** Visit a parse tree produced by the {@code returnStmtAlt} ... *//** Visit a parse tree produced by the {@code throwStmtAlt} ... *//** Visit a parse tree produced by the {@code breakStmtAlt} ... *//** Visit a parse tree produced by the {@code continueStmtAlt} ... *//** Visit a parse tree produced by the {@code yieldStmtAlt} ... *//** Visit a parse tree produced by the {@code labeledStmtAlt} ... *//** Visit a parse tree produced by the {@code assertStmtAlt} ... *//** Visit a parse tree produced by the {@code localVariableDeclarationStmtAlt} ... *//** Visit a parse tree produced by the {@code expressionStmtAlt} ... *//** Visit a parse tree produced by the {@code emptyStmtAlt} ... *//** Visit a parse tree produced by the {@code commandExprAlt} ... *//** Visit a parse tree produced by the {@code forStmtAlt} ... *//** Visit a parse tree produced by the {@code whileStmtAlt} ... *//** Visit a parse tree produced by the {@code doWhileStmtAlt} ... *//** Visit a parse tree produced by {@link GroovyParser#compilationUnit}. ... *//** Visit a parse tree produced by {@link GroovyParser#scriptStatements}. ... *//** Visit a parse tree produced by {@link GroovyParser#scriptStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#packageDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#importDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#modifier}. ... *//** Visit a parse tree produced by {@link GroovyParser#modifiersOpt}. ... *//** Visit a parse tree produced by {@link GroovyParser#modifiers}. ... *//** Visit a parse tree produced by {@link GroovyParser#classOrInterfaceModifiersOpt}. ... *//** Visit a parse tree produced by {@link GroovyParser#classOrInterfaceModifiers}. ... *//** Visit a parse tree produced by {@link GroovyParser#classOrInterfaceModifier}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableModifier}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableModifiersOpt}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableModifiers}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeParameters}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeParameter}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeBound}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeList}. ... *//** Visit a parse tree produced by {@link GroovyParser#classDeclaration}. ... */ModifiersContext _localctxnew ModifiersContext(...)/** Visit a parse tree produced by {@link GroovyParser#classBody}. ... *//** Visit a parse tree produced by {@link GroovyParser#enumConstants}. ... *//** Visit a parse tree produced by {@link GroovyParser#enumConstant}. ... *//** Visit a parse tree produced by {@link GroovyParser#classBodyDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#memberDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#methodDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#compactConstructorDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#methodName}. ... */modifier(...)/** Visit a parse tree produced by {@link GroovyParser#returnType}. ... *//** Visit a parse tree produced by {@link GroovyParser#fieldDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableDeclarators}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableDeclarator}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableDeclaratorId}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableInitializer}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableInitializers}. ... *//** Visit a parse tree produced by {@link GroovyParser#emptyDims}. ... *//** Visit a parse tree produced by {@link GroovyParser#emptyDimsOpt}. ... *//** Visit a parse tree produced by {@link GroovyParser#type}. ... *//** Visit a parse tree produced by {@link GroovyParser#classOrInterfaceType}. ... *//** Visit a parse tree produced by {@link GroovyParser#primitiveType}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeArguments}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeArgument}. ... *//** Visit a parse tree produced by {@link GroovyParser#annotatedQualifiedClassName}. ... *//** Visit a parse tree produced by {@link GroovyParser#qualifiedClassNameList}. ... */ClassOrInterfaceModifiersContext.class/** Visit a parse tree produced by {@link GroovyParser#formalParameters}. ... *//** Visit a parse tree produced by {@link GroovyParser#formalParameterList}. ... *//** Visit a parse tree produced by {@link GroovyParser#thisFormalParameter}. ... *//** Visit a parse tree produced by {@link GroovyParser#formalParameter}. ... */getTokens(...)/** Visit a parse tree produced by {@link GroovyParser#methodBody}. ... */GroovyParser.NL/** Visit a parse tree produced by {@link GroovyParser#qualifiedName}. ... *//** Visit a parse tree produced by {@link GroovyParser#qualifiedNameElement}. ... *//** Visit a parse tree produced by {@link GroovyParser#qualifiedNameElements}. ... */visitClassOrInterfaceModifiersOpt(...)/** Visit a parse tree produced by {@link GroovyParser#qualifiedClassName}. ... *//** Visit a parse tree produced by {@link GroovyParser#qualifiedStandardClassName}. ... *//** Visit a parse tree produced by {@link GroovyParser#literal}. ... *//** Visit a parse tree produced by {@link GroovyParser#gstring}. ... *//** Visit a parse tree produced by {@link GroovyParser#gstringValue}. ... *//** Visit a parse tree produced by {@link GroovyParser#gstringPath}. ... *//** Visit a parse tree produced by {@link GroovyParser#standardLambdaExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#standardLambdaParameters}. ... *//** Visit a parse tree produced by {@link GroovyParser#lambdaBody}. ... *//** Visit a parse tree produced by {@link GroovyParser#closure}. ... *//** Visit a parse tree produced by {@link GroovyParser#closureOrLambdaExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#blockStatementsOpt}. ... *//** Visit a parse tree produced by {@link GroovyParser#blockStatements}. ... *//** Visit a parse tree produced by {@link GroovyParser#annotationsOpt}. ... *//** Visit a parse tree produced by {@link GroovyParser#annotation}. ... *//** Visit a parse tree produced by {@link GroovyParser#elementValues}. ... *//** Visit a parse tree produced by {@link GroovyParser#annotationName}. ... *//** Visit a parse tree produced by {@link GroovyParser#elementValuePairs}. ... *//** Visit a parse tree produced by {@link GroovyParser#elementValuePair}. ... *//** Visit a parse tree produced by {@link GroovyParser#elementValuePairName}. ... *//** Visit a parse tree produced by {@link GroovyParser#elementValue}. ... *//** Visit a parse tree produced by {@link GroovyParser#elementValueArrayInitializer}. ... *//** Visit a parse tree produced by {@link GroovyParser#block}. ... *//** Visit a parse tree produced by {@link GroovyParser#blockStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#localVariableDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeNamePairs}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeNamePair}. ... *//** Visit a parse tree produced by {@link GroovyParser#variableNames}. ... *//** Visit a parse tree produced by {@link GroovyParser#conditionalStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#ifElseStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#switchStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#loopStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#continueStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#breakStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#yieldStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#tryCatchStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#assertStatement}. ... *//** Visit a parse tree produced by {@link GroovyParser#statement}. ... *//** Visit a parse tree produced by {@link GroovyParser#catchClause}. ... *//** Visit a parse tree produced by {@link GroovyParser#catchType}. ... *//** Visit a parse tree produced by {@link GroovyParser#finallyBlock}. ... *//** Visit a parse tree produced by {@link GroovyParser#resources}. ... *//** Visit a parse tree produced by {@link GroovyParser#resourceList}. ... *//** Visit a parse tree produced by {@link GroovyParser#resource}. ... *//** Visit a parse tree produced by {@link GroovyParser#switchBlockStatementGroup}. ... *//** Visit a parse tree produced by {@link GroovyParser#switchLabel}. ... *//** Visit a parse tree produced by {@link GroovyParser#forControl}. ... *//** Visit a parse tree produced by {@link GroovyParser#enhancedForControl}. ... *//** Visit a parse tree produced by {@link GroovyParser#classicalForControl}. ... *//** Visit a parse tree produced by {@link GroovyParser#forInit}. ... *//** Visit a parse tree produced by {@link GroovyParser#forUpdate}. ... *//** Visit a parse tree produced by {@link GroovyParser#castParExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#parExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#expressionInPar}. ... *//** Visit a parse tree produced by {@link GroovyParser#expressionList}. ... *//** Visit a parse tree produced by {@link GroovyParser#expressionListElement}. ... *//** Visit a parse tree produced by {@link GroovyParser#enhancedStatementExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#statementExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#postfixExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#switchExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#switchBlockStatementExpressionGroup}. ... *//** Visit a parse tree produced by {@link GroovyParser#switchExpressionLabel}. ... *//** Visit a parse tree produced by {@link GroovyParser#expression}. ... *//** Visit a parse tree produced by {@link GroovyParser#commandExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#commandArgument}. ... *//** Visit a parse tree produced by {@link GroovyParser#pathExpression}. ... *//** Visit a parse tree produced by {@link GroovyParser#pathElement}. ... *//** Visit a parse tree produced by {@link GroovyParser#namePart}. ... *//** Visit a parse tree produced by {@link GroovyParser#dynamicMemberName}. ... *//** Visit a parse tree produced by {@link GroovyParser#indexPropertyArgs}. ... *//** Visit a parse tree produced by {@link GroovyParser#namedPropertyArgs}. ... *//** Visit a parse tree produced by {@link GroovyParser#primary}. ... *//** Visit a parse tree produced by {@link GroovyParser#list}. ... *//** Visit a parse tree produced by {@link GroovyParser#map}. ... *//** Visit a parse tree produced by {@link GroovyParser#mapEntryList}. ... *//** Visit a parse tree produced by {@link GroovyParser#mapEntry}. ... *//** Visit a parse tree produced by {@link GroovyParser#mapEntryLabel}. ... *//** Visit a parse tree produced by {@link GroovyParser#creator}. ... *//** Visit a parse tree produced by {@link GroovyParser#dim}. ... *//** Visit a parse tree produced by {@link GroovyParser#arrayInitializer}. ... *//** Visit a parse tree produced by {@link GroovyParser#anonymousInnerClassDeclaration}. ... *//** Visit a parse tree produced by {@link GroovyParser#createdName}. ... *//** Visit a parse tree produced by {@link GroovyParser#nonWildcardTypeArguments}. ... *//** Visit a parse tree produced by {@link GroovyParser#typeArgumentsOrDiamond}. ... *//** Visit a parse tree produced by {@link GroovyParser#arguments}. ... *//** Visit a parse tree produced by {@link GroovyParser#enhancedArgumentListInPar}. ... *//** Visit a parse tree produced by {@link GroovyParser#enhancedArgumentListElement}. ... *//** Visit a parse tree produced by {@link GroovyParser#stringLiteral}. ... *//** Visit a parse tree produced by {@link GroovyParser#className}. ... *//** Visit a parse tree produced by {@link GroovyParser#identifier}. ... *//** Visit a parse tree produced by {@link GroovyParser#builtInType}. ... *//** Visit a parse tree produced by {@link GroovyParser#keywords}. ... *//** Visit a parse tree produced by {@link GroovyParser#rparen}. ... *//** Visit a parse tree produced by {@link GroovyParser#nls}. ... *//** Visit a parse tree produced by {@link GroovyParser#sep}. ... */ClassOrInterfaceModifiersOptContext _localctxnew ClassOrInterfaceModifiersOptContext(...)classOrInterfaceModifiers(...)visitClassOrInterfaceModifiers(...)ClassOrInterfaceModifiersContext _localctxnew ClassOrInterfaceModifiersContext(...)AnnotationContext.classGroovyParser.PUBLICGroovyParser.PROTECTEDGroovyParser.PRIVATEGroovyParser.ABSTRACTGroovyParser.SEALEDGroovyParser.NON_SEALEDGroovyParser.FINALGroovyParser.STRICTFPGroovyParser.DEFAULTvisitClassOrInterfaceModifier(...)ClassOrInterfaceModifierContext _localctxnew ClassOrInterfaceModifierContext(...)JointGroovy.StaticInnerannotation(...)JointGroovy.StaticInner.NonStaticInnervisitVariableModifier(...)VariableModifierContext _localctxnew VariableModifierContext(...)VariableModifiersContext.classvisitVariableModifiersOpt(...)VariableModifiersOptContext _localctxnew VariableModifiersOptContext(...)variableModifiers(...)VariableModifierContext.classvisitVariableModifiers(...)VariableModifiersContext _localctxnew VariableModifiersContext(...)variableModifier(...)GroovyParser.LTTypeParameterContext.classGroovyParser.GTGroovyParser.COMMAvisitTypeParameters(...)import GradleVersionimport BasicScriptimport ScriptSourceimport TextResourceScriptSourceimport StringTextResource/** Precompiled org.apache.groovy-aggregating-project script plugin. */String MIN_SUPPORTED_GRADLE_VERSION;assertSupportedByCurrentGradleVersion(...)Class<? extends BasicScript> precompiledScriptClassasSubclass(...)forName(...)BasicScript.classBasicScript scriptnewInstance(...)getDeclaredConstructor(...)TypeParametersContext _localctxnew TypeParametersContext(...)typeParameter(...)ClassNameContext.classGroovyParser.EXTENDSTypeBoundContext.classvisitTypeParameter(...)setScriptSource(...)scriptSource(...)init(...)getServices(...)run(...)Exception enew RuntimeException(...)new TextResourceScriptSource(...)new StringTextResource(...)getSimpleName(...)compareTo(...)getBaseVersion(...)version(...)current(...)//CHECKSTYLE:OFF//CHECKSTYLE:ON/** Precompiled org.apache.groovy-all script plugin. */Class<? extends BasicScript> pluginsBlockClassTypeParameterContext _localctxnew TypeParameterContext(...)className(...)typeBound(...)TypeContext.classGroovyParser.BITANDBasicScript pluginsBlockScriptvisitTypeBound(...)apply(...)getPluginManager(...)TypeBoundContext _localctxnew TypeBoundContext(...)type(...)/** Precompiled org.apache.groovy-artifactory script plugin. */visitTypeList(...)TypeListContext _localctxnew TypeListContext(...)int t;TypeListContext scs;TypeListContext is;TypeListContext ps;ClassBodyContext.classGroovyParser.CLASSGroovyParser.INTERFACEGroovyParser.ENUMGroovyParser.ATGroovyParser.TRAITGroovyParser.RECORDTypeParametersContext.classFormalParametersContext.classGroovyParser.IMPLEMENTSGroovyParser.PERMITSTypeListContext.classvisitClassDeclaration(...)ClassDeclarationContext _localctxnew ClassDeclarationContext(...)_localctx.ttypeParameters(...)formalParameters(...)_localctx.scstypeList(...)_localctx.is_localctx.psclassBody(...)GroovyParser.LBRACEGroovyParser.RBRACEEnumConstantsContext.classClassBodyDeclarationContext.classthis.tvisitClassBody(...)/** Precompiled org.apache.groovy-asciidoctor script plugin. */ClassBodyContext _localctxnew ClassBodyContext(...)enumConstants(...)... - ...classBodyDeclaration(...)EnumConstantContext.classvisitEnumConstants(...)/** Precompiled org.apache.groovy-bad-practices-detection script plugin. */EnumConstantsContext _localctxnew EnumConstantsContext(...)enumConstant(...)ArgumentsContext.classAnonymousInnerClassDeclarationContext.classvisitEnumConstant(...)/** Precompiled org.apache.groovy-base script plugin. */EnumConstantContext _localctxnew EnumConstantContext(...)arguments(...)anonymousInnerClassDeclaration(...)BlockContext.classMemberDeclarationContext.classvisitClassBodyDeclaration(...)ClassBodyDeclarationContext _localctxnew ClassBodyDeclarationContext(...)/** Precompiled org.apache.groovy-common script plugin. */block(...)memberDeclaration(...)FieldDeclarationContext.classModifiersOptContext.classCompactConstructorDeclarationContext.classvisitMemberDeclaration(...)MemberDeclarationContext _localctxnew MemberDeclarationContext(...)fieldDeclaration(...)modifiersOpt(...)compactConstructorDeclaration(...)int ct;MethodNameContext.classReturnTypeContext.classElementValueContext.classGroovyParser.THROWSQualifiedClassNameListContext.classMethodBodyContext.classthis.ctvisitMethodDeclaration(...)/** Precompiled org.apache.groovy-core script plugin. */MethodDeclarationContext _localctxnew MethodDeclarationContext(...)returnType(...)_localctx.ctmethodName(...)elementValue(...)qualifiedClassNameList(...)methodBody(...)visitCompactConstructorDeclaration(...)/** Precompiled org.apache.groovy-distribution script plugin. */CompactConstructorDeclarationContext _localctxnew CompactConstructorDeclarationContext(...)StringLiteralContext.classvisitMethodName(...)MethodNameContext _localctxnew MethodNameContext(...)/** Precompiled org.apache.groovy-doc-aggregator script plugin. */stringLiteral(...)GroovyParser.VOIDvisitReturnType(...)ReturnTypeContext _localctxnew ReturnTypeContext(...)standardType(...)VariableDeclarationContext.classvisitFieldDeclaration(...)/** Precompiled org.apache.groovy-documented script plugin. */FieldDeclarationContext _localctxnew FieldDeclarationContext(...)variableDeclaration(...)VariableDeclaratorContext.classvisitVariableDeclarators(...)/** Precompiled org.apache.groovy-internal script plugin. */VariableDeclaratorsContext _localctxnew VariableDeclaratorsContext(...)variableDeclarator(...)VariableDeclaratorIdContext.classGroovyParser.ASSIGNVariableInitializerContext.classvisitVariableDeclarator(...)/** Precompiled org.apache.groovy-jacoco-aggregation script plugin. */VariableDeclaratorContext _localctxnew VariableDeclaratorContext(...)variableDeclaratorId(...)variableInitializer(...)visitVariableDeclaratorId(...)VariableDeclaratorIdContext _localctxnew VariableDeclaratorIdContext(...)EnhancedStatementExpressionContext.classvisitVariableInitializer(...)VariableInitializerContext _localctxnew VariableInitializerContext(...)enhancedStatementExpression(...)visitVariableInitializers(...)VariableInitializersContext _localctxnew VariableInitializersContext(...)GroovyParser.LBRACKGroovyParser.RBRACKvisitEmptyDims(...)/** Precompiled org.apache.groovy-library script plugin. */EmptyDimsContext _localctxnew EmptyDimsContext(...)do ... while (...)EmptyDimsContext.classvisitEmptyDimsOpt(...)EmptyDimsOptContext _localctxnew EmptyDimsOptContext(...)emptyDims(...)TypeContext _localctxnew TypeContext(...)/** Precompiled org.apache.groovy-performance script plugin. */primitiveType(...)standardClassOrInterfaceType(...)emptyDimsOpt(...)EmptyDimsOptContext.classPrimitiveTypeContext.classClassOrInterfaceTypeContext.classvisitType(...)generalClassOrInterfaceType(...)QualifiedClassNameContext.classQualifiedStandardClassNameContext.classTypeArgumentsContext.classvisitClassOrInterfaceType(...)/** Precompiled org.apache.groovy-platform script plugin. */ClassOrInterfaceTypeContext _localctxnew ClassOrInterfaceTypeContext(...)qualifiedClassName(...)qualifiedStandardClassName(...)typeArguments(...)GroovyParser.BuiltInPrimitiveTypevisitPrimitiveType(...)/** Precompiled org.apache.groovy-publish-validation script plugin. */PrimitiveTypeContext _localctxnew PrimitiveTypeContext(...)TypeArgumentContext.classvisitTypeArguments(...)/** Precompiled org.apache.groovy-published-library script plugin. *//** Precompiled org.apache.groovy-stresstest script plugin. */TypeArgumentsContext _localctxnew TypeArgumentsContext(...)typeArgument(...)GroovyParser.QUESTIONGroovyParser.SUPERvisitTypeArgument(...)/** Precompiled org.apache.groovy-tested script plugin. */TypeArgumentContext _localctxnew TypeArgumentContext(...)visitAnnotatedQualifiedClassName(...)AnnotatedQualifiedClassNameContext _localctxnew AnnotatedQualifiedClassNameContext(...)AnnotatedQualifiedClassNameContext.classvisitQualifiedClassNameList(...)QualifiedClassNameListContext _localctxnew QualifiedClassNameListContext(...)annotatedQualifiedClassName(...)GroovyParser.LPARENRparenContext.classFormalParameterListContext.classvisitFormalParameters(...)FormalParametersContext _localctxnew FormalParametersContext(...)formalParameterList(...)rparen(...)FormalParameterContext.classThisFormalParameterContext.classvisitFormalParameterList(...)import GroovyASTTransformationClassimport ElementTypeimport Retentionimport RetentionPolicyimport Target/** Annotates a groovy property or a class. ... */RetentionPolicy.SOURCEElementType.FIELDElementType.TYPE/* Licensed to the Apache Software Foundation (ASF) under one ... */FormalParameterListContext _localctxnew FormalParameterListContext(...)formalParameter(...)thisFormalParameter(...)GroovyParser.THISimport ASTNodeimport AnnotatedNodeimport AnnotationNodeimport ClassHelperimport ClassNodeimport FieldNodeimport MethodNodeimport Parameterimport PropertyNodeimport Expressionimport BlockStatementimport Statementimport PropertyNodeUtilsimport CompilePhaseimport SourceUnitimport SimpleMessageimport ASTTransformationimport GroovyASTTransformationimport Opcodesimport PropertyChangeListenerimport PropertyChangeSupportimport static ClassNodeUtils.addGeneratedMethodimport static GeneralUtils.argsimport static GeneralUtils.assignXimport static GeneralUtils.callThisXimport static GeneralUtils.callXimport static GeneralUtils.constXimport static GeneralUtils.ctorXimport static GeneralUtils.declSimport static GeneralUtils.fieldXimport static GeneralUtils.localVarXimport static GeneralUtils.paramimport static GeneralUtils.paramsimport static GeneralUtils.returnSimport static GeneralUtils.stmtvisitThisFormalParameter(...)import static GeneralUtils.varX/** Handles generation of code for the {@code @Bindable} annotation when {@code @Vetoable} ... */CompilePhase.CANONICALIZATIONmake(...)Bindable.classClassNode boundClassNode;/** Convenience method to see if an annotated node is {@code @Bindable}. ... */for (... : ...)AnnotationNode annotationgetAnnotations(...)getClassNode(...)/** Handles the bulk of the processing, mostly delegating to other methods. ... */AnnotationNode nodeAnnotatedNode parentClassNode declaringClassgetDeclaringClass(...)hasVetoableAnnotation(...)getModifiers(...)Opcodes.ACC_FINALaddErrorAndContinue(...)getErrorCollector(...)addListenerToProperty(...)addListenerToClass(...)String fieldNamePropertyNode propertyNodegetProperties(...)isStatic(...)needsPropertyChangeSupport(...)addPropertyChangeSupport(...)createListenerSetter(...)FieldNode fieldgetField(...)hasBindableAnnotation(...)/* Wrap an existing setter. */String getterNamegetGetterNameOrDefault(...)MethodNode settergetSetterMethod(...)getSetterNameOrDefault(...)Statement codegetCode(...)Expression oldValuelocalVarX(...)Expression newValueBlockStatement blocknew BlockStatement(...)addStatement(...)declS(...)callThisX(...)stmt(...)args(...)constX(...)setCode(...)String setterNameisEmpty(...)getMethods(...)ThisFormalParameterContext _localctxnew ThisFormalParameterContext(...)VariableModifiersOptContext.classGroovyParser.ELLIPSISExpressionContext.classvisitFormalParameter(...)Statement setterBlockcreateBindableStatement(...)fieldX(...)createSetterMethod(...)wrapSetterMethod(...)/** Creates a statement body similar to: ... */assignX(...)varX(...)/** Creates a setter method with the given body. ... */new MethodNode(...)adjustPropertyModifiersForMethod(...)ClassHelper.VOID_TYPEparams(...)ClassNode.EMPTY_ARRAYparam(...)setSynthetic(...)addGeneratedMethod(...)/** Snoops through the declaring class and all parents looking for methods ... */boolean foundAddboolean foundRemoveboolean foundFireClassNode consideredClassMethodNode methodgetParameters(...).lengthgetParameters(...)getSuperClass(...)getFields(...)new SimpleMessage(...)/** Adds the necessary field and methods to support property change support. ... */ClassNode pcsClassNodePropertyChangeSupport.classClassNode pclClassNodePropertyChangeListener.classFieldNode pcsFieldaddField(...)ctorX(...)callX(...)ClassHelper.STRING_TYPEClassHelper.OBJECT_TYPEmakeArray(...)Parameter.EMPTY_ARRAYreturnS(...)// VetoableASTTransformation will handle both @Bindable and @Vetoable//noinspection ThrowableInstanceNeverThrown// look to see if per-field handlers will catch this one...// explicitly labeled properties are already handled,// don't transform final properties// don't transform static properties// Get the existing code block// create a local variable to hold the old value from the getter// call the existing block, which will presumably set the value properly// get the new value to emit in the event// add the firePropertyChange method call// replace the existing code block with our new one// create method void <setter>(<type> fieldName)// create statementBody// add it to the class// just check length, MOP will match it upFormalParameterContext _localctx// check if a super class has @Bindable annotationsnew FormalParameterContext(...)//String pcsFieldName = "this$propertyChangeSupport";// add field:// protected final PropertyChangeSupport this$propertyChangeSupport = new java.beans.PropertyChangeSupport(this)// add method:// void addPropertyChangeListener(listener) {//     this$propertyChangeSupport.addPropertyChangeListener(listener)//  }variableModifiersOpt(...)// void addPropertyChangeListener(name, listener) {//     this$propertyChangeSupport.addPropertyChangeListener(name, listener)// boolean removePropertyChangeListener(listener) {//    return this$propertyChangeSupport.removePropertyChangeListener(listener);// }// add method: void removePropertyChangeListener(name, listener)// void firePropertyChange(String name, Object oldValue, Object newValue) {//     this$propertyChangeSupport.firePropertyChange(name, oldValue, newValue)// PropertyChangeListener[] getPropertyChangeListeners() {//   return this$propertyChangeSupport.getPropertyChangeListeners// PropertyChangeListener[] getPropertyChangeListeners(String name) {//   return this$propertyChangeSupport.getPropertyChangeListeners(name)expression(...)visitMethodBody(...)new DefaultPropertyAccessor(...)PropertyAccessor INSTANCE;read(...)DefaultPropertyReader.INSTANCEwrite(...)DefaultPropertyWriter.INSTANCEimport InvokerHelpernew DefaultPropertyReader(...)PropertyReader INSTANCE;getPropertySafe(...)new DefaultPropertyWriter(...)PropertyWriter INSTANCE;setProperty(...)MethodBodyContext _localctxnew MethodBodyContext(...)QualifiedNameElementContext.classvisitQualifiedName(...)import PropertyVetoExceptionimport VetoableChangeListenerimport VetoableChangeSupportimport static GeneralUtils.assignS/** Handles generation of code for the {@code @Vetoable} annotation, and {@code @Bindable} ... */Vetoable.classClassNode constrainedClassNode;/** Convenience method to see if an annotated node is {@code @Vetoable}. ... */QualifiedNameContext _localctxnew QualifiedNameContext(...)qualifiedNameElement(...)GroovyParser.INboolean bindableisFinal(...)/** Wrap an existing setter. */String propertyNameExpression proposedValueneedsVetoableChangeSupport(...)addVetoableChangeSupport(...)Expression fieldExpressionBlockStatement setterBlockcreateConstrainedStatement(...)createSetStatement(...)assignS(...)/** Snoops through the declaring class and all parents looking for a field ... */visitQualifiedNameElement(...)ClassNode[] exceptionsnew ClassNode[]PropertyVetoException.class/** Adds the necessary field and methods to support vetoable change support. ... */ClassNode vcsClassNodeVetoableChangeSupport.classClassNode vclClassNodeVetoableChangeListener.classFieldNode vcsField// add the fireVetoableChange method call// check if a super class has @Vetoable annotations// protected static VetoableChangeSupport this$vetoableChangeSupport = new java.beans.VetoableChangeSupport(this)// void addVetoableChangeListener(listener) {//     this$vetoableChangeSupport.addVetoableChangeListener(listener)// void addVetoableChangeListener(name, listener) {//     this$vetoableChangeSupport.addVetoableChangeListener(name, listener)// boolean removeVetoableChangeListener(listener) {//    return this$vetoableChangeSupport.removeVetoableChangeListener(listener);// add method: void removeVetoableChangeListener(name, listener)// void fireVetoableChange(String name, Object oldValue, Object newValue)//    throws PropertyVetoException// {//     this$vetoableChangeSupport.fireVetoableChange(name, oldValue, newValue)// VetoableChangeListener[] getVetoableChangeListeners() {//   return this$vetoableChangeSupport.getVetoableChangeListeners// VetoableChangeListener[] getVetoableChangeListeners(String name) {//   return this$vetoableChangeSupport.getVetoableChangeListeners(name)QualifiedNameElementContext _localctxnew QualifiedNameElementContext(...)visitQualifiedNameElements(...)import Undefined/** Indicates that a method or property can be used to set a CLI option. */RetentionPolicy.RUNTIMEElementType.METHOD/** The description of this option ... *//** The short name of this option. Defaults to the name of member being annotated if the longName is empty. ... *//** The long name of this option. Defaults to the name of member being annotated. ... *//** The value separator for this multi-valued option. Only allowed for array-typed arguments. ... *//** Whether this option can have an optional argument. ... *//** How many arguments this option has. ... *//** How many arguments this option has represented as a String. ... *//** The default value for this option as a String; subject to type conversion and 'convert'. ... *//** A conversion closure to convert the incoming String into the desired object ... */long serialVersionUID;get(...)QualifiedNameElementsContext _localctxnew QualifiedNameElementsContext(...)QualifiedNameElementsContext.classvisitQualifiedClassName(...)/** Indicates that a method or property will contain the remaining arguments. *//** The description for the remaining non-option arguments ... */QualifiedClassNameContext _localctxnew QualifiedClassNameContext(...)qualifiedNameElements(...)visitQualifiedStandardClassName(...)QualifiedStandardClassNameContext _localctxnew QualifiedStandardClassNameContext(...)copyFrom(...)GroovyParser.IntegerLiteralvisitIntegerLiteralAlt(...)GroovyParser.FloatingPointLiteralvisitFloatingPointLiteralAlt(...)visitStringLiteralAlt(...)import Grabimport GrabConfigimport GrabExcludeimport GrabResolverimport Grapesimport CompilationUnitAwareimport ClassCodeVisitorSupportimport ImportNodeimport ModuleNodeimport ConstantExpressionimport ListExpressionimport MapExpressionimport StaticMethodCallExpressionimport CompilationUnitimport StringReaderSourceimport DefaultGroovyMethodsimport GrapeUtilimport ASTTransformationVisitorimport AbstractASTTransformationimport Fileimport URIimport URISyntaxExceptionimport Collectionimport LinkedHashSetimport Matcherimport Patternimport static GeneralUtils.eqXimport static GeneralUtils.ifSimport static AbstractASTTransformation.getMemberStringValue/** Transformation for declarative dependency management. */CompilePhase.CONVERSIONGrab.classGroovyParser.BooleanLiteralvisitBooleanLiteralAlt(...)substring(...)lastIndexOf(...)GrabExclude.classdotName(...)shortName(...)GrabConfig.classGroovyParser.NullLiteralGrapes.classvisitNullLiteralAlt(...)GrabResolver.classThread.classSystem.classasList(...)LiteralContext _localctxnew LiteralContext(...)plus(...)compile(...)new IntegerLiteralAltContext(...)Grape.AUTO_DOWNLOAD_SETTINGGrape.DISABLE_CHECKSUMS_SETTINGGrape.SYSTEM_PROPERTIES_SETTINGnew FloatingPointLiteralAltContext(...)String GRAB_CLASS_NAME;String GRAB_DOT_NAME;String GRAB_SHORT_NAME;String GRABEXCLUDE_CLASS_NAME;String GRABEXCLUDE_DOT_NAME;String GRABEXCLUDE_SHORT_NAME;new StringLiteralAltContext(...)String GRABCONFIG_CLASS_NAME;String GRABCONFIG_DOT_NAME;String GRABCONFIG_SHORT_NAME;String GRAPES_CLASS_NAME;String GRAPES_DOT_NAME;String GRAPES_SHORT_NAME;String GRABRESOLVER_CLASS_NAME;String GRABRESOLVER_DOT_NAME;String GRABRESOLVER_SHORT_NAME;new BooleanLiteralAltContext(...)ClassNode THREAD_CLASSNODE;ClassNode SYSTEM_CLASSNODE;List<String> GRABEXCLUDE_REQUIRED;List<String> GRABRESOLVER_REQUIRED;List<String> GRAB_REQUIRED;List<String> GRAB_OPTIONAL;List<String> GRAB_BOOLEAN;Collection<String> GRAB_ALL;new NullLiteralAltContext(...)Pattern IVY_PATTERN;Pattern ATTRIBUTES_PATTERN;String AUTO_DOWNLOAD_SETTING;String DISABLE_CHECKSUMS_SETTING;String SYSTEM_PROPERTIES_SETTING;boolean allowShortGrab;Set<String> grabAliases;GroovyParser.GStringBeginList<AnnotationNode> grabAnnotations;boolean allowShortGrabExcludes;Set<String> grabExcludeAliases;List<AnnotationNode> grabExcludeAnnotations;boolean allowShortGrabConfig;Set<String> grabConfigAliases;List<AnnotationNode> grabConfigAnnotations;boolean allowShortGrapes;Set<String> grapesAliases;List<AnnotationNode> grapesAnnotations;GstringValueContext.classboolean allowShortGrabResolver;Set<String> grabResolverAliases;List<AnnotationNode> grabResolverAnnotations;CompilationUnit compilationUnit;SourceUnit sourceUnit;ClassLoader loader;boolean initContextClassLoader;Boolean autoDownload;Boolean disableChecksums;Map<String,String> systemProperties;GroovyParser.GStringEndGroovyParser.GStringPartthis.compilationUnitModuleNode mnvisitGstring(...)Collection<Map<String,Object>> grabMapsnew LinkedHashSet<Map<String,Object>>(...)Collection<Map<String,Object>> grabMapsInitnew ArrayList<Map<String,Object>>(...)GstringContext _localctxnew GstringContext(...)gstringValue(...)GstringPathContext.classClosureContext.classvisitGstringValue(...)Collection<Map<String,Object>> grabExcludeMapsnew HashSet<String>(...)ImportNode imgetImports(...)String aliasgetAlias(...)String classNamegetClassName(...)endsWith(...)add(...)ClassNode classNodegetClasses(...)getAST(...)ClassNode grapeClassNodeGrape.classList<Statement> grabResolverInitializersnew ArrayList<Statement>(...)GstringValueContext _localctxnew GstringValueContext(...)gstringPath(...)closure(...)GroovyParser.GStringPathPartvisitGstringPath(...)new ArrayList<AnnotationNode>(...)visitClass(...)Expression initgetMember(...)Expression valueObject ogetExpressions(...)extractGrab(...)<Label>: ...GstringPathContext _localctxnew GstringPathContext(...)Map<String,Object> grabResolverMapnew HashMap<String,Object>(...)StandardLambdaExpressionContext _localctxnew StandardLambdaExpressionContext(...)lambdaParameters(...)lambdaBody(...)StandardLambdaParametersContext.classGroovyParser.ARROWLambdaBodyContext.classvisitStandardLambdaExpression(...)String svalgetMemberStringValue(...)String root... > ...String sString mvaladdError(...)getNameWithoutPackage(...)put(...)Expression membercontains(...)URI sourceURIgetSource(...)getSourceUnit(...)getURI(...)toURI(...)new File(...)URI rootURIresolve(...)new URI(...)toString(...)URISyntaxException eaddResolver(...)addGrabResolverAsStaticInitIfNeeded(...)standardLambdaParameters(...)checkForClassLoader(...)checkForInitContextClassLoader(...)checkForAutoDownload(...)checkForSystemProperties(...)checkForDisableChecksums(...)addInitContextClassLoaderIfNeeded(...)Map<String,Object> grabExcludeMapStandardLambdaParametersContext _localctxnew StandardLambdaParametersContext(...)checkForConvenienceForm(...)visitStandardLambdaParameters(...)getValue(...)Map<String,Object> grabMapConstantExpression.TRUEcallGrabAsStaticInitIfNeeded(...)addStaticInitializerStatements(...)Map<String,Object> basicArgs...?...:...getClassLoader(...)grab(...)toArray(...)new Map<>[]addGlobalTransformsAfterGrab(...)getASTTransformationsContext(...)RuntimeException readdException(...)List<Statement> grabInitializersMapExpression basicArgsnew MapExpression(...)List<Expression> argListnew ArrayList<Expression>(...)StatementExpressionContext.classvisitLambdaBody(...)addMapEntryExpression(...)LambdaBodyContext _localctxnew LambdaBodyContext(...)StaticMethodCallExpression enabledstatementExpression(...)Entry<String,String> eMap<>.Entry<String,String>entrySet(...)BlockStatementsOptContext.classgetKey(...)visitClosure(...)ifS(...)eqX(...)ListExpression listnew ListExpression(...)Map<String,Object> mapSet<Entry<String,Object>> entriesMapExpression innerMap<>.Entry<String,Object>Entry<String,Object> entryaddExpression(...)MapExpression dependencyArgcontainsKey(...)MapExpression resolverArgsEntry<String,Object> nextStatement initStatementaddObjectInitializerStatements(...)Object valObject systemClassLoaderObjectBoolean systemClassLoadergetSystemClassLoader(...)Object initContextClassLoaderObjectObject autoDownloadValueObject disableChecksumsValueList<String> nameValueListgetMemberStringList(...)new HashMap<String,String>(...)ClosureContext _localctxnew ClosureContext(...)String nameValueint equalsDelimindexOf(...)Object allPartsString allstrboolean doneMatcher attrsmatcher(...)find(...)String attrNamegroup(...)String attrValueboolean isBoolConstantExpression valuevalueOf(...)int lastSemisetSourcePosition(...)addMember(...)Matcher mblockStatementsOpt(...)StandardLambdaExpressionContext.classremove(...)getMembers(...)visitClosureOrLambdaExpression(...)Map<String,Object> partsgetIvyParts(...)String keyString valuesetMember(...)/** Adds the annotation to the internal target list if a match is found. ... */visitAnnotations(...)AnnotationNode an// don't worry if it's not a ListExpression, or AnnotationConstant, etc.// the rest of GroovyC will flag it as a syntax error later, so we don't// need to raise the error ourselves// If no scheme is specified for the repository root,// then turn it into a URI relative to that of the source file.// Since we use the data: scheme for StringReaderSources (which are fairly common)// and those are not hierarchical we can't use them for making an absolute URI.// Otherwise let's trust the source to know where it is from.// And actually InputStreamReaderSource doesn't know what to do and so returns null.// If source doesn't know how to get a reference to itself,// then let's use the current working directory, since the repo can be relative to that.// We'll be silent here.// If the URI scheme is unknown or not hierarchical, then we just can't help them and shouldn't cause any trouble either.// addError("Attribute \"root\" has value '" + root + "' which can't be turned into a valid URI relative to its source '" + getSourceUnit().getName() + "' @" + node.getClassNode().getNameWithoutPackage() + " annotations", node);// grab may have added more transformations through new URLs added to classpath, so do one more scan// Decided against syntax exception since this is not a syntax error.// The down side is we lose line number information for the offending// @Grab annotation.// add Grape.grab(excludeArgs, [group:group, module:module, version:version, classifier:classifier])// or Grape.grab([group:group, module:module, version:version, classifier:classifier])// insert at beginning so we have the classloader set up before the class is called// strip off trailing attributes// Support for Ivy syntax// see: https://ant.apache.org/ivy/history/latest-milestone/textual.html// Support for Gradle syntax (covers Gradle/Maven)// see: https://docs.gradle.org/3.5.1/userguide/dependency_management.html#sec:how_to_declare_your_dependencies// see: https://docs.gradle.org/7.2/userguide/declaring_dependencies.htmlClosureOrLambdaExpressionContext _localctxnew ClosureOrLambdaExpressionContext(...)import PrivilegedActionlambdaExpression(...)BlockStatementsContext.class/** Facade to GrapeEngine. */new URI[]parseBoolean(...)getProperty(...)visitBlockStatementsOpt(...)...[] EMPTY_URI_ARRAY;...[] EMPTY_MAP_ARRAY;boolean enableGrapes;boolean enableAutoDownload;boolean disableChecksums;GrapeEngine instance;/** This is a static access kill-switch.  All of the static shortcut ... */Grape.enableGrapes/** This is a static access auto download enabler.  It will set the ... */Grape.enableAutoDownload/** Global flag to ignore checksums. ... *//** Set global flag to ignore checksums. ... */Grape.disableChecksumsReflectiveOperationException ignoreGrapeEngine instancegetInstance(...)BlockStatementsOptContext _localctxnew BlockStatementsOptContext(...)blockStatements(...)doPrivileged(...)new (...)new PrivilegedAction<Void>(...) { ... }Grape$1GrapeEngine instance1BlockStatementContext.classGrapeEngine.CALLEE_DEPTHGrapeEngine.DEFAULT_CALLEE_DEPTHMap<String,Map<String,List<String>>> grapesenumerateGrapes(...)emptyMap(...)visitBlockStatements(...)URI[] urisMap<>[] mapslistDependencies(...)// by default use GrapeIvy// TODO: META-INF/services resolver?// TODO a future Groovy version should perform the operation not as a privileged actionString CALLEE_DEPTH;int DEFAULT_CALLEE_DEPTH;BlockStatementsContext _localctxnew BlockStatementsContext(...)blockStatement(...)visitAnnotationsOpt(...)AnnotationsOptContext _localctxnew AnnotationsOptContext(...)AnnotationNameContext.classElementValuesContext.classvisitAnnotation(...)AnnotationContext _localctxnew AnnotationContext(...)annotationName(...)elementValues(...)ElementValuePairsContext.classvisitElementValues(...)ElementValuesContext _localctxnew ElementValuesContext(...)elementValuePairs(...)visitAnnotationName(...)import GroovyObjectimport MetaClassimport MetaMethodimport PropertyValueimport Tuple2import FormatHelperimport PrintStreamimport Serializableimport Constructorimport Fieldimport Methodimport Modifierimport Comparator/** The Inspector provides a unified access to an object's ... */Object objectUnderInspection;int CLASS_PACKAGE_IDX;// Indexes to retrieve Class Property informationint CLASS_CLASS_IDX;int CLASS_INTERFACE_IDX;int CLASS_SUPERCLASS_IDX;int CLASS_OTHER_IDX;int MEMBER_ORIGIN_IDX;// Indexes to retrieve field and method informationint MEMBER_MODIFIER_IDX;int MEMBER_DECLARER_IDX;int MEMBER_TYPE_IDX;int MEMBER_NAME_IDX;int MEMBER_PARAMS_IDX;int MEMBER_VALUE_IDX;int MEMBER_EXCEPTIONS_IDX;String NOT_APPLICABLE;String GROOVY;String JAVA;/** @param */new IllegalArgumentException(...)this.objectUnderInspection/** Get the Class Properties of the object under inspection. ... */String[] resultPackage packgetPackage(...)getClassUnderInspection(...)String modifiersClass<>[] interfacesgetInterfaces(...)Class<> anInterface...+=...getSuperclass(...)isGroovy(...)isArray(...)isPrimitive(...)isAssignableFrom(...)GroovyObject.class/** Gets the object being inspected. ... *//** Get info about usual Java instance and class Methods as well as Constructors. ... */Method[] methodsConstructor<>[] ctorsgetConstructors(...)Object[] resultnew Object[]methods.lengthctors.lengthint resultIndexMethod methodmethodInfo(...)Constructor<> ctor/** Get info about usual Java instance and class Methods as well as Constructors. */Tuple2<>[] resultnew Tuple2<>[]tuple(...)/** Get info about instance and class Methods that are dynamically added through Groovy. ... */MetaClass metaClassgetMetaClass(...)List<> metaMethodsgetMetaMethods(...)size(...)Iterator<> iteriterator(...)hasNext(...)MetaMethod metaMethodnext(...)/** Get info about instance and class Methods that are dynamically added through Groovy. */List<MetaMethod> metaMethodsAnnotationNameContext _localctxnew AnnotationNameContext(...)ElementValuePairContext.classvisitElementValuePairs(...)Iterator<MetaMethod> iter/** Get info about usual Java public fields incl. constants. ... */Field[] fieldsfields.lengthField fieldfieldInfo(...)/** Get info about Properties (Java and Groovy alike). ... */List<> propsgetMetaPropertyValues(...)PropertyValue pvinspect(...)IllegalAccessException ewithoutNulls(...)getV2(...)fieldWithInfo(...)List<PropertyValue> propsIterator<PropertyValue> iterString[] infoObject fieldnew Tuple2<Object,String[]>(...)getClass(...)String packageNameint offsetStringBuilder sbnew StringBuilder(...)int ktypes.lengthappend(...)makeTypesInfo(...)getReturnType(...)makeParamsInfo(...)getParameterTypes(...)makeExceptionInfo(...)getExceptionTypes(...)int modElementValuePairsContext _localctxnew ElementValuePairsContext(...)getTheClass(...)getNativeParameterTypes(...)elementValuePair(...)toNormalize.lengthprint(...)System.outmemberInfo.lengthString[] metaMethodElementValuePairNameContext.classprintln(...)new MemberComparator(...)visitElementValuePair(...)String[] aStrString[] bStrint resultInspector.MEMBER_NAME_IDXInspector.MEMBER_TYPE_IDXInspector.MEMBER_PARAMS_IDXInspector.MEMBER_DECLARER_IDXInspector.MEMBER_MODIFIER_IDXInspector.MEMBER_ORIGIN_IDXMemberComparator delegate;Tuple2<Object,String[]> aTupleTuple2<Object,String[]> bTuplecompare(...)// no exception info for Groovy MetaMethodsElementValuePairContext _localctxnew ElementValuePairContext(...)elementValuePairName(...)import BufferedWriterimport OutputStreamWriterKeywordsContext.classimport Charset/** A buffered writer only for OutputStreamWriter that is aware of ... */OutputStreamWriter out;this.out/** The encoding as returned by the underlying OutputStreamWriter. Can be the historical name. ... */getEncoding(...)/** The encoding as returned by the underlying OutputStreamWriter. Will be the preferred name. ... */name(...)visitElementValuePairName(...)ElementValuePairNameContext _localctxnew ElementValuePairNameContext(...)keywords(...)ElementValueArrayInitializerContext.classvisitElementValue(...)ElementValueContext _localctxnew ElementValueContext(...)elementValueArrayInitializer(...)visitElementValueArrayInitializer(...)ElementValueArrayInitializerContext _localctxnew ElementValueArrayInitializerContext(...)visitBlock(...)BlockContext _localctxnew BlockContext(...)LocalVariableDeclarationContext.classvisitBlockStatement(...)BlockStatementContext _localctxnew BlockStatementContext(...)localVariableDeclaration(...)visitLocalVariableDeclaration(...)/** Represents particular files of interest. */new FileType(...)FileType FILES;/** Represents normal files */FileType DIRECTORIES;/** Represents directories */FileType ANY;/** Represents both normal files and directories *//** Represents special return values for the 'preDir', 'postDir' and 'visit'/supplied Closures used with ... */new FileVisitResult(...)FileVisitResult CONTINUE;/** Continue processing; the default */FileVisitResult SKIP_SIBLINGS;/** Skip processing sibling files/directories within the current directory being processed */FileVisitResult SKIP_SUBTREE;/** Do not process the child files/subdirectories within the current directory being processed */FileVisitResult TERMINATE;/** Do not process any more files */LocalVariableDeclarationContext _localctxnew LocalVariableDeclarationContext(...)import FileNotFoundExceptionimport OutputStreamimport UnsupportedEncodingException/** A PrintStream that outputs objects in Groovy style. ... *//** Creates a new print stream.  This stream will not flush automatically. ... */isInvalidLocalVariableDeclaration(...)/** Creates a new print stream. ... *//** Creates a new print stream, without automatic line flushing, with the ... *//** Prints an object Groovy style. ... *//** Prints an object Groovy style followed by a newline. ... */VariableDeclaratorsContext.classTypeNamePairsContext.classvisitVariableDeclaration(...)import PrintWriterimport Writer/** A PrintWriter that outputs objects in Groovy style. ... */// JDK 1.6 has changed the implementation to do a// String.valueOf(x) rather than call print(x).// Probably to improve performance by doing the conversion outside the lock.// This will do the same thing for us, and we don't have to have access to the lock.import BufferedReaderimport IOExceptionimport Readerimport CharBuffer/** The <code>LineColumnReader</code> is an extension to <code>BufferedReader</code> ... */long line;/** The current line position */long column;/** The current column position */long lineMark;/** The latest marked line position */long columnMark;boolean newLineWasRead;/** Constructor wrapping a <code>Reader</code> ... *//** Marks the present position in the stream. Subsequent calls to reset() will attempt to reposition the stream to this point. ... */mark(...)/** Resets the stream to the most recent mark. */reset(...)/** Reads a single character. ... */int charReadchar c/** Reads characters into a portion of an array. ... */... <= ...int readInt/** Reads a line of text. A line is considered to be terminated by any one of a line feed ('\n'), ... */StringBuilder resultint intReadVariableDeclarationContext _localctxnew VariableDeclarationContext(...)/** Skips characters. ... */long i/** Reads characters into an array. ... */chars.length/** Not implemented. ... */new UnsupportedOperationException(...)/** Closes the stream and releases any system resources associated with it. ... */close(...)variableDeclarators(...)this.columnMarkthis.lineMarktypeNamePairs(...)// found a \r or \n, like on Mac or Unix// could also be Windows' \r\n// check if we have \r\n like on Windows// if it's not \r\n we reset, otherwise, the \n is just consumedTypeNamePairContext.classvisitTypeNamePairs(...)/** A buffered writer that gobbles any \r characters ... */BufferedWriter writer;new BufferedWriter(...)...--newLine(...)flush(...)/** An interface for MetaClass instances that "adapt" other MetaClass instances such as a proxy or ... *//** Returns the MetaClass that this adapter adapts ... *//** Sets the MetaClass adapted by this MetaClass ... */import LinkedHashMapimport LinkedList/** Interceptor that registers the timestamp of each method call ... */new LinkedHashMap<>(...)TypeNamePairsContext _localctxnew TypeNamePairsContext(...)typeNamePair(...)visitTypeNamePair(...)Map<> calls;/** Returns the raw data associated with the current benchmark run. */// keys to list of invocation times and before and after/** Resets all the benchmark data on this object. */new HashMap<>(...)/** This code is executed before the method is called. ... */new LinkedList<>(...)TypeNamePairContext _localctxnew TypeNamePairContext(...)visitVariableNames(...)currentTimeMillis(...)/** This code is executed after the method is called. ... *//** The call should be invoked separately ... *//** Returns benchmark statistics as a List&lt;Object[]&gt;. ... */List<> resultkeySet(...)Object[] lineList<> timesint accTime... / ...Iterator<> itLong startLong endVariableNamesContext _localctxnew VariableNamesContext(...)IfElseStatementContext.classSwitchStatementContext.classvisitConditionalStatement(...)ConditionalStatementContext _localctxnew ConditionalStatementContext(...)ifElseStatement(...)switchStatement(...)StatementContext tb;StatementContext fb;GroovyParser.IFExpressionInParContext.classGroovyParser.ELSEvisitIfElseStatement(...)/** Represents the variable bindings of a script which can be altered ... */Map<> variables;this.variables/** A helper constructor used in main(String[]) method calls ... */this(...)setVariable(...)/** @param ... */Object resultIfElseStatementContext _localctxnew IfElseStatementContext(...)expressionInPar(...)_localctx.tbnew MissingPropertyException(...)_localctx.fbGroovyParser.SWITCH/** Sets the value of the given variable ... */SwitchBlockStatementGroupContext.classvisitSwitchStatement(...)/** remove the variable with the specified name ... *//** Simple check for whether the binding contains a particular variable or not. ... *//** Overloaded to make variables appear as bean properties or via the subscript operator */MissingPropertyException egetVariable(...)/** @todo */SwitchStatementContext _localctxnew SwitchStatementContext(...)/** Transforms an instance-style Groovy class or interface to become a static-style ... */switchBlockStatementGroup(...)GroovyParser.FORForControlContext.classimport UncheckedThrowimport StringBuilderWriterimport ReflectionCacheimport CachedClosureClassimport ComposedClosureimport CurriedClosureimport InvokerInvocationExceptionimport BooleanClosureWrapperimport ConcurrentCommonCacheimport ConcurrentSoftCacheimport LRUCacheimport MemoizevisitForStmtAlt(...)/** Represents any closure object in Groovy. ... */new Closure<Object>(...) { ... }Closure$1int OWNER_FIRST;/** With this resolveStrategy set the closure will attempt to resolve property references and methods to the ... */int DELEGATE_FIRST;int OWNER_ONLY;/** With this resolveStrategy set the closure will resolve property references and methods to the owner only ... */int DELEGATE_ONLY;/** With this resolveStrategy set the closure will resolve property references and methods to the delegate ... */int TO_SELF;/** With this resolveStrategy set the closure will resolve property references to itself and go ... */int DONE, ...;...[] EMPTY_OBJECT_ARRAY;Closure<> IDENTITY;Object delegate;Object owner;Object thisObject;int resolveStrategy;int directive;...[] parameterTypes;int maximumNumberOfParameters;BooleanClosureWrapper bcw;CachedClosureClass cachedClassgetCachedClass(...)this.ownerthis.delegatethis.thisObjectgetMaximumNumberOfParameters(...)/** Constructor used when the "this" object for the Closure is null. ... *//** Sets the strategy which the closure uses to resolve property references and methods. ... */this.resolveStrategy/** Gets the strategy which the closure uses to resolve methods and properties ... */getDelegate(...)getOwner(...)getDirective(...)getResolveStrategy(...)getThisObject(...)getPropertyDelegateFirst(...)getPropertyOwnerFirst(...)getPropertyTryThese(...)GroovyParser.WHILEGroovyRuntimeException e1...|...GroovyRuntimeException e2visitWhileStmtAlt(...)setDelegate(...)setMetaClass(...)setResolveStrategy(...)intValue(...)setDirective(...)setPropertyDelegateFirst(...)setPropertyOwnerFirst(...)setPropertyTryThese(...)new BooleanClosureWrapper(...)call(...)/** Invokes the closure without any parameters, returning any value if applicable. ... */invokeMethod(...)InvokerInvocationException erethrow(...)getCause(...)throwRuntimeException(...)/** Invokes the closure, returning any value if applicable. ... */new GroovyRuntimeException(...)getMessage(...)/** @return ... *//** Allows the delegate to be changed such as when performing markup building ... */new WritableClosure(...)/* (non-Javadoc) ... *//** Support for Closure currying. ... */new CurriedClosure<V>(...)curry(...)/** Support for Closure "right" currying. ... */arguments.lengthrcurry(...)/** Support for Closure currying at a given index. ... */ncurry(...)/** Support for Closure forward composition. ... */new ComposedClosure<W>(...)GroovyParser.DOvisitDoWhileStmtAlt(...)/** Support for Closure reverse composition. ... */new ComposedClosure<V>(...)/** Alias for {@link #rightShift(Closure)} ... */rightShift(...)/** Call {@link #andThen(Closure)} on {@code this}. ... */andThen(...)/** Call {@link #andThen(Closure)} on {@code this} exactly {@code times} times. ... */andThenSelf(...)/** Alias for {@link #leftShift(Closure)} ... */leftShift(...)/** Call {@link #compose(Closure)} on {@code this}. ... */compose(...)/** Call {@link #compose(Closure)} on {@code this} exactly {@code times} times. ... */composeSelf(...)/** Alias for calling a Closure for non-closure arguments. ... *//** Creates a caching variant of the closure. ... */buildMemoizeFunction(...)new ConcurrentCommonCache<>(...)/** Creates a caching variant of the closure with upper limit on the cache size. ... */new LRUCache<>(...)/** Creates a caching variant of the closure with automatic cache size adjustment and lower limit ... */buildSoftReferenceMemoizeFunction(...)new ConcurrentSoftCache<Object,Object>(...)LoopStatementContext _localctxnew LoopStatementContext(...)new ForStmtAltContext(...)forControl(...)new WhileStmtAltContext(...)new DoWhileStmtAltContext(...)GroovyParser.CONTINUE/** Creates a caching variant of the closure with automatic cache size adjustment and lower and upper limits ... */visitContinueStatement(...)/** Builds a trampolined variant of the current closure. ... */new TrampolineClosure<V>(...)clone(...)CloneNotSupportedException e/* Implementation note: ... */Closure<>.thisasWritable(...)Writer writernew StringBuilderWriter(...)writeTo(...)IOException enew CurriedClosure<>(...)/** @return */this.directive/** Returns a copy of this closure where the "owner", "delegate" and "thisObject" ... */Closure resultresult.delegateresult.ownerresult.thisObject/** Returns a copy of this closure for which the delegate, owner and thisObject are ... */ContinueStatementContext _localctxnew ContinueStatementContext(...)// let's try getting the property on the first object// let's try getting the property on the second object// ignore, we'll throw e1// let's try setting the property on the first object// let's try setting the property on the second object// unreachable statementGroovyParser.BREAKvisitBreakStatement(...)/** An exception thrown by a closure invocation */Closure<> closure;this.closureBreakStatementContext _localctxnew BreakStatementContext(...)GroovyParser.YIELDvisitYieldStatement(...)/** An interface for MetaMethods that invoke closures to implements. Used by ExpandoMetaClass ... *//** Returns the original closure that this method invokes ... *//** Is it a static method? ... *//** The method name ... *//** Annotation to automatically delegate part of the functionality of an owner class to the ... *//** Whether to apply the delegate pattern to deprecated methods; to avoid compilation ... *//** Whether to carry over annotations from the methods of the delegate ... *//** Whether to carry over annotations from the parameters of delegate ... *//** List of method and/or property names to exclude when delegating. ... *//** List of interfaces containing method signatures to exclude when delegating. ... *//** List of method and/or property names to include when delegating. ... *//** List of interfaces containing method signatures to include when delegating. ... *//** Whether to apply the delegate pattern to all methods, including those with names that are considered internal. ... */YieldStatementContext _localctxnew YieldStatementContext(...)GroovyParser.TRYResourcesContext.classCatchClauseContext.classFinallyBlockContext.classvisitTryCatchStatement(...)import Documented/** This annotation can be used by API or DSL writers to document parameters which accept a closure. ... */ElementType.PARAMETER/** The {@link Closure#resolveStrategy} used by the closure. *//** The index of the generic type that will be the type of the closure's delegate. ... *//** In cases when there are multiple {@code @DelegatesTo.Target} annotated parameters, this ... *//** The type member should be used when the type of the delegate cannot ... *//** Parameter annotation used to specify the delegate for a {@code @DelegatesTo} annotated ... *//** An identifier that should be used to disambiguate targets when there are ... */TryCatchStatementContext _localctxnew TryCatchStatementContext(...)MetaClass delegate;getMetaClassRegistry(...)resources(...)isModified(...)addNewInstanceMethod(...)addNewStaticMethod(...)addMetaMethod(...)catchClause(...)addMetaBeanProperty(...)initialize(...)getAttribute(...)finallyBlock(...)ExpressionContext ce;ExpressionContext me;GroovyParser.ASSERTrespondsTo(...)hasProperty(...)invokeConstructor(...)GroovyParser.COLONinvokeStaticMethod(...)visitAssertStatement(...)setAttribute(...)pickMethod(...)getMetaProperty(...)getStaticMetaMethod(...)getMetaMethod(...)invokeMissingMethod(...)invokeMissingProperty(...)AssertStatementContext _localctxnew AssertStatementContext(...)_localctx.ceselectConstructorAndTransformArguments(...)MissingMethodException e_localctx.mevisitBlockStmtAlt(...)/** Use this exception to mark a method implementation as being deprecated. ... */import AbstractList/** Constructing Ranges like 0..&lt;0 */T at;/** The value at which the range originates (may be <code>null</code>). *//** Creates a new {@link EmptyRange}. ... */this.at/** {@inheritDoc} *//** Never true for an empty range. ... *//** Always 0 for an empty range. ... *//** Always throws <code>IndexOutOfBoundsException</code> for an empty range. ... */new IndexOutOfBoundsException(...)/** Always throws <code>UnsupportedOperationException</code> for an empty range. ... *//** Always does nothing for an empty range. *//** Always returns an empty list for an empty range. */new ArrayList<T>(...)ConditionalStatementContext.classvisitConditionalStmtAlt(...)LoopStatementContext.classvisitLoopStmtAlt(...)TryCatchStatementContext.classvisitTryCatchStmtAlt(...)visitSynchronizedStmtAlt(...)GroovyParser.RETURNvisitReturnStmtAlt(...)GroovyParser.THROWvisitThrowStmtAlt(...)BreakStatementContext.classvisitBreakStmtAlt(...)ContinueStatementContext.classvisitContinueStmtAlt(...)import ClosureParamsimport SimpleTypeimport CachedClassimport MixinInMetaClassimport DefaultCachedMethodKeyimport MetaClassHelperimport MethodKeyimport CallSiteimport ConstructorMetaMethodSiteimport PogoMetaClassSiteimport PojoMetaClassSiteimport StaticMetaClassSiteimport ClosureMetaMethodimport ClosureStaticMetaMethodimport DefaultMetaClassInfoimport MethodSelectionExceptionimport MixedInMetaClassimport MixinInstanceMetaMethodimport OwnedMetaClassimport ThreadManagedMetaBeanPropertyimport FastArrayimport ConcurrentHashMapimport Lockimport ReentrantReadWriteLockimport static MetaClassHelper.EMPTY_TYPE_ARRAY/** ExpandoMetaClass is a MetaClass that behaves like an Expando, allowing the addition or replacement ... */new ReentrantReadWriteLock(...)readLock(...)writeLock(...)new HashSet<MetaMethod>(...)YieldStatementContext.classvisitYieldStmtAlt(...)new ConcurrentHashMap<String,MetaProperty>(...)visitLabeledStmtAlt(...)AssertStatementContext.classnew ConcurrentHashMap<MethodKey,MetaMethod>(...)visitAssertStmtAlt(...)new ConcurrentHashMap<>(...)visitLocalVariableDeclarationStmtAlt(...)new LinkedHashSet<MixinInMetaClass>(...)String META_CLASS;String CLASS;String META_METHODS;String METHODS;String PROPERTIES;String STATIC_QUALIFIER;String CONSTRUCTOR;String CLASS_PROPERTY;String META_CLASS_PROPERTY;String GROOVY_CONSTRUCTOR;MetaClass myMetaClass;// These two properties are used when no ExpandoMetaClassCreationHandle is presentboolean initialized;boolean modified;boolean initCalled;ReentrantReadWriteLock rwl;Lock readLock;Lock writeLock;boolean allowChangesAfterInit;boolean inRegistry;Set<MetaMethod> inheritedMetaMethods;Map<String,MetaProperty> beanPropertyCache;Map<String,MetaProperty> staticBeanPropertyCache;Map<MethodKey,MetaMethod> expandoMethods;values(...)ConcurrentHashMap<> expandoSubclassMethods;Map<String,MetaProperty> expandoProperties;ClosureStaticMetaMethod invokeStaticMethodMethod;Set<MixinInMetaClass> mixinClasses;this.myMetaClassthis.inRegistrythis.allowChangesAfterInit/** Constructs a new ExpandoMetaClass instance for the given class ... *//** Constructs a new ExpandoMetaClass instance for the given class optionally placing the MetaClass ... */MixinInMetaClass mixinCachedClass mixinClassgetMixinClass(...)getMetaClassForClass(...)mixinClass.classInfoMetaClassImpl mcCachedClass clgetCachedSuperClass(...)getTheCachedClass(...)getMethodWithoutCaching(...)MetaMethod methodnew MixinInstanceMetaMethod(...)getParameterTypes(...).length...[...].isPrimitiveMetaMethod noParamfindMixinMethod(...)MethodSelectionException msexregisterInstanceMethod(...)this.invokeMethodMethodaddSuperMethodIfNotOverridden(...)this.setPropertyMethodthis.getPropertyMethodthis.modifiedList<MetaMethod> listcreateMethodList(...)registerSubclassInstanceMethod(...)Object methodOrListvisitExpressionStmtAlt(...)FastArray arrnew FastArray(...)getMixinInstance(...)/** For simulating closures in Java *//** Call to enable global use of ExpandoMetaClass within the registry. ... */setWithoutCustomMetaclassCreationHandle(...)enable(...)/** Call to disable the global use of ExpandoMetaClass */disable(...)lock(...)isInitialized(...)setInitialized(...)this.initCalledunlock(...)/** Checks if the meta class is initialized. ... */this.initializedperformOperationOnMetaClass(...)new Callable(...) { ... }ExpandoMetaClass$1MetaMethod existingGroovyRuntimeException eaddMethodWithKey(...)boolean isGroovyMethodClosureMetaMethod closureMethodClass<> declaringClassClosureMetaMethod localMethodcopy(...)MethodKey keynew DefaultCachedMethodKey(...)checkIfGroovyObjectMethod(...)/** Instances of this class are returned when using the {@code <<} left shift operator. ... */String propertyName;boolean isStatic;this.propertyNamethis.isStaticregisterIfClosure(...)Closure<> callableClass<>[] paramTypesGroovyParser.SEMIvisitEmptyStmtAlt(...)registerStatic(...)registerInstance(...)Method foundMethodcheckIfMethodExists(...)registerStaticMethod(...)parametersAreCompatible(...)Class<>[] argClassesconvertToTypeArray(...)invoke(...)/** Handles the ability to use the left shift operator to append new constructors */retrieveConstructor(...)isValidExpandoProperty(...)new ExpandoMetaProperty(...)new ExpandoMetaConstructor(...)Object[] argsArrdoMethodInvoke(...)argsArr.lengthnew MissingMethodException(...)registerBeanProperty(...)Closure<>.DELEGATE_ONLYDefiningClosure definernew DefiningClosure(...)Object delegateClosure<>.DELEGATE_FIRSTdefiner.definitioncheckInitalised(...)/** Registers a new bean property ... */...->...Class<> typeMetaBeanProperty mbpnew ThreadManagedMetaBeanProperty(...)MetaMethod gettergetGetter(...)MethodKey getterKeyCachedClass.EMPTY_ARRAYMetaMethod settergetSetter(...)MethodKey setterKeyStatementContext _localctxnew StatementContext(...)performRegistryCallbacks(...)/** Registers a new instance method for the given method name and closure on this MetaClass ... */boolean initedString methodNameaddMetaMethodToIndex(...)getHeader(...)dropMethodCache(...)isGetter(...)getPropertyForGetter(...)registerBeanPropertyForMethod(...)isSetter(...)getPropertyForSetter(...)new BlockStmtAltContext(...)/** Overrides the behavior of parent getMethods() method to make MetaClass aware of added Expando methods ... */List<MetaMethod> methodListnew ArrayList<MetaMethod>(...)new ConditionalStmtAltContext(...)conditionalStatement(...)new LoopStmtAltContext(...)loopStatement(...)new TryCatchStmtAltContext(...)tryCatchStatement(...)new SynchronizedStmtAltContext(...)new ReturnStmtAltContext(...)new ThrowStmtAltContext(...)new BreakStmtAltContext(...)addAll(...)breakStatement(...)this.expandoMethodsList<MetaProperty> propertyListnew ArrayList<MetaProperty>(...)new ContinueStmtAltContext(...)continueStatement(...)new YieldStmtAltContext(...)yieldStatement(...)new LabeledStmtAltContext(...)new AssertStmtAltContext(...)assertStatement(...)new LocalVariableDeclarationStmtAltContext(...)new ExpressionStmtAltContext(...)new EmptyStmtAltContext(...)GroovyParser.CATCHMetaClassRegistry registryincVersion(...)MetaClass currMetaClasssetAdaptee(...)Map<String,MetaProperty> propertyCacheCatchTypeContext.classMetaBeanProperty beanPropertyMetaProperty metaPropertyboolean staticPropnew MetaBeanProperty(...)MetaMethod setterMethodvisitCatchClause(...)MetaMethod getterMethod/** Registers a new static method for the given method name and closure on this MetaClass ... */ClosureStaticMetaMethod metaMethodnew ClosureStaticMetaMethod(...)dropStaticMethodCache(...)/** Called from ExpandoMetaClassCreationHandle in the registry if it exists to ... */Object modifiedSuperExpandoExpandoMetaClass superExpandorefreshInheritedMethods(...)getExpandoMethods(...)Collection<MetaProperty> metaPropertiesgetExpandoProperties(...)getClosure(...)Object metaPropertyMetaBeanProperty property/** Returns a list of expando MetaMethod instances added to this ExpandoMetaClass ... */unmodifiableList(...)toList(...)/** Returns a list of MetaBeanProperty instances added to this ExpandoMetaClass ... */unmodifiableCollection(...)/** Overrides default implementation just in case invokeMethod has been overridden by ExpandoMetaClass ... */unwrap(...)/** Overrides default implementation just in case a static invoke method has been set on ExpandoMetaClass ... *//** Overrides default implementation just in case getProperty method has been overridden by ExpandoMetaClass ... */hasOverrideGetProperty(...)isInstance(...)getJavaClass(...)new MixedInAccessor(...)/** Overrides default implementation just in case setProperty method has been overridden by ExpandoMetaClass ... *//** Looks up an existing MetaProperty by name ... */MetaProperty mpthis.expandoProperties/** Returns true if the MetaClass has the given property ... *//** Checks whether a MetaMethod for the given name and arguments exists ... *//** Determine if this method name suffix is a legitimate bean property name. ... */charAt(...)/** Returns true if the name of the method specified and the number of arguments make it a javabean property ... */args.lengthstartsWith(...)isPropertyName(...)/** Returns a property name equivalent for the given getter name or null if it is not a getter ... */String propconvertPropertyName(...)/** Returns a property name equivalent for the given setter name or null if it is not a getter ... */CatchClauseContext _localctxnew CatchClauseContext(...)new PojoMetaClassSite(...)createPojoCallSite(...)new StaticMetaClassSite(...)catchType(...)createStaticSite(...)new PogoMetaClassSite(...)createPogoCallSite(...)createPogoCallCurrentSite(...)GroovyParser.BITORClass<>[] paramsvisitCatchType(...)new ConstructorMetaMethodSite(...)createConstructorSite(...)Class<> klazz;this.klazzObject[] argsboolean definition;mixin(...)singletonList(...)ExpandoMetaClass.thisSubClassDefiningClosure definernew SubClassDefiningClosure(...)MissingMethodException mmeStaticDefiningClosure staticDefnew StaticDefiningClosure(...)Closure<> cObject object;this.objectthis.mixinClassesnew GroovyObjectSupport(...) { ... }ExpandoMetaClass$MixedInAccessor$1MetaClass ownMetaClassnew OwnedMetaClass(...) { ... }ExpandoMetaClass$MixedInAccessor$1$1getAdaptee(...)ExpandoMetaClass$MixedInAccessor$2Object mixedInInstanceExpandoMetaClass$MixedInAccessor$2$1CatchTypeContext _localctxnew CatchTypeContext(...)setMixinInstance(...)GroovyParser.FINALLYvisitFinallyBlock(...)// if the current call itself is with empty arg class array, no need to recurse/* Here we just additionally tried to find another no-arg mixin method of the same name and register that as well, if found. ... */// downgrade to readlock before releasing just in case// ignore, this happens with overlapping method definitions// TODO This is the only area where this MetaClass needs to do some interception because Groovy's current// MetaClass uses hard coded references to the java.lang.reflect.Constructor class so you can't simply// inject Constructor like you can do properties, methods and fields. When Groovy's MetaClassImpl is// refactored we can fix this// we have to use doMethodInvoke here instead of simply invoke,// because getMetaMethod may provide a method that can not be called// without further argument transformation, which is done only in// doMethodInvoke// here we don't care if the method exists or not we assume the// developer is responsible and wants to override methods where necessary// we always adds meta methods to class itself// Implementation note: By default Groovy uses soft references to store MetaClass// this insures the registry doesn't grow and get out of hand. By doing this we're// saying this this EMC will be a hard reference in the registry. As we're only// going have a small number of classes that have modified EMC this is ok//                    cacheStaticMethod(key,metaMethod);// don't inherit static methods except our ownFinallyBlockContext _localctxnew FinallyBlockContext(...)import MetaClassCreationHandleimport ClassInfo/** <p>A handle for the MetaClassRegistry that changes all classes loaded into the Grails VM ... */new ExpandoMetaClassCreationHandle(...)ExpandoMetaClassCreationHandle instance;ExpandoMetaClass.classnew ExpandoMetaClass(...)createNormalMetaClass(...)/** Registers a modified ExpandoMetaClass with the creation handle ... */ResourceListContext.classClass<> klazzgetModifiedExpando(...)getClassInfo(...)/** <p>Enables the ExpandoMetaClassCreationHandle with the registry ... */MetaClassRegistry metaClassRegistrysynchronized (...)getMetaClassCreationHandler(...)clearModifiedExpandos(...)setMetaClassCreationHandle(...)new MetaClassCreationHandle(...)visitResources(...)import GStringImplimport GStringUtilimport StringGroovyMethods/** Represents a String which contains embedded values such as "hello there ... */new GString(...) { ... }GString$1String EMPTY_STRING;...[] EMPTY_STRING_ARRAY;GString EMPTY;/** A GString containing a single empty String and no values. */...[] values;this.values// will be static in an instance/** Overloaded to implement duck typing for Strings ... */plusImpl(...)that.valuesgetStrings(...)new GStringImpl(...)values.lengthWriter buffercalcInitialCapacity(...)new StringWriterIOException(...)calcInitialCapacityImpl(...)writeToImpl(...)buildImpl(...)subSequence(...)/** Turns a String into a regular expression pattern ... */bitwiseNegate(...)getBytes(...)// lets try invoke the method on the real StringResourcesContext _localctxnew ResourcesContext(...)resourceList(...)ResourceContext.class/** An interface implemented by some Groovy proxies which gives access to the proxied object. In particular, dynamically ... */visitResourceList(...)/** Used to grab the referenced artifact and its dependencies and make it available on the Classpath. ... */ElementType.CONSTRUCTORElementType.LOCAL_VARIABLE/** The organisation or group, e.g.: "org.apache.ant". A non-empty value is required unless value() is used. *//** The module or artifact, e.g.: "ant-junit". A non-empty value is required unless value() is used. *//** The revision or version, e.g.: "1.7.1". A non-empty value is required unless value() is used. *//** The classifier if in use, e.g.: "jdk14" *//** Defaults to {@code true} but set to {@code false} if you don't want transitive dependencies also to be downloaded. ... *//** Defaults to {@code false} but set to {@code true} to indicate to the underlying Ivy conflict manager that this ... *//** Defaults to {@code false} but set to {@code true} if the dependency artifacts may change without a corresponding ... *//** The configuration if in use (normally only used by internal ivy repositories). ... *//** The extension of the artifact (normally safe to leave at default value of "jar" but other values like "zip" ... *//** The type of the artifact (normally safe to leave at default value of "jar" but other values like "sources" and "javadoc" are sometimes useful). ... *//** Allows a more compact convenience form in one of two formats with optional appended attributes. ... *//** By default, when a {@code @Grab} annotation is used, a {@code Grape.grab()} call is added ... *//** Used to modify the grape configuration for grab requests. ... *//** Set to true if you want to use the system classloader when loading the grape. ... *//** Define any system properties which must be set before invoking the grab - useful for ... *//** Set to true if you want the context classloader to be initialised to the classloader ... *//** Set to false if you want to disable automatic downloading of locally missing jars. *//** Set to true if you want to disable checksum checking. */ResourceListContext _localctxnew ResourceListContext(...)resource(...)/** Used to exclude an indirectly referenced artifact (a transitive dependency) from the classpath. ... *//** The organisation or group, e.g.: "org.apache.ant"; required unless the compact form is used. *//** The module or artifact, e.g.: "ant-junit"; required unless the compact form is used. *//** Allows you to specify the group (organisation) and the module (artifact) in one of two compact convenience formats, ... */visitResource(...)/** Used to add a repository for resolving Grape dependencies. ... *//** Allows a shorthand form which sets the name and root to this value. ... *//** A meaningful name for a repo containing the grape/artifact. ... *//** The URL for a repo containing the grape/artifact. ... *//** Defaults to Maven2 compatibility. Set false for Ivy only compatibility. *//** By default, when a {@code @GrabResolver} annotation is used, a {@code Grape.addResolver()} call is added ... *//** Sometimes we will need more than one grab per class, but we can only add ... *//** This will be pushed into the child grab annotations if the value is not ... */import Callable/** A special "marker" style interface allowing Groovy classes to implement both ... */ResourceContext _localctxnew ResourceContext(...)import CharsetToolkitimport GroovyBugErrorimport InnerClassNodeimport GeneratorContextimport Verifierimport BytecodeProcessorimport CompilationFailedExceptionimport CompilerConfigurationimport Phasesimport EncodingGroovyMethodsimport IOGroovyMethodsimport EvictableCacheimport StampedCommonCacheimport UnlimitedConcurrentCacheimport URLStreamsimport ClassVisitorimport ClassWriterimport InputStreamimport InputStreamReaderimport MalformedURLExceptionimport URLimport URLClassLoaderimport URLConnectionimport URLDecoderimport CodeSourceimport NoSuchAlgorithmExceptionimport Permissionimport PermissionCollectionimport Permissionsimport ProtectionDomainimport Enumeration/** A ClassLoader which can load Groovy classes. The loaded classes are cached, ... */new UnlimitedConcurrentCache<String,Class<>>(...)new StampedCommonCache<String,Class<>>(...)new GroovyResourceLoader(...) { ... }GroovyClassLoader$1new PrivilegedAction<URL>(...) { ... }String extensiongetScriptExtensions(...)URL retgetSourceFile(...)Throwable tnew URL[]new Class<>[]...[] EMPTY_URL_ARRAY;...[] EMPTY_CLASS_ARRAY;EvictableCache<String,Class<>> classCache;/** this cache contains the loaded classes or PARSING, if the class is currently parsed */StampedCommonCache<String,Class<>> sourceCache;/** This cache contains mappings of file name to class. It is used ... */CompilerConfiguration config;String sourceEncoding;Boolean recompile;int scriptNameCounter;// use 1000000 as offset to avoid conflicts with names from the GroovyShellGroovyResourceLoader resourceLoader;/** creates a GroovyClassLoader using the current Thread's context ... */getContextClassLoader(...)currentThread(...)/** creates a GroovyClassLoader using the given ClassLoader as parent *//** creates a GroovyClassLoader using the given GroovyClassLoader as parent. ... */parent.config/** creates a GroovyClassLoader. ... */CompilerConfiguration.DEFAULTthis.configString pathgetClasspath(...)addClasspath(...)initSourceEncoding(...)getSourceEncoding(...)getDefaultSystemCharset(...)/** creates a GroovyClassLoader using the given ClassLoader as parent. */this.resourceLoader/** Loads the given class node returning the implementation Class. ... */CodeSource codeSourceCompilationUnit unitcreateCompilationUnit(...)ClassCollector collectorcreateCollector(...)getContext(...)getModule(...)new CodeSource(...)new URL(...)MalformedURLException eaddClassNode(...)setClassgenCallback(...)Phases.CLASS_GENERATIONdefinePackageInternal(...)collector.generatedClassSwitchLabelContext.classvisitSwitchBlockStatementGroup(...)CompilationFailedException e/** Check if this class loader has compatible {@link CompilerConfiguration} ... *//** Parses the given file into a Java class capable of being run ... */parseClass(...)new GroovyCodeSource(...)/** Parses the given text into a Java class capable of being run ... */GroovyCodeSource gcscreateCodeSource(...)new PrivilegedAction<GroovyCodeSource>(...) { ... }setCachable(...)md5(...)NoSuchAlgorithmException enew GroovyBugError(...)String scriptTextisCachable(...)/** Parses the given code source into a Java class. If there is a class file ... */String cacheKeygenSourceCacheKey(...)getAndPut(...)new ValueProvider<String,Class<>>(...) { ... }doParseClass(...)StringBuilder strToDigestgetScriptText(...)CodeSource csgetCodeSource(...)Class<> answerSourceUnit suFile filegetFile(...)int goalPhaseString mainClassgetMainClassName(...)validate(...)getRecompileGroovySource(...)addFirstPhaseOperation(...)TimestampAdder.INSTANCEgetPhaseNumber(...)CompilePhase.CLASS_GENERATIONaddSource(...)URL urlgetURL(...)getTargetDirectory(...)Phases.OUTPUTgetLoadedClasses(...)Class<> clazzString clazzNamesetClassCacheEntry(...)String pkgNamePackage pkgdefinePackage(...)/** gets the currently used classpath. ... */URL[] urlsgetURLs(...)String[] returls.lengthret.lengthPermissionCollection permsProtectionDomain myDomaingetProtectionDomain(...)PermissionCollection myPermsgetPermissions(...)SecurityException enew Permissions(...)Enumeration<Permission> elementselements(...)hasMoreElements(...)nextElement(...)Throwable esetReadOnly(...)new PrivilegedAction<ProtectionDomain>(...) { ... }GroovyClassLoader$2GroovyClassLoader delegate;long timeStamp;clearCache(...)findResource(...)findResources(...)getResource(...)getResourceAsStream(...)getResourceLoader(...)Class<> cfindLoadedClass(...)loadClass(...)setResourceLoader(...)addURL(...)defineClass(...)generateScriptName(...)setShouldRecompile(...)isShouldRecompile(...)getResources(...)setDefaultAssertionStatus(...)setPackageAssertionStatus(...)setClassAssertionStatus(...)clearAssertionStatus(...)/** creates a new CompilationUnit. If you want to add additional ... */new CompilationUnit(...)/** creates a ClassCollector for a new compilation. ... */new ClassCollector(...)createLoader(...)new PrivilegedAction<InnerLoader>(...) { ... }new InnerLoader(...)GroovyClassLoader.thisCompilationUnit.ClassgenCallbackClass<> generatedClass;GroovyClassLoader cl;SourceUnit su;CompilationUnit unit;Collection<Class<>> loadedClasses;this.clthis.unitthis.loadedClassesnew ArrayList<Class<>>(...)SwitchBlockStatementGroupContext _localctxnew SwitchBlockStatementGroupContext(...)this.suswitchLabel(...)BytecodeProcessor bytecodePostprocessorgetBytecodePostprocessor(...)getConfiguration(...)byte[] fcodeGroovyClassLoader clgetDefiningClassLoader(...)Class<> theClassfcode.lengthprocessBytecode(...)SourceUnit msuClassNode mainGroovyParser.CASEvisitSwitchLabel(...)byte[] codetoByteArray(...)createClass(...)onClassNode(...)/** Converts an array of bytes into an instance of {@code Class}. */bytes.length/** loads a class from a file or a parent classloader. ... *//** gets a class from the class cache. This cache contains only classes loaded through ... *//** sets an entry in the class cache. ... *//** removes a class from the class cache. ... *//** adds a URL to the classloader. ... *//** Indicates if a class is recompilable. Recompilable means, that the classloader ... */long timestampgetTimeStamp(...)Long.MAX_VALUE/** sets if the recompilation should be enable. There are 3 possible ... *//** gets the currently set recompilation mode. null means, the ... */Class<> clsgetClassCacheEntry(...)boolean recompileisRecompilable(...)ClassNotFoundException lastSecurityManager smgetSecurityManager(...)Class<> parentClassLoaderClassClassNotFoundException cnfeNoClassDefFoundError ncdfenew ClassNotFoundException(...)checkPackageAccess(...)Class<> classCacheEntryURL sourceloadGroovySource(...)Class<> oldClassrecompile(...)IOException ioeremoveClassCacheEntry(...)new AssertionError(...)SwitchLabelContext _localctxnew SwitchLabelContext(...)/** (Re)Compiles the given source. ... */isSourceNewer(...)toExternalForm(...)isFile(...)new InputStreamReader(...)openUncachedStream(...)/** Implemented here to check package access prior to returning an ... *//** gets the time stamp of a given class. For groovy ... */getTimestamp(...)/** This method will take a file name and try to "decode" any URL encoded characters.  For example ... */String decodedFiledecode(...)EnhancedForControlContext.classUnsupportedEncodingException eSystem.errClassicalForControlContext.classgetProtocol(...)String fileWithoutPackageint indexfileReallyExists(...)File pathvisitForControl(...)decodeFileName(...)getParentFile(...)exists(...)String caseSensitiveNamegetCanonicalPath(...)File.separatorIOException ignoreString filenamegetFileForUrl(...)/** Decides if the given source is newer than a class. ... */long lastModlong classTimegetPath(...)File.separatorCharlastModified(...)URLConnection connopenConnection(...)getLastModified(...)getInputStream(...)getMinimumRecompilationInterval(...)/** adds a classpath to this classloader. ... */URI newURItoURL(...)/** <p>Returns all Groovy classes loaded by this class loader. ... *//** Removes all classes from the class cache. ... */Map<String,Class<>> clearedClassesclearAll(...)clear(...)Entry<String,Class<>> entryMap<>.Entry<String,Class<>>removeClass(...)/** Closes this GroovyClassLoader and clears any caches it maintains. ... */CompilationUnit.IPrimaryClassNodeOperationnew TimestampAdder(...)TimestampAdder INSTANCE;getDeclaredField(...)Verifier.__TIMESTAMPFieldNode timeTagFieldnew FieldNode(...)ClassHelper.long_TYPEnew ConstantExpression(...)Verifier.__TIMESTAMP__ForControlContext _localctxnew ForControlContext(...)Opcodes.ACC_INTERFACEaddTimeStamp(...)/* @todo multi threaded compiling of the same class but with different roots ... */enhancedForControl(...)classicalForControl(...)// Keep the same default source encoding with the one used by #parseClass(InputStream, String)// TODO should we use org.codehaus.groovy.control.CompilerConfiguration.DEFAULT_SOURCE_ENCODING instead?//swallow// should never happen// it's better to cache class instances by the source code// GCL will load the unique class instance for the same source code// and avoid occupying Permanent Area/Metaspace repeatedly// if the script text is null, i.e. the script content is invalid// use the name as cache key for the time being to trigger the validation by `groovy.lang.GroovyClassLoader.validate`// note: the script will not be cached due to the invalid script content,//       so it does not matter even if cache key is not the md5 value of script content// should never reach here!// Was neither already loaded nor compiling, so compile and add to cache.// TODO replace getPackage with getDefinedPackage once min JDK version >= 9//workaround for Groovy-835// We lied about our CodeSource and that makes URLClassLoader unhappy.// TODO a future Groovy version should remove the security check// look into cache// enable recompilation?// try parent loader// always return if the parent loader was successful// check security manager// no checks on the sun.reflect classes for reflection speed-up// in particular ConstructorAccessorImpl, MethodAccessorImpl, FieldAccessorImpl and SerializationConstructorAccessorImpl// which are generated at runtime by the JDK// prefer class if no recompilation// at this point the loading from a parent loader failed// and we want to recompile if needed.// try groovy file// check if recompilation already happened.// if recompilation fails, we want cls==null// no class found, there should have been an exception before now// found a source, compile it if newer// do nothing and fall back to the other version/* fix for GROOVY-5809 */// file.exists() might be case insensitive.// Let's do case sensitive match for the filename// assume doesn't really exist if we can't read the file// file does not exist!// Special handling for file:// protocol, as getLastModified() often reports// incorrect results (-1)// Coerce the file URL to a File// See ClassNodeResolver.isSourceNewer for another method that replaces '|' with ':'.// WTF: Why is this done and where is it documented?// check if we can create a URL from that URI// the URI has a false format, so lets try it with files ...// Do not use URL.equals.  It uses the network to resolve names and compares ip addresses!// That is a violation of RFC and just plain evil.// http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html// http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)// "Since hosts comparison requires name resolution, this operation is a blocking operation.// Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP."// fail fast! if we got a malformed URI the Classloader has to tell it// fail fast! if we got a malformed URL the Classloader has to tell it// Another Thread may be using an instance of this class// (for the first time) requiring a ClassInfo lock and// classloading which would require a lock on classCache.// The following locks on ClassInfo and to avoid deadlock// should not be done with a classCache lock.// in case if verifier visited the call already//"",// alternatively, FieldNode timeTagField = SourceUnit.createFieldNode("public static final long __timeStamp = " + System.currentTimeMillis() + "L");// does not apply on interfacesimport GroovyCodeSourcePermissionimport ResourceGroovyMethodsimport PrivilegedActionExceptionimport PrivilegedExceptionActionimport Certificateimport Objects/** CodeSource wrapper class that allows specific security policies to be associated with a class ... */CodeSource codeSource;/** The codeSource to be given the generated class.  This can be used by policy file ... */String name;/** The name given to the generated class */String scriptText;/** The groovy source to be compiled and turned into a class */...[] certs;/** The certificates used to sign the items from the codesource */boolean cachable;File file;URL url;this.namethis.scriptTextthis.codeSourcethis.cachable/** Construct a GroovyCodeSource for an inputStream of groovyCode that has an ... */new FileNotFoundException(...)getAbsolutePath(...)isDirectory(...)canRead(...)this.fileObject[] infonew PrivilegedExceptionAction<Object[]>(...) { ... }Object[] info1PrivilegedActionException paeThrowable causethis.urlvisitEnhancedForControl(...)String contentEncodinggetContentEncoding(...)/** TODO(jwagenleitner): remove or fix in future release ... */URLConnection urlConnectionString encodingcloseQuietly(...)checkPermission(...)new GroovyCodeSourcePermission(...)GroovyCodeSource thatthat.codeSourcehash(...)// avoid files which confuse us like ones with .. in path//The calls below require access to user.dir - allow here since getName() and getCodeSource() are//package private and used only by the GroovyClassLoader.// retrieve the content of the file using the provided encoding//toURI().toURL() will encode, but toURL() will not.// TODO: GROOVY-6561: GroovyMain got the name this way: script.substring(script.lastIndexOf('/') + 1)// falls-back on default encoding// For compatibility, ignore exceptions from getInputStream() call/** Marker interface used to notify that all methods should be intercepted through the <code>invokeMethod</code> mechanism ... */import Internal/** The interface implemented by all Groovy objects. ... *//** Invokes the given method. ... *//** Retrieves a property value. ... *//** Sets the given property to the new value. ... *//** Returns the metaclass for a given class. ... *//** Allows the MetaClass to be replaced with a derived implementation. ... */EnhancedForControlContext _localctxnew EnhancedForControlContext(...)// marked as internal just for backward compatibility, e.g. AbstractCallSite.createGroovyObjectGetPropertySite will check `isMarkedInternal`ForInitContext.classForUpdateContext.classvisitClassicalForControl(...)import Transientimport Optional/** Base class for Java objects wishing to be Groovy objects. */getDefaultMetaClass(...)MetaClass metaClass;// never persist the MetaClassthis.metaClassorElseGet(...)ofNullable(...)...::...new Supplier<MetaClass>(...) { ... }/* @Nullable *//** Allows frameworks that integrate with Groovy to determine how Groovy files are resolved. *//** Loads a Groovy source file given its name. ... *//** An exception thrown by the interpreter */ClassicalForControlContext _localctxnew ClassicalForControlContext(...)ModuleNode module;ASTNode node;this.nodeinitCause(...)this.moduleString messageWithoutLocationTextgetMessageWithoutLocationText(...)String locationTextgetLocationText(...)forInit(...)forUpdate(...)String answerExpressionListContext.classgetColumnNumber(...)getLineNumber(...)getDescription(...)visitForInit(...)// not "null"ForInitContext _localctxnew ForInitContext(...)expressionList(...)visitForUpdate(...)ForUpdateContext _localctxnew ForUpdateContext(...)visitCastParExpression(...)CastParExpressionContext _localctxnew CastParExpressionContext(...)visitParExpression(...)import GroovyMainimport GroovyRunnerimport GroovyRunnerRegistryimport InvocationTargetExceptionimport AtomicIntegerimport static ResolveVisitor.EMPTY_STRING_ARRAYimport static InvokerHelper.MAIN_METHOD_NAME/** Represents a groovy shell capable of running arbitrary groovy scripts */new AtomicInteger(...)String DEFAULT_CODE_BASE;String CONFIGURATION_CUSTOMIZER;Binding context;AtomicInteger counter;GroovyClassLoader loader;main(...)/** @since */CompilerConfiguration confignew CompilerConfiguration(...)getDeclaredMethod(...)ParExpressionContext _localctxnew ParExpressionContext(...)visitExpressionInPar(...)CompilerConfiguration.classReflectiveOperationException enew GroovyShell(...)new Binding(...)ClassLoader parentLoaderGroovyShell.classhasCompatibleConfiguration(...)this.loadernew PrivilegedAction<GroovyClassLoader>(...) { ... }new GroovyClassLoader(...)this.context/** Creates a child shell using a new ClassLoader which uses the parent shell's ... */shell.loadershell.contextObject answerReadOnlyPropertyException e/** A helper method which runs the given script file with the given command line arguments ... */ExpressionInParContext _localctxnew ExpressionInParContext(...)boolean canSpread;ExpressionListElementContext.class/** A helper method which runs the given cl script with the given command line arguments ... *//** Runs the given script file name with the given command line arguments ... */String scriptNameint pThread threadclass ...Class<> scriptClass... >= ...this.canSpreadnew CompilationFailedException(...)GroovyShell$1DoSetContext//ClassLoader currentClassLoader = thread.getContextClassLoader();visitExpressionList(...)ClassLoader classLoader;setContextClassLoader(...)new DoSetContext(...)new PrivilegedExceptionAction<Class<>>(...) { ... }getException(...)runScriptOrMainOrTestOrRunnable(...)/** if (theClass is a Script) { ... */Script.classScript scriptnewScript(...)getMethod(...)...[].classExpressionListContext _localctxnew ExpressionListContext(...)NoSuchMethodException eexpressionListElement(...)GroovyRunnerRegistry runnerRegistry_localctx.canSpreadStringBuilder messageRunnable.classvisitExpressionListElement(...)runRunnable(...)GroovyRunner runnercanRun(...)Constructor<> constructorRunnable runnableThrowable reasongetConstructor(...)NoSuchMethodException e1InvocationTargetException itenew InvokerInvocationException(...)getTargetException(...)NoSuchMethodException nsme/** Runs the given script text with command line arguments ... *//** Runs the given script source with command line arguments ... *//** Runs the given script with command line arguments ... */getVariables(...)ExpressionListElementContext _localctxnew ExpressionListElementContext(...)removeVariable(...)/** Evaluates some script against the current Binding and returns the result ... */parse(...)visitEnhancedStatementExpression(...)evaluate(...)/** Evaluates some script against the current Binding and returns the result. ... *//** Parses the given script and returns it ready to be run ... *//** Parses the groovy code contained in codeSource and returns a java class. *//** Parses the given script and returns it ready to be run.  When running in a secure environment ... */createScript(...)incrementAndGet(...)//TODO return new GroovyShell(CompilerCustomizationBuilder.withConfig(new CompilerConfiguration(), spec));// probably a dynamic property// Get the current context classloader and save it on the stack// Parse the script, generate the class, and invoke the main method.  This is a little looser than// if you are compiling the script because the JVM isn't executing the main method.// Set the context classloader back to what it was.//AccessController.doPrivileged(new DoSetContext(currentClassLoader));// Always set the "args" property, regardless of what path we take in the code.// Bad enough to have side effects but worse if their behavior is wonky.//TODO: This logic mostly duplicates InvokerHelper.createScript.  They should probably be unified.// treat it just like a script if it is one// ignore instantiation errors, try to do main// let's find a main method// if that main method exist, invoke it// if it implements Runnable, try to instantiate it// first, fetch the constructor taking String[] as parameter// instantiate a runnable and run it// otherwise, find the default constructor// TODO a future Groovy version should skip security checks// Don't cache scriptsEnhancedStatementExpressionContext _localctxnew EnhancedStatementExpressionContext(...)standardLambdaExpression(...)CommandExpressionContext.classimport MetaClassRegistryImplimport ReferenceBundleimport ReleaseInfovisitCommandExprAlt(...)new MetaClassRegistryImpl(...)boolean USE_REFLECTION;/** If true then the MetaClass will only use reflection for method dispatch, property access, etc. */MetaClassRegistry META_CLASS_REGISTRY;/** Reference to the MetaClass Registry to be used by the Groovy run-time system to map classes to MetaClasses */Map<String,GroovyRunner> RUNNER_REGISTRY;/** Reference to the Runtime Registry to be used by the Groovy run-time system to find classes capable of running scripts ... */boolean keepJavaMetaClasses;GroovySystem.keepJavaMetaClasses/** This method can be used to ensure that no threaded created ... */stopThread(...)getManager(...)getSoftBundle(...)getWeakBundle(...)/** Returns the groovy version */getVersion(...)/** Returns the major and minor part of the groovy version excluding the point/patch part of the version. ... */String fullint firstDotint secondDot//  TODO: make this initialization able to set useReflection true//  TODO: have some way of specifying another MetaClass Registry implementation// Do not allow this class to be instantiated/** An annotation to hold the groovydoc for the annotated element at runtime, we call it "Runtime Groovydoc". ... */ElementType.ANNOTATION_TYPE/** An exception occurred if a dynamic property dispatch fails with a ... */String accessString propertyTypeisProtected(...)StatementExpressionContext _localctxnew StatementExpressionContext(...)isPublic(...)new CommandExprAltContext(...)commandExpression(...)Token op;PathExpressionContext.classGroovyParser.INCGroovyParser.DECvisitPostfixExpression(...)makeMessage(...)/** An exception occurred when invoking a Closure with the wrong number and/or ... */Object arguments;...[] expected;this.argumentsthis.expectedimport IteratorClosureAdapterimport RangeInfoimport BigIntegerimport NoSuchElementException/** Represents a list of Integer objects starting at and potentially including a specified ... *//** Iterates through each number in an <code>IntRange</code>. */isReverse(...)getTo(...)getFrom(...)int index;/** Counts from 0 up to size - 1. */int size;/** The number of values in the range. */int value;/** The next value to return. */new NoSuchElementException(...)--...++.../** Not supported. ... */IntRange.thisPostfixExpressionContext _localctxnew PostfixExpressionContext(...)pathExpression(...)_localctx.opSwitchBlockStatementExpressionGroupContext.classvisitSwitchExpression(...)int from;/** For non-inclusive aware ranges, the first number in the range; <code>from</code> is always less than or equal to <code>to</code>. ... */int to;/** For non-inclusive aware ranges, the last number in the range; <code>to</code> is always greater than or equal to <code>from</code>. ... */boolean reverse;/** If <code>false</code>, counts up from <code>from</code> to <code>to</code>.  Otherwise, counts down ... */Boolean inclusiveRight;/** If <code>true</code> or null, <code>to</code> is included in the range. ... */Boolean inclusiveLeft;/** If <code>true</code> or null, <code>from</code> is included in the range. ... *//** Creates a new non-inclusive aware <code>IntRange</code>. If <code>from</code> is greater than ... */this.inclusiveRightthis.inclusiveLeftthis.fromthis.tothis.reversecheckSize(...)/** Creates a new non-inclusive aware <code>IntRange</code>. ... *//** Creates a new inclusive aware <code>IntRange</code>. ... *//** Creates a new inclusive aware <code>IntRange</code> ... *//** Creates a new NumberRange with the same <code>from</code> and <code>to</code> as this ... */new NumberRange(...)long sizeInteger.MAX_VALUE/** A method for determining from and to information when using this IntRange to index an aggregate object of the specified size. ... */new IllegalStateException(...)subListBorders(...)int tempFromint tempTonew RangeInfo(...)/** Determines if this object is equal to another object. Delegates to ... *//** Compares an {@link IntRange} to another {@link IntRange}. ... */that.fromthat.tothat.reversethat.inclusiveLeftthat.inclusiveRight/** Returns the same as <code>getInclusiveRight</code>, kept here for backwards compatibility. */getInclusiveRight(...)/** Returns the inclusiveRight flag. Null for non-inclusive aware ranges or non-null for inclusive aware ranges. *//** Returns the inclusiveLeft flag. Null for non-inclusive aware ranges or non-null for inclusive aware ranges. *//** Gets the 'from' value as a primitive integer. ... *//** Gets the 'to' value as a primitive integer. ... */max(...)new IntRangeIterator(...)new EmptyRange<Integer>(...)SwitchExpressionContext _localctxnew SwitchExpressionContext(...)switchBlockStatementExpressionGroup(...)_ctx.stopnew IntRange(...)SwitchExpressionLabelContext.classBigInteger bigintIntRange rangecontainsAll(...)visitSwitchBlockStatementExpressionGroup(...)int valueIteratorClosureAdapter<Integer> adapternew IteratorClosureAdapter<Integer>(...)step(...)int hashCodeint fromint to// range may still be reversed, this value is ignored for inclusive-aware ranges// GROOVY-10496// size() in the Collection interface returns an integer, so ranges can have no more than Integer.MAX_VALUE elements// If inclusiveRight is null, then inclusive left is also null (see constructor)// If fully exclusive and borders are one apart, the size would be negative, take that into account// from == to and step == 0, nothing to do, so return/** Implementers of this interface can be registered in the ProxyMetaClass for ... *//** This code is executed before the method is optionally called. ... *//** This code is executed after the method is optionally called. ... */SwitchBlockStatementExpressionGroupContext _localctxnew SwitchBlockStatementExpressionGroupContext(...)switchExpressionLabel(...)Token ac;visitSwitchExpressionLabel(...)/** Field annotation to simplify lazy initialization. ... */SwitchExpressionLabelContext _localctxnew SwitchExpressionLabelContext(...)_localctx.acCastParExpressionContext.classvisitCastExprAlt(...)import ListIterator/** A wrapper for {@link List} which automatically grows the list when either {@link #get(int)} or ... */List<T> delegate;boolean lazyDefaultValues;Closure<> initClosure;this.lazyDefaultValuesthis.initClosurePostfixExpressionContext.classvisitPostfixExprAlt(...)SwitchExpressionContext.classvisitSwitchExprAlt(...)new ListWithDefault<T>(...)removeAll(...)retainAll(...)/** Overwrites subscript operator handling by redirecting to {@link #get(int)}. ... *//** Returns the element at the given index but grows the list if needed. If the requested {@code index} is ... */int sizeint normalisedIndexnormaliseIndex(...)T itemint gapCountint idxgetDefaultValue(...)set(...)GroovyParser.BITNOTGroovyParser.NOTvisitUnaryNotExprAlt(...)listIterator(...)/** Returns a view of a portion of this list. This method returns a list with the same ... */new ListWithDefault(...)subList(...)// either index >= size or the normalised index is negative// find out the number of gaps to fill with null/the default value// fill all gaps// if we lazily create default values, use 'null' as placeholder// add the first/last element being always the default value// normalise index again to get positive index/** A wrapper for Map which allows a default value to be specified using a closure. ... */Map<K,V> delegate;Closure<V> initClosure;boolean autoGrow;boolean autoShrink;this.autoGrowthis.autoShrink/** Decorates the given Map allowing a default value to be specified. ... */new MapWithDefault<K,V>(...)ExpressionContext left;ExpressionContext right;GroovyParser.POWERvisitPowerExprAlt(...)containsValue(...)/** Returns the value to which the specified key is mapped, ... */V value/** Associates the specified value with the specified key in this map. ... */forEach(...)GroovyParser.ADDGroovyParser.SUBvisitUnaryAddExprAlt(...)new Consumer<Entry<? extends K,? extends V>>(...) { ... }Map<>.Entry<K,V>/** Represents the length property of an array *//** Sole constructor setting name to "length" and type to int */int.class/** Get this property from the given object. ... */getLength(...)/** Sets the property on the given object to the new value ... */new ReadOnlyPropertyException(...)GroovyParser.DIVGroovyParser.MODvisitMultiplicativeExprAlt(...)import CachedFieldimport DefaultTypeTransformation/** Represents a property on a bean which may have a getter and/or a setter */MetaMethod getter;MetaMethod setter;CachedField field;/** Sole constructor setting name, type (class), getter and setter. */this.getterthis.setter/** Get the property of the given object. ... */MetaClassHelper.EMPTY_ARRAY/** Set the property on the given object to the new value. ... */castToType(...)/** Get the getter method. ... *//** Get the setter method. ... *//** This is for MetaClass to patch up the object later when looking for get*() methods. ... *//** This is for MetaClass to patch up the object later when looking for set*() methods. ... *//** Gets the visibility modifiers for the property as defined by the getter and setter methods. ... */int modifiersint visibilityint statesModifier.PROTECTEDisPrivate(...)Modifier.PRIVATE...&=......|=.../** Sets the field of this property ... */this.field/** Gets the field of this property ... *///TODO: create a WriteOnlyException class?/** A MetaClass within Groovy defines the behaviour of any given Groovy or Java class. The MetaClass ... *//** <p>Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object. ... *//** <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object. ... *//** <p>Sets a property on the given receiver for the specified arguments. The sender is the class that is setting the property from the object. ... *//** <p>Attempts to invoke the methodMissing method otherwise throws a MissingMethodException ... *//** Invokes the propertyMissing method otherwise throws a MissingPropertyException ... *//** Retrieves the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. ... *//** Sets the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. ... *//** Complete the initialisation process. After this method ... *//** Retrieves a list of MetaProperty instances that the MetaClass has ... *//** Retrieves a list of MetaMethods held by the class. This list does not include MetaMethods added by groovy.lang.ExpandoMetaClass. ... *//** Obtains a reference to the original AST for the MetaClass if it is available at runtime ... *//** Retrieves a list of MetaMethods held by this class. This list includes MetaMethods added by groovy.lang.ExpandoMetaClass. ... *//** Internal method to support Groovy runtime. Not for client usage. ... *//** Selects a method by name and argument classes. This method ... */visitAdditiveExprAlt(...)import GroovyObjectHelperimport BeanUtilsimport SystemUtilimport BytecodeHelperimport CacheAccessControlExceptionimport CachedConstructorimport CachedMethodimport GeneratedMetaMethodimport ParameterTypesimport ReflectionUtilsimport AndroidSupportimport ArrayTypeUtilsimport ArrayUtilimport ConvertedClosureimport GeneratedClosureimport GroovyCategorySupportimport CategoryMethodimport MethodClosureimport AbstractCallSiteimport ConstructorSiteimport MetaClassConstructorSiteimport PogoMetaMethodSiteimport PojoMetaMethodSiteimport StaticMetaMethodSiteimport MetaMethodIndeximport GetBeanMethodMetaPropertyimport GetMethodMetaPropertyimport MissingMethodExceptionNoStackimport MissingMethodExecutionFailedimport MissingPropertyExceptionNoStackimport MultipleSetterPropertyimport NewInstanceMetaMethodimport NewMetaMethodimport NewStaticMetaMethodimport TransformMetaMethodimport NumberMathModificationInfoimport Wrapperimport ComplexKeyHashMapimport SingleKeyHashMapimport VMPluginimport VMPluginFactoryimport BeanInfoimport EventSetDescriptorimport Introspectorimport PropertyDescriptorimport MethodHandleimport MethodHandlesimport Arrayimport Proxyimport ConcurrentMapimport BiConsumerimport Functionimport static Tuple.tupleimport static Character.isUpperCaseimport static Arrays.concatimport static GeneralUtils.inSamePackageimport static ReflectionCache.isAssignableFromimport static ReflectionUtils.parameterTypeMatchesimport static MetaClassHelper.castArgumentsToClassArrayToken dlOp;Token tgOp;Token dgOp;Token rangeOp;GroovyParser.RANGE_INCLUSIVEGroovyParser.RANGE_EXCLUSIVE_LEFTGroovyParser.RANGE_EXCLUSIVE_RIGHTGroovyParser.RANGE_EXCLUSIVE_FULLvisitShiftExprAlt(...)/** Allows methods to be dynamically added to existing classes at runtime ... */new LinkedHashMap<CachedClass,LinkedHashMap<String,MetaProperty>>(...)GroovyParser.INSTANCEOFGroovyParser.NOT_INSTANCEOFGroovyParser.LEGroovyParser.GEGroovyParser.NOT_INvisitRelationalExprAlt(...)new LinkedHashMap<String,MetaProperty>(...)new LinkedHashMap<String,MetaMethod>(...)GroovyParser.IDENTICALGroovyParser.NOT_IDENTICALGroovyParser.EQUALGroovyParser.NOTEQUALGroovyParser.SPACESHIPvisitEqualityExprAlt(...)GroovyParser.REGEX_FINDGroovyParser.REGEX_MATCHvisitRegexExprAlt(...)new MetaArrayLengthProperty(...)new LinkedHashSet<MetaMethod>(...)new DummyMetaMethod(...)comparing(...)new Function<CachedClass,String>(...) { ... }getBooleanSafe(...)getPlugin(...)new ClassValue<Map<String,Set<Method>>>(...) { ... }MetaClassImpl$2new ConcurrentHashMap<String,Set<Method>>(...)visitAndExprAlt(...)GroovyParser.XORvisitExclusiveOrExprAlt(...)new ConcurrentHashMap<String,String>(...)new Copier(...) { ... }new SingleKeyHashMap(...)visitInclusiveOrExprAlt(...)...[] EMPTY_ARGUMENTS;String STATIC_METHOD_MISSING;String STATIC_PROPERTY_MISSING;String METHOD_MISSING;String PROPERTY_MISSING;String INVOKE_METHOD_METHOD;String CALL_METHOD;String DO_CALL_METHOD;String CONSTRUCTOR_NAME;String GET_PROPERTY_METHOD;String SET_PROPERTY_METHOD;...[] METHOD_MISSING_ARGS;...[] GETTER_MISSING_ARGS;...[] SETTER_MISSING_ARGS;MetaMethod AMBIGUOUS_LISTENER_METHOD;Comparator<CachedClass> CACHED_CLASS_NAME_COMPARATOR;boolean PERMISSIVE_PROPERTY_ACCESS;VMPlugin VM_PLUGIN;Class<> theClass;CachedClass theCachedClass;boolean isGroovyObject;boolean isMap;MetaMethodIndex metaMethodIndex;Map<CachedClass,LinkedHashMap<String,MetaProperty>> classPropertyIndex;Map<String,MetaProperty> staticPropertyIndex;Map<String,MetaMethod> listeners;List<MetaMethod> allMethods;MetaProperty arrayLengthProperty;// we only need one of these that can be reused over and over.Map<CachedClass,LinkedHashMap<String,MetaProperty>> classPropertyIndexForSuper;Set<MetaMethod> newGroovyMethodsSet;...[] myNewMetaMethods;...[] additionalMetaMethods;MetaMethod getPropertyMethod;MetaMethod invokeMethodMethod;MetaMethod setPropertyMethod;MetaClassRegistry registry;ClassNode classNode;FastArray constructors;MetaMethod genericGetMethod;MetaMethod genericSetMethod;MetaMethod propertyMissingGet;MetaMethod propertyMissingSet;MetaMethod methodMissing;MetaMethodIndex.Header mainClassMethodHeader;MetaMethodIndex.Headerboolean permissivePropertyAccess;/** Constructor ... */MetaMethod[] metaMethodsgetNewMetaMethods(...)this.theClassthis.isGroovyObjectthis.isMapthis.registrynew MetaMethodIndex(...)add.lengthconcat(...)MetaMethod.EMPTY_ARRAY/** Constructor that sets the methods to null ... *//** Constructor with registry ... */this.constructors/** Constructor with registry setting methods to null ... *//** Returns the cached class for this metaclass ... *//** Returns the registry for this metaclass ... *//** @see */Class<>[] classescastArgumentsToClassArray(...)MetaMethod mGroovyParser.ANDemptyList(...)visitLogicalAndExprAlt(...)LinkedHashMap<String,MetaProperty> propertyMapcomputeIfAbsent(...)new Function<CachedClass,LinkedHashMap<String,MetaProperty>>(...) { ... }findPropertyInClassHierarchy(...)onSuperPropertyFoundInHierarchy(...)pickStaticMethod(...)/** Returns the class this object this is the metaclass of. ... *//** Return whether the class represented by this metaclass instance is an instance of the GroovyObject class ... */Set<CachedClass> interfacesList<CachedClass> superClassesgetSuperClasses(...)CachedClass firstGroovySupercalcFirstGroovySuperClass(...)CachedClass cCachedMethod mpopulateMethods(...)inheritInterfaceNewMetaMethods(...)copyMethodsToSuper(...)connectMultimethods(...)removeMultimethodsOverloadedWithPrivateMethods(...)replaceWithMOPCalls(...)theCachedClass.mopMethodsHeader headerIterator<CachedClass> iterHeader lastCachedMethod metaMethodaddToAllMethodsIfPublic(...)copyNonPrivateMethods(...)GroovyParser.ORvisitLogicalOrExprAlt(...)LinkedList<CachedClass> superClassesnew LinkedList<CachedClass>(...)isInterface(...)ReflectionCache.OBJECT_CLASSExpressionContext con;ExpressionContext tb;addFirst(...)ExpressionContext fb;theCachedClass.isArraygetComponentType(...)ReflectionCache.OBJECT_ARRAY_CLASSMethodIndexAction mianew MethodIndexAction(...) { ... }MetaClassImpl$1GroovyParser.ELVISMetaMethodIndex.Entryboolean hasPrivatee.methodsForSupere.methodsFastArray methodsint lenObject[] datagetArray(...)visitConditionalExprAlt(...)iterate(...)MetaClassImpl$1MOPIterMOPIter iternew MOPIter(...)boolean useThis;Object arrayOrMethodint matchedMethodmopArrayIndex(...)isDGM(...)int nint distancegetSuperClassDistance(...)mopMethods.length... ^ ...getMopName(...)...-=...CachedClass.CachedMethodComparatorWithString.INSTANCECachedClass.CachedMethodComparatorWithStringCachedClass[] params1CachedClass[] params2equal(...)iter.useThisMethod[] theClassMethodsCachedClass faceboolean skipString generatedMethodNameCachedClass[] generatedMethodParameterTypesMethod mListIterator<CachedClass> iterhasPrevious(...)VariableNamesContext left;StatementExpressionContext right;previous(...)Header methodIndexcopyNonPrivateNonNewMetaMethods(...)VariableNamesContext.classCachedClass firstGroovyvisitMultipleAssignmentExprAlt(...)theCachedClass.isInterface/** Gets all instance methods available on this class for the given name ... */Entry entryFastArray.EMPTY_LISTentry.methodsForSuperentry.methodsList<CategoryMethod> usedgetCategoryMethods(...)CategoryMethod cmfilterMatchingMethodForCategory(...)/** Returns all the normal static methods on this class for the given name ... */entry.staticMethods/** Returns whether this MetaClassImpl has been modified. Since MetaClassImpl ... *//** Adds an instance method to this metaclass. ... */CachedMethod cachedMethodNewInstanceMetaMethod newMethodnew NewInstanceMetaMethod(...)addNewInstanceMethodToIndex(...)/** Adds a static method to this metaclass. ... */NewStaticMetaMethod newMethodnew NewStaticMetaMethod(...)addNewStaticMethodToIndex(...)/** Invoke a method on the given object with the given arguments. ... */EnhancedStatementExpressionContext right;GroovyParser.ADD_ASSIGNGroovyParser.SUB_ASSIGNGroovyParser.MUL_ASSIGNGroovyParser.DIV_ASSIGNGroovyParser.AND_ASSIGNGroovyParser.OR_ASSIGNGroovyParser.XOR_ASSIGNGroovyParser.RSHIFT_ASSIGNGroovyParser.URSHIFT_ASSIGNGroovyParser.LSHIFT_ASSIGNGroovyParser.MOD_ASSIGNGroovyParser.POWER_ASSIGNGroovyParser.ELVIS_ASSIGNvisitAssignmentExprAlt(...)/** Invoke a missing method on the given object with the given arguments. ... *//** Invoke a missing property on the given object with the given arguments. ... */Class<?> theClassClass<?>[] getPropertyArgsnew Class<?>[]findMethodInClassHierarchy(...)onGetPropertyFoundInHierarchy(...)Class<?>[] setPropertyArgsonSetPropertyFoundInHierarchy(...)InvokerInvocationException iieboolean shouldHandleClass<>.classnew MissingPropertyExceptionNoStack(...)Class<?> instanceKlazzClass<?>[] argClassesClass<?>[] invokeMethodArgsonMixinMethodFound(...)ParserRuleContext _parentctxint _parentStateExpressionContext _localctxnew ExpressionContext(...)ExpressionContext _prevctxint _startStateenterRecursionRule(...)onSuperMethodFoundInHierarchy(...)onInvokeMethodFoundInHierarchy(...)new CastExprAltContext(...)hasCategoryInCurrentThread(...)castParExpression(...)getCategoryMethodMissing(...)castOperandExpression(...)new PostfixExprAltContext(...)postfixExpression(...)new SwitchExprAltContext(...)switchExpression(...)new UnaryNotExprAltContext(...)new MissingMethodExecutionFailed(...)getArguments(...)new MissingMethodExceptionNoStack(...)new UnaryAddExprAltContext(...)(...).op/** Hook to deal with the case of MissingProperty for static properties. The method will look attempt to look up ... */MetaClass mcMetaMethod propertyMissingnew MultipleAssignmentExprAltContext(...)(...).leftvariableNames(...)/** Invokes a method on the given receiver for the specified arguments. ... */(...).rightMethodClosure mcObject ownertriggerExitRuleEvent(...)new PowerExprAltContext(...)pushNewRecursionContext(...)precpred(...)boolean ownerIsClassClass<> ownerClassMetaClass ownerMetaClassnew MultiplicativeExprAltContext(...)new AdditiveExprAltContext(...)RuntimeException eObject newReceiverObject[] newArgumentscopyOfRange(...)MethodClosure.NEWint arrayDimensiondimension(...)int[] sizeArrayClass<> arrayTypenew ShiftExprAltContext(...)elementType(...)getCanonicalName(...)sizeArray.lengthObject argumentparseInt(...)(...).dlOpMissingMethodExceptionNoStack nope(...).tgOp(...).dgOpMethodClosure.ANY_INSTANCE_METHOD_EXISTS(...).rangeOp/** Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object. ... */doInvokeMethod(...)MethodHandles.LookupLookup lookupClass<?> receiverClassboolean spyFoundLookup theLookupMethodHandle methodHandlefindMethod(...)new Function<Method,MethodHandle>(...) { ... }new RelationalExprAltContext(...)unreflectSpecial(...)unreflect(...)orElseThrow(...)lookup(...)new EqualityExprAltContext(...)new Supplier<MissingMethodException>(...) { ... }invokeWithArguments(...)bindTo(...)new RegexExprAltContext(...)new AndExprAltContext(...)invokeExact(...)MethodHandleHolder.CLONE_ARRAY_METHOD_HANDLEin(...)IllegalArgumentException eClass<ArrayUtil> arrayUtilClassArrayUtil.classMethod cloneArrayMethodnew ExclusiveOrExprAltContext(...)new InclusiveOrExprAltContext(...)new LogicalAndExprAltContext(...)new LogicalOrExprAltContext(...)MethodHandle CLONE_ARRAY_METHOD_HANDLE;ClassValue<Map<String,Set<Method>>> SPECIAL_METHODS_MAP;Map<String,Set<Method>> mapSet<Method> methodsparameterTypeMatches(...)new ConditionalExprAltContext(...)(...).conClass<?> cList<Method> declaredMethodsgetDeclaredMethods(...)(...).tb(...).fbisAbstract(...)new AssignmentExprAltContext(...)new Function<String,Set<Method>>(...) { ... }newSetFromMap(...)new ConcurrentHashMap<K,V>(...)unrollRecursionContexts(...)ExpressionContext expression;EnhancedArgumentListInParContext.classCommandArgumentContext.classvisitCommandExpression(...)Object[] argumentsboolean isClosurenew NullPointerException(...)Closure<> closureboolean isClosureNotOwnerint resolveStrategyClass<> objectClassMethodClosure.classinvokeMethodClosure(...)CurriedClosure<>.classCurriedClosure<> ccObject[] curriedArgumentsgetUncurriedArguments(...)Tuple2<Object,MetaMethod> tuplegetV1(...)CommandExpressionContext _localctxnew CommandExpressionContext(...)_localctx.expressionisFollowingArgumentsOrClosure(...)argumentList(...)Tuple2<Object,MetaMethod> tObject rClosure<>.TO_SELFcommandArgument(...)MetaClass delegateMetaClasslookupObjectMetaClass(...)PrimaryContext.classinvokeMethodOnGroovyObject(...)Closure<>.OWNER_ONLYInvokeMethodResult.NONEPathElementContext.classMissingMethodException lastvisitCommandArgument(...)MetaMethod transformedMetaMethodtransformMetaMethod(...)invokePropertyOrMissing(...)getMethodWithCaching(...)tryListParamMetaMethod(...)createTransformMetaMethod(...)new TransformMetaMethod(...) { ... }MetaClassImpl$3Object firstArgumentList<> list/** Tries to find a callable property and make the call. */Object valuegetBinding(...)Closure<?> closureCommandArgumentContext _localctxnew CommandArgumentContext(...)commandPrimary(...)pathElement(...)GroovyObject goPathElementContext pathElement;Entry evisitPathExpression(...)getSuperMethodWithCaching(...)getNormalMethodWithCaching(...)params.lengthObject arg// This method should be called by CallSite onlyMetaMethodIndex.CacheEntryCacheEntry cacheEntrye.cachedMethodsameClasses(...)cacheEntry.paramscacheEntry.methodnew CacheEntry(...)chooseMethod(...)e.namee.cachedMethodForSuperClass<?>[] typesCachedConstructor constructorgetCachedConstructor(...)e.cachedStaticMethode.staticMethodsObject methodsClass<> senderretrieveStaticMethod(...)Object propObject[] originalArgumentsClass<> superClassMissingPropertyException mpeinvokeStaticClosureProperty(...)PathExpressionContext _localctxnew PathExpressionContext(...)MetaClass propMCinvokeStaticMissingMethod(...)primary(...)MethodSelectionException msegetStaticMethods(...)_localctx.pathElement_localctx.pathElement.tMetaClass classMetaClassGroovyParser.NEWCreatorContext.classNamePartContext.classselectConstructorAndTransformArguments1(...)selectConstructorAndTransformArguments0(...)ClosureOrLambdaExpressionContext.classcreateCachedConstructor(...)GroovyParser.METHOD_POINTERList<> lnew ArrayList<>(...)GroovyParser.METHOD_REFERENCEGroovyParser.SPREAD_DOTGroovyParser.SAFE_DOTGroovyParser.SAFE_CHAIN_DOTNonWildcardTypeArgumentsContext.classIndexPropertyArgsContext.classNamedPropertyArgsContext.classComparator<> compnew Comparator<>(...) { ... }visitPathElement(...)CachedConstructor c0CachedConstructor c1String descriptor0getMethodDescriptor(...)Void.TYPEString descriptor1int foundnew IncompatibleClassChangeError(...)toTypeString(...)/** Constructor selection algorithm for Groovy 2.1.9+. ... */String methodDescriptor/** checks if the initialisation of the class id complete. ... *//** This is a helper class introduced in Groovy 2.1.0, which is used only by ... */CachedConstructor cc;boolean beanConstructor;setParametersTypes(...)this.ccthis.beanConstructordoConstructorInvoke(...)/** This is a helper method added in Groovy 2.1.0, which is used only by indy. ... */Class<>[] argTypesObject resnew MetaConstructor(...)getEnclosingClass(...)retrieveNamedArgCompatibleConstructor(...)copyOf(...)origArgTypes.lengthorigArgs.lengthPathElementContext _localctxnew PathElementContext(...)String prettyOrigArgsreplaceFirst(...)creator(...)Object beansetProperties(...)/** Sets a number of bean properties from the given Map where the keys are ... */Map<>.Entry<>Entry<> entrynonWildcardTypeArguments(...)boolean isStaticTuple2<MetaMethod,MetaProperty> methodAndPropertycreateMetaMethodAndMetaProperty(...)namePart(...)closureOrLambdaExpression(...)isSpecialProperty(...)indexPropertyArgs(...)namedPropertyArgs(...)DynamicMemberNameContext.classgetCategoryMethodGetter(...)visitNamePart(...)MetaMethod addListenerMethodgetAt(...)invokeStaticMissingProperty(...)new MetaProperty(...) { ... }MetaClassImpl$4MetaClassImpl$5new GetBeanMethodMetaProperty(...)new GetMethodMetaProperty(...)MetaClassImpl$6MetaClassImpl$7MetaClassImpl$8MetaClassImpl$9MetaClassImpl$10MetaClassImpl$11NamePartContext _localctxnew NamePartContext(...)/** Object#getClass, Map#isEmpty, GroovyObject#getMetaClass */dynamicMemberName(...)MetaProperty saveddecapitalize(...)ParExpressionContext.classGstringContext.classvisitDynamicMemberName(...)getPropertyCategoryGetterName(...)MetaMethod categoryMethodfindCategoryMethod(...)new Predicate<CachedClass[]>(...) { ... }List<CategoryMethod> categoryMethodsList<CategoryMethod> choicesnew ArrayList<CategoryMethod>(...)CategoryMethod categoryMethodtest(...)getOwnerClass(...)comparingLong(...)DynamicMemberNameContext _localctxnew DynamicMemberNameContext(...)new ToLongFunction<CategoryMethod>(...) { ... }calculateParameterDistance(...)new ParameterTypes(...)new CachedClass[]/** Get all the properties defined for this type ... */Map<String,MetaProperty> propertyMapList<MetaProperty> retparExpression(...)gstring(...)GroovyParser.SAFE_INDEXvisitIndexPropertyArgs(...)Opcodes.ACC_SYNTHETICboolean getterboolean setterMetaMethod getterMetaMethodMetaMethod setterMetaMethodboolean getterAccessiblecanAccessLegally(...)boolean setterAccessibleboolean accessibleCachedMethod cmMetaClassImpl.class/** return null if nothing valid has been found, a MetaMethod (for getter always the case if not null) or ... */Object retint parameterCountClass<?> returnTypeBoolean.TYPEVoid.classMetaMethod elementaddElementToList(...)IndexPropertyArgsContext _localctxnew IndexPropertyArgsContext(...)MapEntryListContext.classvisitNamedPropertyArgs(...)int localDistancedistanceToObject(...)int count/** This will build up the property map (Map of MetaProperty objects, keyed on ... */CachedClass superClassList<CachedClass> superInterfacesnew ArrayList<CachedClass>(...)NamedPropertyArgsContext _localctxnew NamedPropertyArgsContext(...)Map<String,MetaProperty> iPropertyIndexCachedClass sInterfaceMap<String,MetaProperty> sPropertyIndexcopyNonPrivateFields(...)addFields(...)applyPropertyDescriptors(...)applyStrayPropertyMethods(...)LinkedHashMap<String,MetaProperty> mapinheritStaticInterfaceFields(...)inheritFields(...)fillStaticPropertyIndex(...)BiConsumer<String,MetaProperty> indexStaticPropertynew BiConsumer<String,MetaProperty>(...) { ... }namedPropertyArgList(...)CachedField fieldestablishStaticMetaProperty(...)createStaticVersion(...)visitIdentifierPrmrAlt(...)Map<String,MetaProperty> strayPropertiesCachedField staticFieldorElse(...)filter(...)new Predicate<CachedField>(...) { ... }boolean fieldMetaProperty staticPropertyMetaBeanProperty newmpsetField(...)CachedClass iclassLinkedHashMap<String,MetaProperty> iPropertyIndexLinkedHashMap<String,MetaProperty> sPropertyIndexMap<String,MetaProperty> sciCachedClass ccMap<String,MetaProperty> cciEntry<String,MetaProperty> entryMap<>.Entry<String,MetaProperty>inSamePackage(...)/** Looks for any stray getters/setters that may be used to define a property. */header.heade.nextClassEntryint methodNameLengthboolean isBooleanGetterboolean isGetterboolean isSetterObject propertyMethodsLiteralContext.classfilterPropertyMethod(...)String propNamegetPropName(...)createMetaBeanProperty(...)ConcurrentMap<String,String> PROP_NAMES;visitLiteralPrmrAlt(...)new Function<String,String>(...) { ... }CachedField mfpvisitGstringPrmrAlt(...)MultipleSetterProperty mspsetGetter(...)setSetter(...)new MultipleSetterProperty(...)MetaProperty newMpmakeReplacementMetaProperty(...)PropertyDescriptor pdgetReadMethod(...)MetaBeanProperty mpgetPropertyType(...)CachedMethod cachedGettergetWriteMethod(...)CachedMethod cachedSetter/** Adds a new MetaBeanProperty to this MetaClass ... */MetaProperty oldMetaProperty fieldboolean ambiguousListenerMetaProperty fgetPropertyCategorySetterName(...)getCategoryMethodSetter(...)Object proxynewProxyInstance(...)new ConvertedClosure(...)visitNewPrmrAlt(...)boolean mapInstanceCachedClass cachedClassCachedClass clazznew MissingFieldException(...)/** <p>Sets an attribute on the given receiver for the specified arguments. The sender is the class that is setting the attribute from the object. ... */String groovyFileClassgenCallback searchvisitThisPrmrAlt(...)new ClassgenCallback(...) { ... }MetaClassImpl.this.classNodeMetaClassImpl.this/** Returns a string representation of this metaclass *//** adds a MetaMethod to this class. WARNING: this method will not ... */// Implementation methodsCachedClass declaringClassgetOrPutMethods(...)checkIfStdMethod(...)addMethodToList(...)/** Checks if the metaMethod is a method from the GroovyObject interface such as setProperty, getProperty and invokeMethod ... */isGetPropertyMethod(...)isInvokeMethod(...)isSetPropertyMethod(...)isGenericGetMethod(...)isGenericSetMethod(...)CachedClass[] parameterTypesparameterTypes.lengththeCachedClass.isNumberNumberMathModificationInfo.instanceCachedClass[] paramTypes1CachedClass[] paramTypes2paramTypes1.lengthClass<> selfType1Class<> selfType2paramTypes2.lengthBoolean.FALSEBoolean.TRUEint jMetaMethod aMethodBoolean matchgetMatchKindForCategory(...)FastArray mvisitSuperPrmrAlt(...)isMethod(...)/** Chooses the correct method to use from a list of methods which match by ... */Object methodchooseMethodInternal(...)GeneratedMetaMethod.Proxyproxy(...)int methodCountisValidMethod(...)chooseEmptyMethodParams(...)Object matchingMethodsmethods.sizeList<> arrchooseMostSpecificParams(...)new MethodSelectionException(...)doChooseMostSpecificParams(...)long matchesDistanceLinkedList<> matchesParameterTypes parameterTypeslong disthandleMatches(...)getFirst(...)createErrorMessageForAmbiguity(...)StringBuilder msgObject matchCachedClass[] typesreinitialize(...)fillMethodIndex(...)addProperties(...)isRunningAndroid(...)BeanInfo infoPropertyDescriptor[] descriptorsgetPropertyDescriptors(...)EventSetDescriptor[] eventDescriptorsgetEventSetDescriptors(...)isBeanDerivative(...)new PrivilegedExceptionAction<>(...) { ... }getBeanInfo(...)Introspector.IGNORE_ALL_BEANINFOsetupProperties(...)EventSetDescriptor descriptorMethod[] listenerMethodsgetListenerMethods(...)Method listenerMethodgetAddListenerMethod(...)visitParenPrmrAlt(...)Class<> nextBeanInfo.class/** Retrieves the list of MetaMethods held by the class. This list does not include MetaMethods added by groovy.lang.ExpandoMetaClass. ... *//** Retrieves the list of MetaMethods held by this class. This list includes MetaMethods added by groovy.lang.ExpandoMetaClass. ... */clearCaches(...)/** Create a CallSite */getMethodWithCachingInternal(...)createPojoMetaMethodSite(...)createStaticMetaMethodSite(...)CallSite tempSiteGeneratedClosure.classnew AbstractCallSite(...)getIndex(...)createPogoMetaMethodSite(...)visitClosureOrLambdaExpressionPrmrAlt(...)new NoParamSite(...)new NoParamSiteInnerClass(...)ConstructorSite.NoParamSiteConstructorSite.NoParamSiteInnerClassnew MetaClassConstructorSite(...)/** Returns the ClassInfo for the contained Class ... */theCachedClass.classInfo/** Returns version of the contained Class ... *//** Increments version of the contained Class *//** Retrieves a list of additional MetaMethods held by this class ... */getMetaPropertyFromMutableMetaClass(...)searchInterfacesForMetaProperty(...)Class<>[] superInterfacessuperInterfaces.lengthboolean isModifiedboolean checkClassInfo cigetHierarchy(...)(...).theCachedClassMetaClass aClassgetStrongMetaClass(...)MetaClass superMetaClassfindSubClassMethod(...)findOwnMethod(...)MetaMethod infMethodsearchInterfacesForMetaMethod(...)mostSpecific(...)Object listgetSubclassMetaMethods(...)ListContext.classisValidExactMethod(...)visitListPrmrAlt(...)Class<> newMethodCClass<> methodCMetaClass infMetaClassMetaMethod ownMethodEntry<Class<>,Header> classEntryMap<>.Entry<Class<>,Header>metaMethodIndex.methodHeadersskipClass(...)Entry nameEntrynameEntry.nextClassEntrymethodNameAction(...)/** <p>Retrieves a property on the given object for the specified arguments. ... *//** <p>Sets a property on the given object for the specified arguments. ... *//** indicates is the meta class method invocation for non-static methods is done ... *//** indicates is the meta class method invocation for static methods is done ... *//** remove all method call cache entries. This should be done if a ... */SingleKeyHashMap.Copier NAME_INDEX_COPIER;SingleKeyHashMap.CopierSingleKeyHashMap.Copier METHOD_INDEX_COPIER;new MethodIndex(...)Entry resgetOrPut(...)res.valuegetOrPut(...).valueComplexKeyHashMap.Entry(...).keyMapContext.classvisitMapPrmrAlt(...)new InvokeMethodResult(...)InvokeMethodResult NONE;this.permissivePropertyAccess// in reverse order// GROOVY-8164// methods --> methodsForSuper// We have private methods for that name, so remove the// multimethods. That is the same as in our index for// super, so just copy the list from there. It is not// possible to use a pointer here, because the methods// in the index for super are replaced later by MOP// methods like super$5$foo// not fit for super usage// GROOVY-4922: Due to a numbering scheme change, find the super$number$methodName with// the highest value. If we don't, no method may be found, leading to a stack overflow!// include overloads in search// replace all calls for super with the correct MOP method// replace all calls for this with the correct MOP method// add methods declared by DGM for interfaces// skip DGM methods on an interface if the class already has the method// but don't skip for GroovyObject-related methods as it breaks things :-(// below not true for DGM#push and also co-variant return scenarios//&& method.getReturnType().equals(m.getReturnType())// We don't copy DGM methods to superclasses' indexes// The reason we can do that is particular set of DGM methods in use,// if at some point we will define DGM method for some Groovy class or// for a class derived from such, we will need to revise this condition.// It saves us a lot of space and some noticeable time// MetaClassImpl not designed for modification, just return false// look for getProperty or setProperty overrides// still not method here, so see if there is an invokeMethod method up the hierarchy// last resort look in the category// CONSTRUCTOR REFERENCE// Just for better performance, though we can use reduceDimension only// not "new"; maybe it's a reference to a Class method// METHOD REFERENCE// if the owner is a class and the method closure can be related to some instance method(s),// try to invoke method with adjusted arguments -- first argument is instance of owner type;// otherwise re-throw the exception//        final Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);//        unwrap(arguments);// change the arguments for an uncurried call// still no methods found, test if delegate or owner are GroovyObjects// and invoke the method on them if so.// fall through -- "doCall" is not instrisic to Closure// delegate to call method of property value// ignore// allow "super.name()" to find DGM if class declares method "name"// we do here a null check because the params field might not have been set yet//        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);// let's try use the cache to find the method// falling back to pre 2.1.9 selection algorithm// in practice this branch will only be reached if the class calling this code is a Groovy class// compiled with an earlier version of the Groovy compiler//TODO: that is just a quick prototype, not the real thing!// NOTE: must be changed to "1 |" if constructor was vargs// keeping 3 bits for additional information such as vargs// handle named args on class or inner class (one level only for now)// if we get here Map variant already not found so allow for no-arg plus setters// chooseMethod allows fuzzy matching implicit null case but we don't want that here// code here handles inner class case but we currently don't do fuzzy matching for inner classes//----------------------------------------------------------------------// handling of static// getter//------------------------------------------------------------------// public field// can't access the field directly but there may be a getter// java.util.Map get method// non-public field// propertyMissing (via category) or generic get method// check for propertyMissing provided through a category; TODO:should this have lower precedence?// check for a generic get method provided through a category// special cases// TODO: maybe these special cases should be special MetaClasses// TODO: one day we could try return the previously registered Closure listener for easy removal// executing the method// missing property protocol// generic get method// error due to missing method/field// GROOVY-9618 adjust because capitalised properties aren't stored as meta bean props// restore if we didn't find something better// check for a category method named like a getter// GROOVY-5453, GROOVY-10214: order by self-type distance// GROOVY-6903: May happen in some special environment, like Android, due to class-loading issues// simply return the values of the metaproperty map as a List// filter out extrinsic properties (DGM, ...)//  TODO: I (ait) don't know why these strange tricks needed and comment following as it effects some Grails tests//                if (!setter && mbp.getSetter() != null) {//                    mp = new MetaBeanProperty(mbp.getName(), mbp.getType(), mbp.getGetter(), null);//                }//                if (!getter && mbp.getGetter() != null) {//                    mp = new MetaBeanProperty(mbp.getName(), mbp.getType(), null, mbp.getSetter());// Method has been optimized to reach a target of 325 bytecode size, making it JIT'able//&& returnType == Void.TYPEBuiltInTypeContext.class// we found multiple matching methods// this is a problem, because we can use only one// if it is a getter, then use the most general return// type to decide which method to use. If it is a setter// we use the type of the first parameter//TODO: maybe implement the case localDistance==distance// always includes interface theCachedClass// sort interfaces so that we may ensure a deterministic behaviour in case of// ambiguous fields -- class implementing two interfaces using the same field// add the special read-only "length" property// ignore all other types// GROOVY-10592: static interface accessors// mbp has static field, null or static getter and null or static setter// GROOVY-9608, GROOVY-9609: add public, protected, and package-private fields to index for super// assume "is" or "[gs]et"//isSetter// GROOVY-10133: do not replace "isPropName()" with "getPropName()" or ...// is this property already accounted for?// now iterate over the map of property descriptors and generate// MetaBeanProperty objects// skip if the property type is unknown (this seems to be the case if thevisitBuiltInTypePrmrAlt(...)// property descriptor is based on a setX() method that has two parameters,// which is not a valid property)// get the getter method// get the setter method// now create the MetaProperty object// remember field// put it in the list// this will overwrite a possible field property// Unwrap wrapped values fo now - the new MOP will handle them properly// setter// check for a category method named like a setter// listener method// let's create a dynamic proxy// field// GROOVY-8065// GROOVY-5985// generic set method// java.util.Map put method// delegate the get operation to the metaproperty// let's try load it from the classpath//System.out.println("Attempting to load: " + groovyFile);/* todo there is no CompileUnit in scope so class name ... */// replace if self type is the same or the category self type is more specific// GROOVY-6363: replace if the private method self type is more specific// true == replace// null == ignore (we have a better method already)// the casese true and null for a match are through, the// remaining case is false and that means adding the method// to our list//                    TODO: should be better check for case when only diff in modifiers can be SYNTHETIC flag//                    && method.getModifiers() == aMethod.getModifiers()// making this false helps find matches//more than one matching method found --> ambiguous!// Introspection failure...// May happen in Android//     introspect// build up the metaproperties based on the public fields, property descriptors,// and the getters and setters// GROOVY-5202// there might be a non public listener of some kind// we skip that here// here, we want to point to a method named "doCall" instead of "call"// but we don't want to replace the original call site name, otherwise// we loose the fact that the original method name was "call" so instead// we will point to a metamethod called "doCall"// see GROOVY-5806 for details// we trick ourselves hereimport ClosureMetaClass/** A MetaClassRegistry is an object that is responsible for managing the a cache of MetaClass instances. Each ... *//** The main function of the registry ... *//** Adds a metaclass to the registry for the given class ... *//** Removes a cached MetaClass from the registry ... *//** Retrieves the MetaClassCreationHandle that is responsible for constructing MetaClass instances ... *//** Sets the MetaClassCreationHandle instance that is responsible for constructing instances ... *//** Adds a meta class change listener for constant meta classes ... *//** Adds a meta class change listener for constant meta classes. ... *//** Removes a meta class change listener for constant meta classes ... *//** Returns all registered class change listener for constant meta classes. ... *//** Gets a snapshot of the current constant meta classes and returns it as Iterator. ... *//** Class used as base for the creation of MetaClass implementations. ... */boolean disableCustomMetaClassLookup;/** Creates a metaclass implementation for theClass. ... */PrimaryContext _localctxnew PrimaryContext(...)createWithCustomLookup(...)Class<> customMetaClassnew IdentifierPrmrAltContext(...)new LiteralPrmrAltContext(...)literal(...)new GstringPrmrAltContext(...)new NewPrmrAltContext(...)new ThisPrmrAltContext(...)new SuperPrmrAltContext(...)new ParenPrmrAltContext(...)new ClosureOrLambdaExpressionPrmrAltContext(...)new ListPrmrAltContext(...)list(...)new MapPrmrAltContext(...)map(...)new BuiltInTypePrmrAltContext(...)builtInType(...)DelegatingMetaClass.classConstructor<> customMetaClassConstructorMetaClass.classMetaClass normalMetaClassMetaClassRegistry.classClassNotFoundException evisitList(...)new ClosureMetaClass(...)new MetaClassImpl(...)/** Returns whether custom meta classes are disabled. *//** Set flag saying to disable lookup of custom meta classes ... */this.disableCustomMetaClassLookupimport EventObject/** An event used to propagate meta class updates */Class<> clazz;Object instance;MetaClass oldMetaClass;/** Constructs a new MetaClassRegistryChangeEvent Object ... */this.clazzthis.oldMetaClassthis.instance/** Get the class that is updated. ... *//** Get the new MetaClass ... *//** Get the old MetaClass ... *//** Determines if this event is for a change for a single instance or all instances of the Class. ... *//** Returns the instance this event is for. ... *//** Get the MetaClassRegistry that originates this change ... */ListContext _localctxnew ListContext(...)import EventListener/** A listener called whenever a constant MetaClass is set, removed or replaced. ... *//** Called when the a constant MetaClass is updated. If the new MetaClass is null, then the MetaClass ... */visitMap(...)import Entry/** Represents a property in an Expando object */Object value;/** Represents a Method on a Java object a little like {@link java.lang.reflect.Method} ... */new MetaMethod[]...[] EMPTY_ARRAY;String signature;String mopName;/** Constructor for a metamethod with an empty parameter list *//** Constructor wit a list of parameter classes ... *//** Returns the modifiers for this method ... *//** Returns the name of the method represented by this class ... *//** Access the return type for this method ... *//** Gets the class where this method is declared ... *//** Invoke this method ... *//** Checks that the given parameters are valid to call this method ... *//** Returns true if this this metamethod represents the same method as the argument. ... */a.lengthb.length/** Returns a string representation of this method *//** Returns whether or not this method is static. ... */Modifier.STATIC/** Returns whether or not this method is abstract. ... */Modifier.ABSTRACT/** Returns whether or not this method is interface-default. ... */getDeclaringClass(...).isInterfaceMapContext _localctxnew MapContext(...)/** Returns whether or not this method is private. ... *//** Returns whether or not this method is protected. ... *//** Returns whether or not this method is public. ... */compatibleModifiers(...)/** Checks the compatibility between two modifier masks. Checks that they are equal ... */int mask/** Returns whether this object is cacheable *//** Return a descriptor of this method based on the return type and parameters of this method. *//** Returns the signature of this method ... */CachedClass[] parametersStringBuilder bufparameters.lengthmapEntryList(...)MapEntryContext.classvisitMapEntryList(...)/** This method is called when an exception occurs while invoking this method. */createExceptionText(...)/** Invokes the method this object represents. This method is not final but it should be overloaded very carefully and only by generated methods ... */coerceArgumentsToClasses(...)processDoMethodInvokeException(...)// lets check that the argument types are valid//        if (e instanceof IllegalArgumentException) {//            //TODO: test if this is OK with new MOP, should be changed!//            // we don't want the exception being unwrapped if it is a IllegalArgumentException//            // but in the case it is for example a IllegalThreadStateException, we want the unwrapping//            // from the runtime//            //Note: the reason we want unwrapping sometimes and sometimes not is that the method//            // invocation tries to invoke the method with and then reacts with type transformation//            // if the invocation failed here. This is OK for IllegalArgumentException, but it is//            // possible that a Reflector will be used to execute the call and then an Exception from inside//            // the method is not wrapped in a InvocationTargetException and we will end here.//            boolean setReason = e.getClass() != IllegalArgumentException.class || this instanceof org.codehaus.groovy.reflection.GeneratedMetaMethod;//            return MetaClassHelper.createExceptionText("failed to invoke method: ", this, object, argumentArray, e, setReason);//        }MapEntryListContext _localctxnew MapEntryListContext(...)/** <p>An interface that defines the API usable by clients of Groovy's Meta Object Protocol (MOP). These methods are ... */mapEntry(...)/** Obtain a list of all meta properties available on this meta class ... *//** Obtain a list of all the meta methods available on this meta class ... *//** <p>Returns an object satisfying Groovy truth if the implementing MetaClass responds to ... *//** <p>Returns true of the implementing MetaClass has a property of the given name ... *//** Returns a MetaProperty for the given name or null if it doesn't exist ... *//** Retrieves a static MetaMethod for the given name and argument values, using the types of the arguments ... *//** Retrieves an instance MetaMethod for the given name and argument values, using the types of the ... *//** Retrieves that Java Class that the attached Meta behaviours apply to ... *//** Invokes a constructor for the given arguments. The MetaClass will attempt to pick the best argument which ... *//** Invokes a method on the given Object with the given name and arguments. The MetaClass will attempt to pick ... *//** Invokes a method on the given object, with the given name and single argument. ... *//** Invokes a static method on the given Object with the given name and arguments. ... *//** Retrieves a property of an instance of the class returned by the getTheClass() method. ... *//** Sets a property of an instance of the class returned by the getTheClass() method. ... *//** Retrieves an attribute of an instance of the class returned by the getTheClass() method. ... *//** Sets an attribute of an instance of the class returned by the getTheClass() method. ... */namedPropertyArg(...)MapEntryLabelContext.classvisitMapEntry(...)import static BeanUtils.capitalizeString PROPERTY_SET_PREFIX;Class<> type;/** Constructor that sets the property name and type (class) */this.type/** Return the name of the property ... *//** Returns the access modifier. ... *//** Gets the name for the getter for this property ... */String prefixcapitalize(...)/** Gets the setter for the getter for this property. ... *//** An exception occurred if a dynamic method dispatch fails with an unknown class. ... */String type;MapEntryContext _localctxnew MapEntryContext(...)/** An exception occurred if a dynamic field dispatch fails with an unknown field. ... */String field;mapEntryLabel(...)namedPropertyArgLabel(...)namedArgLabel(...)import MethodRankHelper/** An exception occurred if a dynamic method dispatch fails with an unknown method. ... */String method;Class<?> type;...[] arguments;visitMapEntryLabel(...)this.methodtoArrayString(...)getMethodSuggestionString(...)MapEntryLabelContext _localctxnew MapEntryLabelContext(...)/** An exception occurred if a dynamic property dispatch fails with an unknown property. ... */new Object(...)Object MPE;String property;this.propertynamedPropertyArgPrimary(...)getPropertySuggestionString(...)namedArgPrimary(...)CreatedNameContext.classDimContext.classArrayInitializerContext.classvisitCreator(...)/** Provides a mechanism for mixing in methods into a class. ... *//** An interface that defines methods that implementers of mutable Meta classes should specify. It provides operations to perform mutations ... *//** Return whether the MetaClass has been modified or not ... *//** adds a new instance method to this MetaClass. Instance ... *//** adds a new static method to this MetaClass. This is only ... *//** Adds a new MetaMethod to the MetaClass ... *//** Adds a new MetaBeanProperty to the MetaClass ... */// TODO: Add methods like addMetaConstructor, addMetaAttribute, addMetaAnnotation etc.CreatorContext _localctxnew CreatorContext(...)createdName(...)dim(...)import IncubatingarrayInitializer(...)/** Represents a value with name ... */T val;this.valNamedValue<?> thatvisitDim(...)that.namethat.valformat(...)/** Annotation that supports writing constructor call expressions without the 'new' ... *//** @since ... *//** Represents a sequence of one or more objects of a given type. ... */DimContext _localctxnew DimContext(...)VariableInitializersContext.classvisitArrayInitializer(...)ArrayInitializerContext _localctxnew ArrayInitializerContext(...)variableInitializers(...)visitAnonymousInnerClassDeclaration(...)AnonymousInnerClassDeclarationContext _localctxnew AnonymousInnerClassDeclarationContext(...)TypeArgumentsOrDiamondContext.classvisitCreatedName(...)import NumberMathimport BigDecimalimport RoundingModeimport static ScriptBytecodeAdapter.compareEqualimport static ScriptBytecodeAdapter.compareGreaterThanimport static ScriptBytecodeAdapter.compareGreaterThanEqualimport static ScriptBytecodeAdapter.compareLessThanimport static ScriptBytecodeAdapter.compareLessThanEqualimport static ScriptBytecodeAdapter.compareNotEqualimport static ScriptBytecodeAdapter.compareToimport static NumberNumberMinus.minusimport static NumberNumberMultiply.multiplyimport static NumberNumberPlus.plus/** Represents an immutable list of Numbers from a value to a value with a particular step size. ... */CreatedNameContext _localctxnew CreatedNameContext(...)Comparable<> from;/** The first value in the range. */Comparable<> to;/** The last value in the range. */Number stepSize;/** The step size in the range. *//** The cached size, or -1 if not yet computed */Integer hashCodeCache;/** The cached hashCode (once calculated) *//** <code>true</code> if the range counts backwards from <code>to</code> to <code>from</code>. */boolean inclusiveLeft;/** <code>true</code> if the range includes the lower bound. */boolean inclusiveRight;/** <code>true</code> if the range includes the upper bound. *//** Creates an inclusive {@link NumberRange} with step size 1. ... *//** Creates a new {@link NumberRange} with step size 1. ... */typeArgumentsOrDiamond(...)/** Creates an inclusive {@link NumberRange}. ... *//** Creates a {@link NumberRange}. ... */visitNonWildcardTypeArguments(...)Number tempFromNumber tempToareReversed(...)doubleValue(...)longValue(...)this.stepSize/** For a NumberRange with step size 1, creates a new NumberRange with the same ... */comparableNumber(...)compareGreaterThan(...)ClassCastException cceNonWildcardTypeArgumentsContext _localctxnew NonWildcardTypeArgumentsContext(...)visitTypeArgumentsOrDiamond(...)/** An object is deemed equal to this NumberRange if it represents a List of items and ... */TypeArgumentsOrDiamondContext _localctxnew TypeArgumentsOrDiamondContext(...)visitArguments(...)ArgumentsContext _localctxnew ArgumentsContext(...)enhancedArgumentListInPar(...)EnhancedArgumentListInParContext _localctxnew EnhancedArgumentListInParContext(...)firstArgumentListElement(...)argumentListElement(...)EnhancedArgumentListElementContext.classvisitEnhancedArgumentListInPar(...)enhancedArgumentListElement(...)EnhancedArgumentListElementContext _localctxnew EnhancedArgumentListElementContext(...)namedArg(...)visitEnhancedArgumentListElement(...)/** A NumberRange's hashCode is based on hashCode values of the discrete items it represents. ... *//** Compares a {@link NumberRange} to another {@link NumberRange} using only a strict comparison ... *///    }//        return canonicalHashCodeCache;//            canonicalHashCodeCache = hashCode;//            }//                hashCode = 31 * hashCode + value;//                    }//                        value = next.stripTrailingZeros().hashCode();//                    } else {//                        value = BigDecimal.ZERO.hashCode();//                        // workaround on pre-Java8 for http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6480539//                    if (next.compareTo(BigDecimal.ZERO) == 0) {//                    BigDecimal next = new BigDecimal(e.toString());//                } else {//                    value = 0;//                if (e == null) {//                int value;//            for (Comparable e : this) {//            int hashCode = 1;//        if (canonicalHashCodeCache == null) {//    public int canonicalHashCode() {/* A NumberRange's canonicalHashCode is based on hashCode values of the discrete items it represents. ... *///    private Integer canonicalHashCodeCache = null;/* The cached canonical hashCode (once calculated) *//* NOTE: as per the class javadoc, this class doesn't obey the normal equals/hashCode contract. ... */compareEqual(...)GroovyParser.StringLiteralthat.stepSize//        return fastHashCodeCache;//            fastHashCodeCache = result;//            result = result * 31 + new BigDecimal(stepSize.toString()).stripTrailingZeros().hashCode();//            result = result * 31 + new BigDecimal(to.toString()).stripTrailingZeros().hashCode();//            result = result * 31 + new BigDecimal(from.toString()).stripTrailingZeros().hashCode();//            result = result * 31 + (inclusive ? 1 : 0);//            result = result * 31 + (reverse ? 1 : 0);//            int result = 17;//        if (fastHashCodeCache == null) {//    public int fastHashCode() {/* A hashCode function that pairs with fastEquals, following the normal equals/hashCode contract. ... *///    private Integer fastHashCodeCache = null;/* The cached fast hashCode (once calculated) */visitStringLiteral(...)Iterator<Comparable<>> iternew StepIterator(...)Comparable<> value/** Checks whether a value is between the from and to values of a Range ... *//** protection against calls from Groovy */calcSize(...)int tempsizeboolean shortcutisIntegral(...)BigInteger fromTempnew BigInteger(...)BigInteger fromNumBigInteger.ONEBigInteger toTempBigInteger toNumsubtract(...)BigInteger sizeNumtoBigInteger(...)divide(...)new BigDecimal(...)RoundingMode.DOWNBigDecimal fromTemptoBigDecimal(...)BigDecimal fromNumBigDecimal.ONEBigDecimal toTempBigDecimal toNumBigDecimal tempStepSizeComparable<> fromValueComparable<> toValuenew EmptyRange<Comparable<>>(...)getToString(...)String sepLeftString sepString base/** iterates over all values and returns true if one value matches. ... */StepIterator itermultiply(...)/** convenience class to serve in other methods. ... */NumberRange range;Number step;boolean isAscending;boolean isNextFetched;Comparable<> next;compareNotEqual(...)this.rangecompareLessThan(...)this.stepfetchNextIfNeeded(...)range.inclusiveRightcompareLessThanEqual(...)compareGreaterThanEqual(...)range.inclusiveLeftincrement(...)decrement(...)IteratorClosureAdapter<Comparable<>> adapternew IteratorClosureAdapter<Comparable<>>(...)/** Increments by given step ... *//** Decrements by given step ... */minus(...)StringLiteralContext _localctxnew StringLiteralContext(...)GroovyParser.CapitalizedIdentifiervisitClassName(...)/* package private */// let's fast calculate the size// let's brute-force calculate the size by iterating start to end// integer overflow// Performance detail:// not using get(fromIndex), get(toIndex) in the following to avoid stepping over elements twice// make the first fetch lazy tooClassNameContext _localctxnew ClassNameContext(...)import ScriptBytecodeAdapterGroovyParser.Identifier/** Represents an inclusive list of objects from a value to a value using ... *//** Creates a new {@link ObjectRange}. Creates a reversed range if ... *//** Creates a new {@link ObjectRange} assumes smaller &lt;&#61; larger, else behavior is undefined. ... *//** Constructs a Range, computing reverse if not provided. When providing reverse, ... */boolean computedReversevisitIdentifier(...)Comparable<> tempComparable<> tempfromnormaliseStringType(...)Comparable<> temptoComparable<> startcheckBoundaryCompatibility(...)/** throws IllegalArgumentException if to and from are incompatible, meaning they e.g. (likely) produce infinite sequences. ... */String startString endint lengthIllegalArgumentException iaeIdentifierContext _localctxnew IdentifierContext(...)visitBuiltInType(...)/** Compares an {@link ObjectRange} to another {@link ObjectRange}. ... */numberAwareCompareTo(...)char fromNumchar toNumBuiltInTypeContext _localctxnew BuiltInTypeContext(...)GroovyParser.CONSTGroovyParser.GOTOnew ObjectRange(...)String toTextString fromText/** Iterates over all values and returns true if one value matches. ... */GroovyParser.THREADSAFEvisitKeywords(...)/** Non-thread-safe iterator which lazily produces the next element only on calls of hasNext() or next() */int step;// actual step, can be +1 when desired step is -1 and direction is from high to lowObjectRange range;Comparable<> value;boolean nextFetched;Comparable<> peekValuerange.fromrange.toint positiveStep/** Increments by one ... *//** Decrements by one ... *//** if operand is a Character or a String with one character, return that character's int value. */String string// ensure invariant from <= to/* areReversed() already does an implicit type compatibility check ... */// Convenience hack: try convert single-char strings to ints// if after normalizing both are numbers, assume intended range was numbers// if convenience hack did not make classes match,// throw exception when starting with known class, and thus "from" cannot be advanced over "to".// Note if start is an unusual Object, it could have a next() method// that yields a Number or String to close the range// starting with number will never reach a non-number, same for string// Since normalizing did not help, use original values at user's risk// this test depends deeply on the String.next implementation// 009.next is 00:, not 010// strings must be equal except for the last character// non thread-safe iterator// not thread safe// handle back to beginning due to modulo incrementing// handle back to beginning due to modulo decrementingKeywordsContext _localctxnew KeywordsContext(...)/** <p>An interface that adds the ability to intercept ... *//** Intercepts a getXXX call and returns a result. The result is replaced by the ... *//** Intercepts a setXXX call ... */Object bean;// the owner of the propertyMetaProperty mp;// the description of the propertythis.beanthis.mpGroovyParser.RPARENvisitRparen(...)import Supplier/** As subclass of MetaClass, ProxyMetaClass manages calls from Groovy Objects to POJOs. ... */MetaClass adaptee;Interceptor interceptor;/** convenience factory method for the most usual case. */MetaClassRegistry metaRegistryMetaClass metanew ProxyMetaClass(...)this.adapteerequireNonNull(...)this.interceptor/** Use the ProxyMetaClass for the given Closure. ... */MetaClass origMetaClass/** Call invokeMethod on adaptee with logic like in MetaClass unless we have an Interceptor. ... */doCall(...)new Supplier<Object>(...) { ... }/** Call invokeStaticMethod on adaptee with logic like in MetaClass unless we have an Interceptor. ... *//** Call invokeConstructor on adaptee with logic like in MetaClass unless we have an Interceptor. ... *//** Interceptors the call to getProperty if a PropertyAccessInterceptor is ... */PropertyAccessInterceptor paebeforeGet(...)doInvoke(...)RparenContext _localctxnew RparenContext(...)/** Interceptors the call to a property setter if a PropertyAccessInterceptor ... */beforeSet(...)beforeInvoke(...)afterInvoke(...)visitNls(...)// grab existing meta (usually adaptee but we may have nested use calls)/** A Range represents the list of discrete items between some starting (or <code>from</code>) ... *//** The lower value in the range. ... *//** The upper value in the range. ... *//** Indicates whether this is a reverse range which iterates backwards ... *//** Indicates whether an object is greater than or equal to the <code>from</code> ... *//** Steps through the range, calling a closure for each item. ... *//** Forms a list by stepping through the range by the indicated interval. ... */NlsContext _localctxnew NlsContext(...)visitSep(...)/** This exception is thrown if an attempt is made to set a read only property */SepContext _localctxnew SepContext(...)scriptStatement_sempred(...)classBody_sempred(...)localVariableDeclaration_sempred(...)statement_sempred(...)expression_sempred(...)commandExpression_sempred(...)pathExpression_sempred(...)import ArgumentListExpressionimport GeneralUtils/** This object represents a Groovy script */Binding binding;this.binding/** Represents a reference to a value */T value;setBinding(...)this.valuehasSetterMethodFor(...)hasVariable(...)getSetterName(...)/** Represents a sequence of zero or more objects of a given type. ... */int hashCode;getParameterCount(...)/** Invoke a method (or closure in the binding) defined. ... */Object boundClosure/** Sets the contents of this sequence to that ... */checkCollectionType(...)/** The main instance method of a script which has variables in scope ... *//** Prints a newline to the current 'out' variable which should be a PrintWriter ... */// println helper methodsObject objectArgumentListExpression.EMPTY_ARRAY/** Prints the value to the current 'out' variable which should be a PrintWriter ... *//** Prints the value and a newline to the current 'out' variable which should be a PrintWriter ... *//** Prints a formatted string using the specified format string and argument. ... */printf(...)/** Prints a formatted string using the specified format string and arguments. ... *//** A helper method to allow the dynamic evaluation of groovy expressions using this ... */GroovyShell shellint hash...^=...checkType(...)removeRange(...)//-------------------------------------------------------------------------// GroovyObject interfaceList<> answerObject element/** A helper method to allow scripts to be run taking command line arguments *//** Checks that each member of the given collection are of the correct ... *//** Checks that the given object instance is of the correct type ... */// GROOVY-9554: @Field adds setter// TODO: Test modifiers or return type?// if the method was not found in the current scope (the script's methods)// let's try to see if there's a method closure with the same name in the binding/** Class annotation to make a singleton class. The singleton is obtained through normal property access using the singleton property (defaults to "instance"). ... */// let's apply the method to each item in the collection/** Helper to turn a list with an even number of elements into a Map. *//** An IO exception occurred trying to append to a StringWriter which should never happen. *//* This {@link Interceptor} traces method calls on the proxied object to a log. ... */new PrintWriter(...)Writer writer;int indent;/** Returns the writer associated with this interceptor. *//** Changes the writer associated with this interceptor. */this.writerindent(...)writeInfo(...)printStackTrace(...)String argumentTypescollect(...)Object eObject keyjoining(...)of(...)new Function<Object,String>(...) { ... }/** A TrampolineClosure wraps a closure that needs to be executed on a functional trampoline. ... */Closure<V> original;this.original/** Delegates to the wrapped closure */original.maximumNumberOfParametersoriginal.parameterTypes/** Starts the trampoline loop and calls the wrapped closure as the first step. ... */loop(...)(...).originalnew TrampolineClosure(...)/** Returns itself, since it is a good enough trampolined variant of the current closure. ... */// GROOVY-10009/** Represents a list of 0 typed Object. ... */new Tuple0(...)Tuple0 INSTANCE;/** Represents a list of 1 typed Object. ... */T1 v1;this.v1tuple.v1new Tuple1(...)/** Represents a list of 10 typed Objects. ... */T2 v2;T3 v3;T4 v4;T5 v5;T6 v6;T7 v7;T8 v8;T9 v9;T10 v10;this.v2this.v3this.v4this.v5this.v6this.v7this.v8this.v9this.v10tuple.v2tuple.v3tuple.v4tuple.v5tuple.v6tuple.v7tuple.v8tuple.v9tuple.v10new Tuple10(...)T11 v11;this.v11tuple.v11new Tuple11(...)/** Represents a list of 12 typed Objects. ... */T12 v12;this.v12tuple.v12/** Represents a list of Objects. */new Tuple12(...)...[] contents;this.contentstuple.contentscontents.lengthE[] newContentarraycopy(...)new Tuple(...)Tuple<> that/** Represents a list of 13 typed Objects. ... */T13 v13;this.v13tuple.v13new Tuple13(...)/** Represents a list of 14 typed Objects. ... */T14 v14;int thisSizeint otherSizemin(...)this.v14tuple.v14new Tuple14(...)/** Construct a tuple of degree 0. */Tuple0.INSTANCE/** Construct a tuple of degree 1. */new Tuple1<T1>(...)/** Construct a tuple of degree 2. */new Tuple2<T1,T2>(...)/** Construct a tuple of degree 3. */new Tuple3<T1,T2,T3>(...)/** Construct a tuple of degree 4. */new Tuple4<T1,T2,T3,T4>(...)/** Construct a tuple of degree 5. */new Tuple5<T1,T2,T3,T4,T5>(...)/** Represents a list of 15 typed Objects. ... *//** Construct a tuple of degree 6. */new Tuple6<T1,T2,T3,T4,T5,T6>(...)/** Construct a tuple of degree 7. */new Tuple7<T1,T2,T3,T4,T5,T6,T7>(...)T15 v15;/** Construct a tuple of degree 8. */new Tuple8<T1,T2,T3,T4,T5,T6,T7,T8>(...)/** Construct a tuple of degree 9. */this.v15tuple.v15new Tuple9<T1,T2,T3,T4,T5,T6,T7,T8,T9>(...)new Tuple15(...)/** Construct a tuple of degree 10. */new Tuple10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>(...)/** Construct a tuple of degree 11. */new Tuple11<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>(...)/** Construct a tuple of degree 12. *//** Represents a list of 16 typed Objects. ... */new Tuple12<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12>(...)/** Construct a tuple of degree 13. */T16 v16;new Tuple13<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13>(...)this.v16tuple.v16/** Construct a tuple of degree 14. */new Tuple16(...)new Tuple14<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14>(...)/** Construct a tuple of degree 15. */new Tuple15<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15>(...)/** Construct a tuple of degree 16. *//** Represents a list of 2 typed Objects. */new Tuple16<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16>(...)p15new Tuple2(...)/** Represents a list of 3 typed Objects. ... */new Tuple3(...)/** Represents a list of 4 typed Objects. ... */new Tuple4(...)/** Represents a list of 5 typed Objects. ... */new Tuple5(...)/** Represents a list of 6 typed Objects. ... */new Tuple6(...)/** Represents a list of 8 typed Objects. ... *//** Represents a list of 7 typed Objects. ... */new Tuple8(...)new Tuple7(...)/** Represents a list of 9 typed Objects. ... *//** Represents an object which is capable of writing itself to a text stream ... *//** Writes this object to the given writer. ... */new Tuple9(...)import AnnotatedElement/** Represents groovydoc */new Groovydoc(...) { ... }Groovydoc$1String content;List<GroovydocTag> tagList;GroovydocHolder<> holder;Groovydoc EMPTY_GROOVYDOC;this.contentthis.holdernew GroovydocHolder<AnnotatedElement>(...) { ... }Groovydoc$2Groovydoc.this/** Tests if groovydoc is present ... *//** Get the content of groovydoc ... *//** TODO Get list of groovydoc tags ... *//** Get the holder of the groovydoc ... */Groovydoc groovydoc/** Represents Groovydoc Holder */String DOC_COMMENT;/** Get the groovydoc ... */// keys for meta data/** Get GroovydocHolder instance ... */groovydoc.contentgroovydoc.holder//        return tagList;/** TODO parse groovydoc to get tag content */Groovydoc groovydoc;this.groovydoc/** <code>QName</code> class represents the value of a qualified name ... */GroovydocTag that/** comment/shared empty string */String namespaceURI;/** Field namespaceURI */String localPart;/** Field localPart */String prefix;/** Field prefix *//** Constructor for the QName. ... */this.namespaceURIthat.contentthat.groovydocthis.localPartthis.prefix/** Gets the Namespace URI for this QName ... *//** Gets the Local part for this QName ... *//** Gets the Prefix for this QName ... *//** Returns the fully qualified name of this QName ... *//** Returns a string representation of this QName ... *//** Tests this QName for equality with another object. ... */QName qNameqName.namespaceURIqName.localPartint lastColonIndexString stringPrefiximport BasicPermission/** Permission required to explicitly specify a codebase for a groovy script whose ... */String stringLocalPart/** Tests if this QName matches another object. ... */import Calendarimport Date/** Base class for date and time durations. ... */int years;int months;int days;int hours;int minutes;int seconds;int millis;this.yearsthis.monthsthis.daysthis.hoursthis.minutes/** Returns a QName holding the value of the specified String. ... */this.secondsthis.millisCalendar calsetTime(...)Calendar.YEARCalendar.MONTHCalendar.DAY_OF_YEARCalendar.HOUR_OF_DAYCalendar.MINUTEnew QName(...)/** Returns a hash code value for this QName object. The hash code ... */Calendar.SECONDCalendar.MILLISECONDgetTime(...)List<> buffer// try matching against 'prefix:localname'/** DatumDependentDuration represents durations whose length in milliseconds ... */new DatumDependentDuration(...)getYears(...)getMonths(...)getDays(...)getHours(...)getMinutes(...)getSeconds(...)getMillis(...)int norm_millis... % ...int norm_secondsintdiv(...)CharSequence millisToPadabs(...)padLeft(...)join(...)signum(...)toMilliseconds(...)getNow(...)/** @see ... */Date nownew Date(...)getTimeInMillis(...)new From(...) { ... }DatumDependentDuration$1/** Duration represents time periods which have values independent of the context. ... */DatumDependentDuration.thisnew Duration(...)new TimeDuration(...)new TimeDatumDependentDuration(...)Duration$1Duration.thisimport TimeZone/** Apply a number of methods to allow convenient Date/Time manipulation,such as: ... *//* Methods to allow Date Duration arithmetic *//** Retrieves the default TimeZone for a date by using the default Locale ... */Calendar calendargetTimeZone(...)/** Get the DST offset (if any) for the default locale and the given date. ... */TimeZone timeZoneint millis/** TimeDatumDuration represents a time period which results from an ... */getDSTSavings(...)useDaylightTime(...)inDaylightTime(...)getDaylightSavingsOffset(...)/** Return a Duration representing the DST difference (if any) between two ... */Duration d1Duration d2/** Subtract one date from the other. ... */long millisecondslong daysTimeDatumDependentDuration$1int hoursint minutesint secondsTimeDatumDependentDuration.this/* Methods on Integer to implement 1.month, 4.years etc. *//* Methods on Integer to implement 1.week, 4.days etc. */getWeeks(...)/** TimeDuration represents time periods expressed in units of hours, minutes, ... */getMilliseconds(...)TimeDuration$1TimeDuration.thisimport Closure/** This AST transformation aims at helping in debugging other AST transformations. It provides a basic ... */ElementType.PACKAGE/** The AnnotationCollector can be used to define aliases for groups of ... *//** Processor used for computing custom logic or the list of annotations, or ... *//** When the collector annotation is replaced, whether to check for duplicates between ... *//** The compile phase after which the test code should run. *//** List of aliased annotations. *//** A closure which is executed against the annotated node after the specified phase has completed. *//** Used internally - the default value is a marker value indicating that the attribute hasn't been set. ... *//* @ClosureParams(value=FromString.class,options="") *//** Class annotation used to assist in the creation of {@code Cloneable} classes. ... *//** Comma separated list of property (and/or field) names to exclude from cloning. ... *//** Include fields as well as properties when cloning. ... *//** Style to use when cloning. *//** Intended style to use for cloning when using the {@code @}AutoClone annotation. ... */new AutoCloneStyle(...)AutoCloneStyle CLONE;/** Uses only cloning. */AutoCloneStyle SIMPLE;/** Uses the no-arg constructor followed by property/field copying/cloning. */AutoCloneStyle COPY_CONSTRUCTOR;/** Uses the copy constructor pattern. */AutoCloneStyle SERIALIZATION;/** Uses serialization to clone. *//** Annotation to automatically add the final qualifier to method, constructor, ... *//** Indicates that adding final to parameters should not be applied on this node. ... *//** Class annotation used to provide default dummy methods for a class extending an abstract super class or ... *//** If defined, all unimplemented methods will throw this exception. ... *//** If {@code exception} is defined, {@code message} can be used to specify the exception message. ... *//** If defined, all unimplemented methods will execute the code found within the supplied closure. */import Script/** Variable annotation used for changing the base script class of the current script. ... *//* , ElementType.IMPORT *//** This interface is for AST transformations which must be aware of the compilation unit where they are applied. *//** This will let the Groovy compiler use compile time checks in the style of Java ... *//** The list of (classpath resources) paths to type checking DSL scripts, also known ... */new AnnotationCollectorMode(...)AnnotationCollectorMode DUPLICATE;/** Annotations from the annotation collection will always be inserted. After all transforms have been run, it will ... */AnnotationCollectorMode PREFER_COLLECTOR;/** Annotations from the collector will be added and any existing annotations with the same name will be removed. */AnnotationCollectorMode PREFER_EXPLICIT;/** Annotations from the collector will be ignored if any existing annotations with the same name are found. */AnnotationCollectorMode PREFER_COLLECTOR_MERGED;/** Annotations from the collector will be added and any existing annotations with the same name will be removed but any new parameters found within existing annotations will be merged into the added annotation. */AnnotationCollectorMode PREFER_EXPLICIT_MERGED;/** Annotations from the collector will be ignored if any existing annotations with the same name are found but any new parameters on the collector annotation will be added to existing annotations. *//** Intended mode to use when generating constructors to emulate default parameter values when using the {@link TupleConstructor} annotation. ... *//** Class annotation used to assist in creating appropriate {@code equals()} and {@code hashCode()} methods. ... */new DefaultsMode(...)DefaultsMode OFF;/** Produce a single constructor corresponding to the complete list of properties/fields of the class being compiled. */DefaultsMode AUTO;/** Produce multiple constructors as required to handle any mandatory and optional arguments. ... */DefaultsMode ON;/** Produce multiple constructors as required from all parameters through to the no-arg constructor. ... *//** List of property names (and field names if includeFields is true) to exclude from the equals and hashCode calculations. ... *//** List of property names (and field names if includeFields is true) to include within the equals and hashCode calculations. ... *//** Whether to cache hashCode calculations. You should only set this to true if ... *//** Whether to include super in equals and hashCode calculations. *//** Include fields as well as properties in equals and hashCode calculations. *//** Generate a canEqual method to be used by equals. *//** Whether to include all properties (as per the JavaBean spec) in the generated constructor. ... *//** Whether to include all fields and/or properties in equals and hashCode calculations, including those ... *//** Whether to avoid using Groovy runtime methods and instead use methods like {@link java.util.Objects#hash(Object...)} ... *//** Class annotation used to assist in the creation of {@code Externalizable} classes. ... *//** Comma separated list of property names to exclude from externalizing. ... *//** Include fields as well as properties when externalizing. *//** Variable annotation used for changing the scope of a variable within a script from ... *//** Comma separated list of property names to exclude from externalization verification. ... *//** Include fields as well as properties when verifying externalization properties. *//** Turns on strict type checking for property (or field) types. In strict mode, such types must also implement Serializable or Externalizable. ... *//** Annotation to add the final modifier to classes, methods, constructors, and fields. ... *//** Marks class members that have been generated by the compiler. ... *//** When disabled, this annotation effectively becomes a no-op. ... *//** Class annotation used to assist in the creation of immutable classes. ... *//** If {@code true}, this adds a method {@code copyWith} which takes a Map of ... */import ImmutablePropertyHandler/** Allows you to provide {@code @Immutable} with a list of classes which ... *//** Allows you to provide {@code @Immutable} with a list of property names which ... *//** Field annotation used with properties to provide an indexed getter and setter for the property. ... *//** Class annotation to make constructors from a super class available in a sub class. ... *//** Whether to carry over annotations on the copied constructors. ... *//** Whether to carry over parameter annotations on the copied constructors. ... *//** Marks class members that are intended for internal use. ... *//** Class annotation used as a marker for immutable classes. ... *//** Class annotation used to assist in the creation of map constructors in classes. ... *//** List of field and/or property names to exclude from the constructor. ... *//** List of field and/or property names to include within the constructor. ... *//** Include properties in the constructor. *//** Include fields in the constructor. Fields come after any properties. *//** Include properties from super classes in the constructor. ... *//** Include fields from super classes in the constructor. ... *//** By default, Groovy properties are set directly using their respective field. ... *//** Whether to include static properties in the constructor. *//** Whether to include all fields and/or properties within the constructor, including those with names that are considered internal. *//** In addition to the map constructor, provide a no-arg constructor which calls the map constructor with an empty map. *//** If true, change the type of the map constructor argument from Map to LinkedHashMap only for the case where ... *//** If specified, must match the "id" attribute in a VisibilityOptions annotation to enable a custom visibility. *//** Method annotation that creates a cache for the results of the execution of the annotated method. Whenever the method ... *//** A Closure containing statements which will be prepended to the generated constructor. The first statement within the Closure may be "super(someArgs)" in which case the no-arg super constructor won't be called. *//** A Closure containing statements which will be appended to the end of the generated constructor. Useful for validation steps or tweaking the populated fields/properties. *//** Number of cached return values to protect from garbage collection. *//** The maximum size the cache can grow to. *//** Marker interface used to indicate that the property names of the annotated parameter ... */import Repeatable/** Marker interface used to indicate that the name of the annotated parameter ... *//** Collector annotation for {@link NamedParam}. ... *//** Allows construction of a named-arg equivalent method or constructor. ... *//** If specified, must match the optional "id" attribute in an applicable {@code VisibilityOptions} annotation. *//** If true, add an implicit {@code @NamedDelegate} to the first parameter if no {@code @NamedDelegate} or {@code @NamedParam} annotations are found on any parameter. ... *//** If true, will use {@code as} to convert map parameter to required class ... *//** Class annotation used to demarcate non-sealed classes. ... *//** Class, method or constructor annotation which indicates that each parameter ... *//** Whether to try to add null checking to generated methods/constructors such as those added by other transforms. ... *//** Annotation used for turning off Groovy's auto visibility conventions. ... */import DefaultPropertyHandlerimport PropertyHandler/** Marker annotation used to indicate that special property handling code will be generated for this class. ... *//** The property handler class which creates the necessary code for getting, setting or initializing properties. *//** Marks the return value of "pure" method only comes from expressions involving ... *//** Class annotation used to assist in the creation of record-like classes. ... *//** Mode to use when creating record type classes. *//** If {@code true}, this adds a method {@code getAt(int)} which given ... *//** If {@code true}, this adds a method {@code toList()} to the record ... *//** If {@code true}, this adds a method {@code toMap()} to the record. ... *//** If {@code true}, this adds a method {@code size()} to the record which returns the number of components. ... *//** If {@code true}, this adds a method {@code components()} to the record ... *//** Intended mode to use for records when using the {@code @RecordType} annotation (or {@code record} keyword). ... */new RecordTypeMode(...)RecordTypeMode EMULATE;/** Produce a record-like class. */RecordTypeMode NATIVE;/** Produce a Java-like "native" record (JEP 359/384/395). */RecordTypeMode AUTO;/** Produce native records when compiling for a suitable target bytecode (JDK16+). *//** Class annotation used to assist in the creation of sealed classes. ... *//** List of the permitted subclasses. *//** Intended mode to use for sealed classes when using the {@code @Sealed} annotation (or {@code sealed} keyword). ... */new SealedMode(...)SealedMode EMULATE;/** Indicate the sealed nature using annotations. ... */SealedMode NATIVE;/** Produce Java-like code with sealed nature indicated by "native" bytecode information (JEP 360/397/409). ... */SealedMode AUTO;/** Produce native sealed classes when compiling for a suitable target bytecode (JDK17+) ... *//** Mode to use when creating sealed classes. *//** Add annotations even for native sealed classes. ... *//** This annotation can be added on a trait to declare the list of types that a class ... *//** Intended target when {@code @}PackageScope is placed at the class level. ... */new PackageScopeTarget(...)PackageScopeTarget CLASS;/** Make the Class have package protected visibility. */PackageScopeTarget METHODS;/** Make the Class methods have package protected visibility. */PackageScopeTarget FIELDS;/** Make the Class fields have package protected visibility. */PackageScopeTarget CONSTRUCTORS;/** Make the Class constructors have package protected visibility. *//** A class annotation used to make a class Comparable by (potentially) multiple Comparators. ... *//** Property names to include in the comparison algorithm. ... *//** Property names to exclude in the comparison algorithm. ... *//** Set to true so that comparator uses reversed natural order. ... *//** Whether to include super properties in the comparison algorithm. ... *//** Whether to include all properties (as per the JavaBean spec) in the comparison algorithm. ... *//** Whether to include all fields and/or properties in the comparison algorithm, including those with names that ... *//** Variable annotation used for getting the URI of the current script. ... *//** Method annotation to make a method call synchronized for concurrency handling ... *//** Method annotation used to transform methods with tail recursive calls into iterative methods automagically ... *//** Used to mark a class as being a trait. ... *//** Class annotation used to assist in the creation of {@code toString()} methods in classes. ... *//** List of field and/or property names to exclude from generated toString. ... *//** List of field and/or property names to include within the generated toString. The order of inclusion ... *//** Whether to include the toString() of super in the generated toString. *//** Whether to include names of properties/fields in the generated toString. *//** Include fields as well as properties in the generated toString. Fields come after any properties. *//** Whether to include super properties in the generated toString. ... *//** Include super fields in the generated toString. ... *//** Don't display any fields or properties with value <tt>null</tt>. *//** Whether to include the fully-qualified class name (i.e. including ... *//** Whether to include all properties (as per the JavaBean spec) in the generated toString. ... *//** Whether to cache toString() calculations. You should only set this to true if ... *//** Whether to include all fields and/or properties in the generated toString, including those with names that ... *//** Whether to avoid using Groovy runtime methods when printing the toString for class members. ... *//** The String to use after the classname and before the list of properties/fields. ... *//** The String to use after the list of properties/fields. ... *//** The string to use between the name of the property/field and its value when {@code includeNames} is true. ... *//** The string to use between each property/field. ... *//** Class annotation used to assist in the creation of tuple constructors in classes. ... *//** List of field and/or property names to include within the constructor. The order of inclusion ... *//** Include visible fields from super classes in the constructor. ... *//** Should super properties be called within a call to the parent constructor ... *//** By default, this annotation becomes a no-op if you provide your own constructor. ... *//** Used to set whether default value processing is enabled (the default) or disabled. ... *//** Used to set the mode for default value processing. ... *//** By default, properties are set directly using their respective field. ... *//** Whether to include all fields and/or properties within the constructor, including those with names that are ... *//** If true, add a map-based named-arg variant. ... *//** If specified, must match the "id" attribute in a VisibilityOptions annotation to enable a custom visibility. ... *//** A Closure containing statements which will be prepended to the generated constructor. The first statement ... *//** A Closure containing statements which will be appended to the end of the generated constructor. Useful for validation steps or tweaking the populated fields/properties. ... *//** This will let the Groovy compiler use compile time checks in the style of Java. *//** This annotation is added by @TypeChecked on methods which have type checking turned on. ... *//** Returns the type checker information protocol number. This is used if the format of the ... *//** An encoded type information. ... *//** This enumeration can be used whenever it is preferred to annotate a class as ... */new TypeCheckingMode(...)TypeCheckingMode PASS;TypeCheckingMode SKIP;/** Java doesn't allow you to have null as an attribute value. It wants you to indicate what you really ... */String STRING;import Visibility/** Marker annotation used in the context of AST transformations to provide a custom visibility. ... *///    Visibility field() default Visibility.UNDEFINED;/** This annotation is used in conjunction with {@link WithWriteLock} to support read and write synchronization on a method. ... */EXCEPTION.class/** This annotation is used in conjunction with {@link WithReadLock} to support read and write synchronization on a method. ... */import static BuilderASTTransformation.BuilderStrategy/** The {@code @Builder} AST transformation is used to help write classes that can be created using <em>fluent</em> api calls.<!-- --> ... */import ConstructorNodeimport BuilderASTTransformationimport static ClassNodeUtils.addGeneratedInnerClassimport static ClassHelper.OBJECT_TYPEimport static GeneralUtils.blockimport static GeneralUtils.propXimport static GenericsUtils.correctToGenericsSpecRecurseimport static GenericsUtils.createGenericsSpecimport static GenericsUtils.extractSuperClassGenericsimport static GenericsUtils.newClassimport static BuilderASTTransformation.NO_EXCEPTIONSimport static BuilderASTTransformation.NO_PARAMSimport static Opcodes.ACC_PRIVATEimport static Opcodes.ACC_PUBLICimport static Opcodes.ACC_STATIC/** A class for which builder methods should be created. It will be an error to leave ... *//** A class capturing the builder strategy *//** The prefix to use when creating the setter methods. ... *//** For strategies which create a builder helper class, the class name to use for the helper class. ... *//** For strategies which create a builder helper class that creates the instance, the method name to call to create the instance. ... *//** The method name to use for a builder factory method in the source class for easy access of the ... *//** List of field and/or property names to exclude from generated builder methods. ... *//** List of field and/or property names to include within the generated builder methods. ... *//** Generate builder methods for properties from super classes. ... *//** Whether the generated builder should support all properties, including those with names that are considered internal. ... *//** Whether to include all properties (as per the JavaBean spec) in the generated builder. ... *//** Whether to always include helper constructors. Currently only supported by InitializerStrategy. ... *//** This strategy is used with the {@link Builder} AST transform to create a builder helper class ... */BuilderASTTransformation.AbstractBuilderStrategyExpression DEFAULT_INITIAL_VALUE;int PUBLIC_STATIC;unsupportedAttribute(...)buildClass(...)buildMethod(...)ClassNode buildeeClassNode buildercreateBuilder(...)getMemberValue(...)BuilderASTTransformation.MY_TYPE_NAMEcreateBuilderFactoryMethod(...)Parameter parametercreateFieldCopy(...)createBuilderMethodForProp(...)new PropertyInfo(...)getPrefix(...)createBuildMethodForMethod(...)List<String> excludesnew ArrayList<String>(...)import static BuilderASTTransformation.MY_TYPE_NAME/** This strategy is used with the {@link Builder} AST transform to populate a builder helper class ... */getMemberClassValue(...)List<String> includesboolean allNamesmemberHasValue(...)boolean allPropertiesList<PropertyInfo> propsgetPropertyInfos(...)Undefined.STRINGgetIncludeExclude(...)isUndefined(...)PropertyInfo piClassNode correctedTypegetCorrectedType(...)createBuildMethod(...)Map<String,ClassNode> genericsSpeccreateGenericsSpec(...)extractSuperClassGenerics(...)correctToGenericsSpecRecurse(...)addGeneratedInnerClass(...)createBuilderMethod(...)new InnerClassNode(...)getFullName(...)String builderClassNameString buildMethodNameBlockStatement bodyClassNode returnTypenewClass(...)String builderMethodNameinitializeInstance(...)ClassNode fieldTypepropX(...)ClassNode correctedParamTypegetInitialExpression(...)Expression instance//        List<FieldNode> fields = getFields(transform, anno, buildee);import TupleConstructorimport AnnotatedNodeUtilsimport GenericsTypeimport static ClassNodeUtils.addGeneratedConstructorimport static GeneralUtils.ctorSuperSimport static GeneralUtils.ctorThisSimport static GenericsUtils.makeClassSafeWithGenericsimport static Opcodes.ACC_SYNTHETICcheckKnownProperty(...)PropertyInfo propcreateBuilderMethodForField(...)Expression sourceClassInstanceTupleConstructor.class/** Internal phantom type used by the {@code InitializerStrategy} to indicate that a property has been set. It is used in conjunction with the generated parameterized type helper class. *//** Internal phantom type used by the {@code InitializerStrategy} to indicate that a property remains unset. It is used in conjunction with the generated parameterized type helper class. */ClassNode TUPLECONS_TYPE;boolean useSettersboolean forcecreateBuilderForAnnotatedClass(...)createBuilderForAnnotatedMethod(...)import static GeneralUtils.getInstancePropertyFields/** This strategy is used with the {@link Builder} AST transform to modify your Groovy objects so that the ... */List<FieldNode> fieldsList<FieldNode> filteredFieldsfilterFields(...)createInnerHelperClass(...)getBuilderClassName(...)boolean needsConstructorhasAnnotation(...)buildCommon(...)createBuildeeConstructors(...)Parameter[] parametersList<FieldNode> convertedFieldsconvertParamsToFields(...)setModifiers(...)createBuildeeMethods(...)FieldNode filteredFieldcreateBuilderConstructors(...)List<FieldNode> fieldNodesnew ArrayList<FieldNode>(...)FieldNode fieldNodeString fullNameGenericsType[] gtypesnew GenericsType[]gtypes.lengthmakePlaceholder(...)setGenericsTypes(...)makeClassSafeWithGenerics(...)unsetGenTypes(...)new GenericsType(...)UNSET.classSET.classctorSuperS(...)addGeneratedConstructor(...)initializeFields(...)getParams(...)createInitializerConstructor(...)ClassNode paramTypesetGenTypes(...)List<Expression> argsListcheckKnownField(...)shouldSkipUndefinedAware(...)Opcodes.ACC_PUBLICgetInstancePropertyFields(...)import POJOParameter initParamimport MethodCallExpressionimport VariableExpressionimport MapConstructorASTTransformationimport static ConstructorNodeUtils.checkPropNamesSimport static ClassHelper.makeString newNameimport static GeneralUtils.equalsNullXimport static GeneralUtils.getSetterNamerenameMethod(...)POJO.class// no rename so delete and addClassNode POJO_TYPE;getExceptions(...)removeMethod(...)boolean successnew Parameter[]FieldNode fNodenew Parameter(...)VariableExpression namedArgsboolean pojoctorThisS(...)equalsNullX(...)checkPropNamesS(...)validateProperties(...)ClassNode typemakeWithoutCaching(...)setRedirect(...)setGenericsPlaceHolder(...)boolean hasSetterassignFieldS(...)Expression varsetViaSetterS(...)assignToFieldS(...)ArgumentListExpression nameArgMethodCallExpression varMethodCallExpression containsKeysetImplicitThis(...)//success |= isValidAttribute(xform, anno, "");// can't have private and public methods of the same name, so rename originalimport TupleConstructorASTTransformationimport static ClassHelper.makeWithoutCachingimport static GeneralUtils.findArgimport static GeneralUtils.ifElseSimport static GeneralUtils.isOneXimport static GeneralUtils.isTrueX/** The {@code @Immutable} transformation in earlier versions of Groovy tried to be smart ... */HashMap<>.classClassNode HMAP_TYPE;Expression fieldExprExpression initExprgetInitialValueExpression(...)Statement assignInitExpression namedArgsfindArg(...)Expression baseArgsStatement assignStmtifElseS(...)isTrueX(...)cloneCollectionExpr(...)import ReadOnlyPropertyExceptionisOneX(...)import ImmutablePropertyUtilsimport EmptyStatementimport ImmutableASTTransformationimport NullCheckASTTransformationisNullExpression(...)import SortedMapimport SortedSetimport static ImmutablePropertyUtils.cloneArrayOrCloneableExprimport static ImmutablePropertyUtils.cloneDateExprimport static ImmutablePropertyUtils.derivesFromDateimport static ImmutablePropertyUtils.implementsCloneableConstantExpression.EMPTY_EXPRESSIONimport static GeneralUtils.assignNullSimport static GeneralUtils.castXimport static GeneralUtils.classList2argsimport static GeneralUtils.isInstanceOfXimport static GeneralUtils.isOrImplementsimport static GeneralUtils.list2argsimport static GeneralUtils.notXimport static GeneralUtils.safeExpressionimport static GeneralUtils.ternaryXimport static GeneralUtils.throwSvalidateAttributes(...)Cloneable.classCollection<>.classDefaultGroovyMethods.classImmutableASTTransformation.classSortedSet<>.classSortedMap<>.classSet<>.classReadOnlyPropertyException.classClassNode CLONEABLE_TYPE;ClassNode COLLECTION_TYPE;ClassNode DGM_TYPE;ClassNode SELF_TYPE;ClassNode MAP_TYPE;ClassNode SORTEDSET_CLASSNODE;ClassNode SORTEDMAP_CLASSNODE;ClassNode SET_CLASSNODE;ClassNode MAP_CLASSNODE;ClassNode READONLYEXCEPTION_TYPE;Statement statementimplementsCloneable(...)createGetterBodyArrayOrCloneable(...)derivesFromDate(...)createGetterBodyDate(...)createGetterBodyDefault(...)isValidAttribute(...)getAnnotationName(...)checkFinalArgNotOverridden(...)createConstructorStatement(...)Expression expressioncloneArrayOrCloneableExpr(...)safeExpression(...)cloneDateExpr(...)castX(...)createIfInstanceOfAsImmutableS(...)ClassHelper.LIST_TYPEcreateAsImmutableX(...)ternaryX(...)isInstanceOfX(...)createLegacyConstructorStatementMapSpecial(...)List<String> knownImmutableClassesgetKnownImmutableClasses(...)List<String> knownImmutablesgetKnownImmutables(...)ClassNode fTypeboolean shouldNullCheckhasIncludeGenerated(...)isKnownImmutableType(...)isKnownImmutable(...)createConstructorStatementDefault(...)createConstructorStatementArrayOrCloneable(...)createConstructorStatementDate(...)isDerivedFrom(...)isOrImplements(...)createConstructorStatementCollection(...)isResolved(...)createErrorMessage(...)EmptyStatement.INSTANCEcreateConstructorStatementGuarded(...)Expression paramgetParam(...)makeThrowStmt(...)isPrimitiveType(...)assignNullS(...)assignFieldWithDefault(...)setInitialValueExpression(...)createCheckImmutable(...)// check at runtime since classes might not be resolvedExpression argslist2args(...)classList2args(...)notX(...)throwS(...)// to avoid default initialization/** Indicates the visibility of a node. ... */new Visibility(...)Visibility PUBLIC;Visibility PROTECTED;import GroovyClassLoaderimport PropertyOptionsVisibility PACKAGE_PRIVATE;Visibility PRIVATE;Visibility UNDEFINED;int modifier;import Annotationthis.modifier/** Used to provide custom property handling when getting, setting or initializing properties. ... */PropertyOptions.classClass<? extends Annotation> PROPERTY_OPTIONS_CLASS;ClassNode PROPERTY_OPTIONS_TYPE;/** Create a statement that will initialize the property including any defensive copying. Null if no statement should be added. ... *//** Create the getter block used when reading the property including any defensive copying. ... */getGetterBlock(...)/** Create the setter block used when setting the property. Can be null for read-only properties. ... */getSetterBlock(...)/** Parameter annotation aimed at helping IDEs or the static type checker to infer the ... */import ClosureExpression/** If multiple candidate signatures are found after applying type hints, ... */List<AnnotationNode> annotations// do nothing by defaultAnnotationNode annoimport WarningMessage/** <p>A closure signature hint class is always used in conjunction with the {@link ClosureParams} annotation. It is ... *//** A helper method which will extract the n-th generic type from a class node. ... */GenericsType[] genericsTypesgetGenericsTypes(...)genericsTypes.length/** A helper method which will extract the n-th generic type from the n-th parameter of a method node. ... */ClassNode handlerClassgetOriginType(...)DefaultPropertyHandler.classpickGenericType(...)new DefaultPropertyHandler(...)Object instance/** <p>Subclasses should implement this method, which returns the list of accepted closure signatures.</p> ... *//** Produces a {@link ClassNode} given a string representing the type. Checks ... */ClassNode cnfindClassNode(...)String messagePropertyHandler.classaddWarning(...)WarningMessage.LIKELY_ERRORSisCachedType(...)tryLoadClass(...)getPlainNodeReference(...)ClassNotFoundException ignore// TODO: include reference to the source method & parameter/** <p>A hint used to instruct the type checker to pick the first parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the first generic type of the first parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the second generic type of the first parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the third generic type of the first parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the type of the component of the first parameter type, which is therefore ... */import Traits/** This signature hint uses abstract methods from some type (abstract class or interface) in order ... */ClassNode[] parameterTypesList<ClassNode[]> signaturesnew ArrayList<ClassNode[]>(...)import GenericsUtils/** <p>A closure parameter hint class that is convenient if you want to use a String representation ... */List<ClassNode[]> listoptions.lengthgetAbstractMethods(...)isSynthetic(...)hasDefaultImplementation(...)isGroovyObjectType(...)String optionparseOption(...)/** Parses a string representing a type, that must be aligned with the current context. ... */parseClassNodesFromString(...)import SyntaxExceptiongetTypeDescriptor(...)stream(...)new Function<Parameter,ClassNode>(...) { ... }/** <p>A special hint which handles a common use case in the Groovy methods that work on maps. In case of an ... */Map<>.Entry<>.classnew IntFunction<ClassNode[]>(...) { ... }ClassNode MAPENTRY_TYPE;Options optopt.parameterIndexClassNode[] firstSigClassNode[] secondSigClassNode mapEntryIncorrectTypeHintException eopt.generateIndexClassHelper.int_TYPE/** Marker interface to indicate that the normal GroovyObject methods should not be added. */int parameterIndex;boolean generateIndex;this.parameterIndexthis.generateIndexint pIndexboolean generateIndexString[] keyValuesplit(...)keyValue.lengthnew IncorrectTypeHintException(...)new Options(...)// would happen if you have a raw Map type for example/** <p>Base class for hints which use the type of a parameter of the annotated method as the signature. ... */int genericTypeIndex;/** Creates the an argument picker which extracts the type of the first parameter. *//** Creates a picker which will extract the parameterIndex-th parameter type, or its ... */this.genericTypeIndex/** Returns the first of several candidates found. ... *//** <p>A hint used to instruct the type checker to pick the second parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the first generic type of the second parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the second generic type of the second parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the type of the component of the second parameter type, which is therefore ... */import static Arrays.stream/** A simplified version of a {@link groovy.transform.stc.ClosureSignatureHint} which is suitable ... *//** <p>A hint used to instruct the type checker to pick the third parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the first generic type of the third parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the second generic type of the third parameter type. For example:</p> ... *//** <p>A hint used to instruct the type checker to pick the type of the component of the third parameter type, which is therefore ... */new Function<String,ClassNode>(...) { ... }import Bindingimport GroovyCodeSourceimport GroovyRuntimeExceptionimport GroovyShellimport GroovySystemimport MissingMethodExceptionimport ImportCustomizerimport StackTraceUtilsimport InetAddressimport ServerSocketimport CommandLineimport Socketimport Commandimport IVersionProviderimport Optionimport ParameterExceptionimport ParseResultimport Unmatchedimport FileReaderimport FileWriter/** Simple server that executes supplied script against a socket. ... */GroovyShell groovy;GroovyCodeSource source;boolean autoOutput;int counter;/** This creates and starts the socket server on a new Thread. There is no need to call run or spawn ... *//** A Command line to execute groovy. */matches(...)searchForGroovyScriptFile(...)List<String> args;// arguments to the scriptboolean isScriptFile;// is this a file on diskString script;// filename or content of scriptboolean processFiles;// process args as input filesboolean editFiles;// edit input files in place// automatically output the result of each scriptboolean autoSplit;// automatically split each line using the splitpatternString splitPattern;// The pattern used to split the current lineboolean processSockets;// process socketsint port;// port to listen on when processing socketsString backupExtension;// backup input files with extensionboolean debug;// do you want full stack traces in script exceptions?CompilerConfiguration conf;// Compiler configuration, used to set the encodings of the scripts/classesGroovyShell.DEFAULT_CODE_BASE/** Main CLI interface. ... */processArgs(...)Pattern URI_PATTERN;// package-level visibility for testing purposes (just usage/errors at this stage)// scheme        = alpha *( alpha | digit | "+" | "-" | "." )// RFC2396this.groovythis.sourcethis.autoOutputgetHostAddress(...)getLocalHost(...)GroovyCommand groovyCommandnew GroovyCommand(...)CommandLine parsersetStopAtUnmatched(...)setUnmatchedArgumentsAllowed(...)setErr(...)setOut(...)new CommandLine(...)start(...)new Thread(...)/** Runs this server. There is typically no need to call this method, as the object's constructor ... */ParseResult resultparseArgs(...)ServerSocket serverSocketprintHelpIfRequested(...)new ServerSocket(...)getPort(...)process(...)exit(...)ParameterException exnew GroovyClientConnection(...)accept(...)usage(...)getCommandLine(...)Script script;Socket socket;BufferedReader reader;PrintWriter writer;boolean autoOutputFlag;this.scriptthis.autoOutputFlagthis.socketnew BufferedReader(...)getOutputStream(...)getInetAddress(...)String linereadLine(...)IOException e3// We could jump through some hoops to have GroovyShell make our script name, but that seems unwarranted.// If we *did* jump through that hoop then we should probably change the run loop to not recompile// the script on every iteration since the script text can't change (the reason for the recompilation).// Create one script per socket connection.// This is purposefully not caching the Script// so that the script source file can be changed on the fly,// as each connection is made to the server.//FIXME: Groovy has other mechanisms specifically for watching to see if source code changes.// We should probably be using that here.// See also the comment about the fact we recompile a script that can't change.// System.out.println(line);// to close sockets gracefully etc...new LinkedHashMap<String,String>(...)// do nothingString classpath;// This saves us from having to fork a new JVM process with the classpath set from the processed arguments.// can extract it and the JVM can be started with the classpath already correctly set.// classpath must be the first argument, so that the `startGroovy(.bat)` script// IMPLEMENTATION NOTE:List<String> disableopt;String encoding;String extension;boolean lineByLine;boolean lineByLinePrint;boolean parameterMetadata;boolean previewFeatures;String port;String configscript;String scriptBaseClass;boolean helpRequested;boolean versionRequested;boolean compileStatic;boolean typeChecked;List<String> arguments;/** Process the users request. ... */GroovyMain mainnew GroovyMain(...)List<String> transformationsEntry<String,String> entrysetSourceEncoding(...)main.confmain.debugsetDebug(...)setParameters(...)setPreviewFeatures(...)main.processFilesmain.autoOutputmain.editFilesmain.backupExtensionmain.autoSplitmain.splitPatternmain.isScriptFilenew ParameterException(...)main.scriptmain.processSocketsString ptrim(...)main.portString optimizationgetOptimizationOptions(...)setScriptBaseClass(...)processConfigScriptText(...)buildConfigScriptText(...)processConfigScripts(...)getConfigScripts(...)main.argsList<String> scriptsString configScriptsthis.configscripttokenize(...)createConfigScriptsShell(...)String scriptStringBuilder scriptString tBinding bindingCompilerConfiguration configuratorConfigImportCustomizer customizernew ImportCustomizer(...)addStaticStars(...)addCompilationCustomizers(...)/** Run the script. */processSockets(...)processFiles(...)processOnce(...)deepSanitize(...)/** Process Sockets. */GroovyShell groovynew GroovySocketServer(...)getScriptSource(...)/** Get the text of the Groovy script at the given location. ... */huntForTheScriptFile(...)/** Get a new GroovyCodeSource for a script which may be given as a location ... */File scriptFile// match URIs but not Windows filenames, e.g.: http://cnn.com but not C:\xxx\file.ext/** Search for the script file, doesn't bother if it is named precisely. ... */String scriptFileNameString[] standardExtensionsstandardExtensions.length/** Hunt for the script file by calling searchForGroovyScriptFile(String). ... */// GROOVY-6771Thread currentGroovyMain$1DoSetContext/** Process the input files. */Script ssetupContextClassLoader(...)BufferedReader readerSystem.inPrintWriter writerprocessReader(...)processFile(...)/** Process a single input file. ... */new FileReader(...)/** An iterator that allows examining the next element without consuming it. ... */File backupcreateTempFile(...)deleteOnExit(...)delete(...)renameTo(...)new IOException(...)new FileWriter(...)/** Process a script against a single input file. ... */String lineCountNameString autoSplitNameBigInteger.ZERO/** Process the standard, single script with args. */import GroovyObjectSupport/** Base class for creating arbitrary nested trees of objects or events. */Object current;// TODO: pass printstream(s) down through processClosure<> nameMappingClosure;// If we fail, then exit with an error so scripting frameworks can catch it.BuilderSupport proxyBuilder;// command line arguments could not be parsedthis.proxyBuilder// add the ability to parse scripts with a specified encoding// default port to listen tothis.nameMappingClosure//check the script is currently valid before starting a server against the script// search for the file and if it exists don't try to use URIs ...this.current/** Convenience method when no arguments are required. ... */// TODO: Shouldn't these extensions be kept elsewhere?  What about CompilerConfiguration?// This method probably shouldn't be in GroovyMain either.// if we still haven't found the file, point back to the originally specified filenameObject name//TODO: These are the arguments for -p and -i.  Why are we searching using Groovy script extensions?// Where is this documented?Object node// ignore the missing method exception// as it means no begin() method is present// as it means no end() method is presentimport FileInputStreamimport LineNumberReaderimport StandardCharsets/** Utility class to guess the encoding of a given text file. ... */new Charset[]new byte[]...[] EMPTY_CHARSET_ARRAY;...[] buffer;Charset defaultCharset;Charset charset;boolean enforce8Bit;...[] EMPTY_BYTE_ARRAY;/** Constructor of the <code>CharsetToolkit</code> utility class. ... */this.defaultCharsetcreateNode(...)this.charsetInputStream inputnew FileInputStream(...)byte[] bytesint bytesReadthis.bufferbyte[] bytesToGuess/** Defines the default <code>Charset</code> used in case the buffer represents ... */Object object1guessEncoding(...)Object object2/** If US-ASCII is recognized, enforce to return the default encoding, rather than US-ASCII. ... */this.enforce8Bit/** Gets the enforce8Bit flag, in case we do not want to ever get a US-ASCII encoding. ... *//** Retrieves the default Charset *//** Guess the encoding of the provided buffer. ... */boolean highOrderBitboolean validU8Charbuffer.lengthhasUTF8Bom(...)StandardCharsets.UTF_8hasUTF16LEBom(...)Object arg0StandardCharsets.UTF_16LEhasUTF16BEBom(...)StandardCharsets.UTF_16BEObject arg1Object arg2byte b0byte b1byte b2byte b3byte b4setParent(...)byte b5Object oldCurrentisTwoBytesSequence(...)isContinuationChar(...)isThreeBytesSequence(...)getCurrent(...)isFourBytesSequence(...)setCurrent(...)setClosureDelegate(...)isFiveBytesSequence(...)isSixBytesSequence(...)StandardCharsets.US_ASCII/** If the byte has the form 10xxxxx, then it's a continuation byte of a multiple byte character; ... *//** If the byte has the form 110xxxx, then it's the first byte of a two-bytes sequence character. ... */nodeCompleted(...)/** If the byte has the form 1110xxx, then it's the first byte of a three-bytes sequence character. ... */postNodeCompletion(...)/** A strategy method to allow derived builders to use ... *//** If the byte has the form 11110xx, then it's the first byte of a four-bytes sequence character. ... *//** If the byte has the form 11110xx, then it's the first byte of a five-bytes sequence character. ... *//** If the byte has the form 1110xxx, then it's the first byte of a six-bytes sequence character. ... *//** Retrieve the default charset of the system. ... *//** Has a Byte Order Marker for UTF-8 (Used by Microsoft's Notepad and other editors). ... *//** Has a Byte Order Marker for UTF-16 Low Endian ... *//** A hook to allow names to be converted into some other object ... *//** Has a Byte Order Marker for UTF-16 Big Endian ... *//** Gets a <code>BufferedReader</code> (indeed a <code>LineNumberReader</code>) from the <code>File</code> ... */LineNumberReader reader/** A hook to allow nodes to be processed once they have had all of their ... */new LineNumberReader(...)getCharset(...)// push new node on stack// let's register the builder as the delegate/** Retrieves all the available <code>Charset</code>s on the platform, ... */Collection<> collectionavailableCharsets(...)/** A Comparator which uses a closure to compare 2 values being equal */intUnbox(...)// if the file has a Byte Order Marker, we can assume the file is in UTF-xx// otherwise, the file would not be human readable// if a byte has its most significant bit set, the file is in UTF-8 or in the default encoding// otherwise, the file is in US-ASCII// if the file is in UTF-8, high order bytes must have a certain value, in order to be valid// if it's not the case, we can assume the encoding is the default encoding of the system// TODO the buffer is not read up to the end, but up to length - 6// a high order bit was encountered, thus the encoding is not US-ASCII// it may be either an 8-bit encoding or UTF-8// a two-bytes sequence was encountered// there must be one continuation byte of the form 10xxxxxx,// otherwise the following character is is not a valid UTF-8 construct// a three-bytes sequence was encountered// there must be two continuation bytes of the form 10xxxxxx,// a four-bytes sequence was encountered// there must be three continuation bytes of the form 10xxxxxx,// a five-bytes sequence was encountered// there must be four continuation bytes of the form 10xxxxxx,// a six-bytes sequence was encountered// there must be five continuation bytes of the form 10xxxxxx,// if no byte with an high order bit set, the encoding is US-ASCII// (it might have been UTF-7, but this encoding is usually internally used only by mail systems)// returns the default charset rather than US-ASCII if the enforce8Bit flag is set.// if no invalid UTF-8 were encountered, we can assume the encoding is UTF-8,// otherwise the file would not be human readable// finally, if it's not UTF-8 nor US-ASCII, let's assume the encoding is the default encoding// should never happen, as a file with no content// but with a BOM has at least one charimport MissingPropertyException/** {@link Script} that performs method invocations and property access like {@link groovy.lang.Closure} does. ... *//** Sets the delegation target. *//** Allow easy integration from Groovy into Java through convenience methods. ... *//** Evaluates the specified String expression and returns the result. For example: ... */me(...)/** Evaluates the specified String expression and makes the parameter available inside ... */Binding bGroovyShell sh/** Evaluates the specified String expression and makes the first two parameters available inside ... *//** Evaluates the specified String expression and makes the first three parameters available inside ... */import MetaExpandoProperty/** Represents a dynamically expandable bean. */Map<> expandoProperties;createMap(...)List<> retnew MetaExpandoProperty(...)/** This allows toString to be overridden by a closure <i>field</i> method attached ... *//** This allows equals to be overridden by a closure <i>field</i> method attached ... */Boolean ret/** This allows hashCode to be overridden by a closure <i>field</i> method attached ... */Integer ret/** Factory method to create a new Map used to store the expando properties map ... */// run through all our current properties and create MetaProperty objects// always use the expando properties first// IGNORE// always use the expando properties// br should get a "native" property match first. getProperty includes such fall-back logic// invoke overridden toString closure method// invoke overridden equals closure method// invoke overridden hashCode closure methodimport Writableimport Typesimport Properties/** A ConfigObject at a simple level is a Map that creates configuration entries (other ConfigObjects) when referencing them. ... *//** Does this factory "Own" its child closure. ... *//** Called when a factory is registered to a builder ... *//** Only called if it isLeaf is false and isHandlesNodeChildren is true ... */getKeywords(...)Collection<String> KEYWORDS;String TAB_CHARACTER;URL configFile;/** The config file that was used when parsing this ConfigObject */HashMap<> delegateMap;this.configFile/** Writes this config object into a String serialized representation which can later be parsed back using the parse() ... */BufferedWriter outwriteConfig(...)/** Overrides the default getProperty implementation to create nested ConfigObject instances on demand ... */ConfigObject propnew ConfigObject(...)/** A ConfigObject is a tree structure consisting of nested maps. This flattens the maps into ... */flatten(...)/** Flattens this ConfigObject populating the results into the target Map ... */populate(...)/** Merges the given map with this ConfigObject overriding any matching configuration entries in this ConfigObject ... */doMerge(...)/** Converts this ConfigObject into a the java.util.Properties format, flattening the tree structure beforehand ... */Properties propsnew Properties(...)convertValuesToString(...)/** Converts this ConfigObject ino the java.util.Properties format, flatten the tree and prefixing all entries with the given prefix ... */Entry<> nextObject configEntryString spaceObject o1Object vConfigObject valueObject dotsInKeysint configSizeObject firstKeyObject firstValueint firstSizeEntry<> eString kasBoolean(...)String writePrefixwriteNode(...)Object jObject v2Object k2writeValue(...)boolean isKeywordProperties newPropsNullPointerException eputAll(...)/** Returns a shallow copy of this ConfigObject, keys and configuration entries are not cloned. ... */ConfigObject cloneclone.configFileclone.delegateMap/** Checks if a config option is set. Example usage: ... */import DelegatingMetaClassimport ReferenceObject entryimport TreeSetWriter sw// recur//        key = key.indexOf('.') > -1 ? InvokerHelper.inspect(key) : key;// it is idiotic story but if config map doesn't allow null values (like Hashtable)// we can't do too much/** Mix of BuilderSupport and SwingBuilder's factory support. ... */new ThreadLocal<LinkedList<Map<String,Object>>>(...)new LinkedList<Closure<>>(...)import FromStringimport NumberAwareComparator/** A Collections utility class *//** Finds all combinations of items from the given collections. ... */combinations(...)/** Finds all non-null subsequences of a list. ... */Set<List<T>> ansnew HashSet<List<T>>(...)T hSet<List<T>> nextList<T> hlistnew ArrayList<Closure<>>(...)new HashMap<String,Factory>(...)List<T> itList<T> sublist/** Finds all combinations of items from the given Iterable aggregate of collections. ... */List<> collectedCombosObject collectionIterable<> itemsasCollection(...)Object itemList<> savedCombosList<> newCombosObject savedCombonew ThreadLocal<FactoryBuilderSupport>(...)List<> oldListnew HashMap<String,Closure<>[]>(...)List<T> copyList<List<T>> resultnew ArrayList<List<T>>(...)new HashMap<String,Closure<>>(...)List<T> nextnew HashMap<String,Set<String>>(...)FactoryBuilderSupport.class/** Transposes an array of lists. ... */transpose(...)/** Transposes the given lists. ... */int minSizeObject listLikeList<>.classList<> resultList/** Selects the minimum value found in an array of items, so ... *//** Selects the minimum value found in an Iterable of items. ... *//** Selects the maximum value found in an array of items, so ... *//** Selects the maximum value found in an Iterable. ... *//** Sums all the items from an array of items. ... */sum(...)/** Sums all the given items. ... *//** Returns an ordered set of all the unique items found in the provided argument iterables. ... */union(...)new NumberAwareComparator<T>(...)thenComparingInt(...)new Function<Method,String>(...) { ... }/** Returns an ordered set of all the unique items found in the provided argument iterables ... */new ToIntFunction<Method>(...) { ... }String CURRENT_FACTORY;String PARENT_FACTORY;String PARENT_NODE;String CURRENT_NODE;String PARENT_CONTEXT;String PARENT_NAME;String CURRENT_NAME;String OWNER;String PARENT_BUILDER;String CURRENT_BUILDER;String CHILD_BUILDER;String SCRIPT_CLASS_NAME;Logger LOG;Comparator<Method> METHOD_COMPARATOR;/** Throws an exception if value is null. ... *//** Checks type of value against builder type ... */LinkedHashSet<T> ansSetnew LinkedHashSet<T>(...)TreeSet<T> seennew TreeSet<T>(...)/** Checks values against factory's type ... */ThreadLocal<LinkedList<Map<String,Object>>> contexts;LinkedList<Closure<>> attributeDelegates;List<Closure<>> disposalClosures;Map<String,Factory> factories;// because of reverse iteration use ArrayListThreadLocal<FactoryBuilderSupport> localProxyBuilder;FactoryBuilderSupport globalProxyBuilder;LinkedList<Closure<>> preInstantiateDelegates;LinkedList<Closure<>> postInstantiateDelegates;LinkedList<Closure<>> postNodeCompletionDelegates;Closure<> methodMissingDelegate;Closure<> propertyMissingDelegate;Map<String,Closure<>[]> explicitProperties;Map<String,Closure<>> explicitMethods;Map<String,Set<String>> registrationGroup;String registrationGroupName;boolean autoRegistrationRunning;// use binding to store?boolean autoRegistrationComplete;new TreeSet<String>(...)Iterable<T> nextListT nextComparator<T> comparatornew OrderBy<T>(...)new ClosureComparator<T>(...)autoRegisterNodes(...)Set<String> groupnew Function<String,Set<String>>(...) { ... }/** Ask the nodes to be registered */callAutoRegisterMethods(...)Method[] declaredMethods// items.inject([]){ ss, h -> ss.collect { it + [h] }  + ss + [[h]] }InvocationTargetException edoGetVariable(...)getProxyBuilder(...)import GroovyResourceLoaderimport ClassNodeResolverimport DependencyTrackerimport StringSetMapimport WeakReferencedoSetVariable(...)doGetVariables(...)doGetProperty(...)/** Specific script engine able to reload modified scripts as well as dealing properly ... */new ConcurrentHashMap<String,ScriptCacheEntry>(...)MissingPropertyException mpe2Closure<>[] accessorsresolveExplicitProperty(...)doSetProperty(...)unmodifiableMap(...)getProxyBuilder(...).factoriesgetProxyBuilder(...).explicitMethodsgetProxyBuilder(...).explicitPropertiesunmodifiableSet(...)Set<String> groupSetemptySet(...)LinkedList<Map<String,Object>> contextsgetProxyBuilder(...).contextsgetContextAttribute(...)Map<> context/** Convenience method when no arguments are required ... */Object previousContextgetContexts(...)Map<String,Object> contextCompilerConfiguration.DEFAULT_SOURCE_ENCODINGpopContext(...)/** Add an attribute delegate so it can intercept attributes being set. ... */getProxyBuilder(...).attributeDelegates/** Remove the most recently added instance of the attribute delegate. ... */new PrivilegedAction<ClassLoader>(...) { ... }/** Add a preInstantiate delegate so it can intercept nodes before they are ... */getProxyBuilder(...).preInstantiateDelegatesnew ClassLoader(...) { ... }GroovyScriptEngine$1/** Remove the most recently added instance of the preInstantiate delegate. ... *//** Add a postInstantiate delegate so it can intercept nodes after they are ... */getProxyBuilder(...).postInstantiateDelegatesnew WeakReference<ThreadLocal<LocalData>>(...)/** Remove the most recently added instance of the postInstantiate delegate. ... *//** Add a nodeCompletion delegate so it can intercept nodes after they done ... */getProxyBuilder(...).postNodeCompletionDelegates/** Remove the most recently added instance of the nodeCompletion delegate. ... */registerExplicitProperty(...)String methodNameBaseClassLoader CL_STUB;new StringSetMap(...)new Closure<>[]getRegistrationGroup(...)registerExplicitMethod(...)/** Registers a factory for a JavaBean.<br> ... */registerBeanFactory(...)registerFactory(...)new AbstractFactory(...) { ... }FactoryBuilderSupport$1checkValueIsTypeNotString(...)/** Registers a factory for a node name. ... */onFactoryRegistration(...)/** This method is responsible for instantiating a node and configure its ... */Factory factoryresolveFactory(...)log(...)Level.WARNINGpreInstantiate(...)getChildBuilder(...)CompilationUnit cu;StringSetMap dependencyCache;Map<String,String> precompiledEntries;WeakReference<ThreadLocal<LocalData>> localData;ThreadLocal<LocalData> localLevel.FINEfine(...)new ThreadLocal<LocalData>(...)postInstantiate(...)handleNodeAttributes(...)/** This is a hook for subclasses to plugin a custom strategy for mapping ... */getFactories(...)...[] roots;ResourceConnector rc;ClassLoader parentLoader;GroovyClassLoader groovyLoader;Map<String,ScriptCacheEntry> scriptCache;getExplicitMethods(...)//TODO: more finals?Class<> scriptClass;long lastModified, ...;Set<String> dependencies;getExplicitProperties(...)boolean sourceNewer;/** This method is the workhorse of the builder. ... */this.scriptClassthis.lastModifiedthis.lastCheckReference<> explicitResultnew Reference<>(...)this.dependenciesthis.sourceNewercheckExplicitMethod(...)old.scriptClassold.lastModifiedold.dependenciesdispatchNodeCall(...)setResLoader(...)GroovyResourceLoader rlClosure<> explicitMethodresolveExplicitMethod(...)getConfig(...)URLConnection dependentScriptConngetResourceConnection(...)/** Use {@link FactoryBuilderSupport#dispatchNodeCall(Object, Object)} instead. */ResourceException eCompilationUnit cuboolean needToPopContextnewContext(...)LocalData localgetLocalData(...)Map<> namedArgsCollections.EMPTY_MAPStringSetMap cachelocal.dependencyCacheMap<String,String> precompiledEntrieslocal.precompiledEntriesObject currentlocal.cuString depSourcePathFactory parentFactorygetCurrentFactory(...)boolean processContentisLeaf(...)isHandlesNodeChildren(...)onNodeChildren(...)String parentNamegetCurrentName(...)Map<> parentContext/** A hook to allow names to be converted into some other object such as a ... */getProxyBuilder(...).nameMappingClosure/** Proxy builders are useful for changing the building context, thus ... */FactoryBuilderSupport proxy/** Sets the builder to be used as a proxy. ... */addPhaseOperation(...)new IPrimaryClassNodeOperation(...) { ... }DependencyTracker dtnew DependencyTracker(...)/** Assigns any existing properties to the node.<br> ... */Closure<> attrDelegategetAttributeDelegates(...)FactoryBuilderSupport buildergetOuterClass(...)setClassNodeResolver(...)new ClassNodeResolver(...) { ... }GroovyScriptEngine$ScriptClassLoader$1onHandleNodeAttributes(...)CompilerConfiguration ccsetNodeAttributes(...)/** Pushes a new context on the stack. */String extString finalNameScriptCacheEntry entryentry.scriptClassGroovyScriptEngine.thisnew LookupResult(...)forceClose(...)ResourceException reThreadLocal<LocalData> localThLocalData localDatanew LocalData(...)localData.dependencyCacheClass<?> answerupdateLocalDependencyCache(...)updateScriptCache(...)ScriptCacheEntry origEntrySet<String> origDeponNodeCompleted(...)origEntry.dependencies/** Removes the last context from the stack. ... */Set<String> newDepremoveFirst(...)/** A hook after the factory creates the node and before attributes are set.<br> ... */Closure<> postInstantiateDelegategetPostInstantiateDelegates(...)Closure<> postNodeCompletionDelegategetPostNodeCompletionDelegates(...)/** A hook before the factory creates the node.<br> ... */Closure<> preInstantiateDelegategetPreInstantiateDelegates(...)/** Clears the context stack. *//** A strategy method to allow derived builders to use builder-trees and ... *//** Maps attributes key/values to properties on node. ... */String property/** Strategy method to establish parent/child relationships. ... */getParentFactory(...)setChild(...)getCurrentBuilder(...)new LinkedList<Map<String,Object>>(...)/** Stores the thread local states in a Map that can be passed across threads ... */Map<String,Object> data/** Restores the state of the current builder to the same state as an older build. ... */String depNameScriptCacheEntry deplong timegetCurrentTime(...)Set<String> entryNamesmakeTransitiveHull(...)Entry<String,Set<String>> entryMap<>.Entry<String,Set<String>>build(...)MetaClass scriptMetaClassObject oldScriptNameString entryNamenew FactoryInterceptorMetaClass(...)localData.precompiledEntriesSet<String> valueconvertToPaths(...)long lastModifiedScriptCacheEntry cacheEntrynew ScriptCacheEntry(...)get(...).cu/** Switches the builder's proxyBuilder during the execution of a closure.<br> ... */FactoryBuilderSupport previousProxyBuilderwithBuilder(...)Set<String> retFactoryBuilderSupport builder;/** Simple testing harness for the GSE. Enter script roots as arguments and ... */GroovyScriptEngine gsethis.buildernew GroovyScriptEngine(...)BufferedReader br/** Initialize a new GroovyClassLoader with a default or ... */GroovyClassLoader groovyClassLoadernew PrivilegedAction<ScriptClassLoader>(...) { ... }new ScriptClassLoader(...)URL root/** Get a resource connection as a <code>URLConnection</code> to retrieve a script ... */URLConnection groovyScriptConnResourceException seURL scriptURLMissingMethodException mme2Throwable rootnew ResourceException(...)IOException e1// if java did atomic blocks, this would be one// registration already done or in process, abort// write only propertyverifyInputStream(...)// read only property/** This method closes a {@link URLConnection} by getting its {@link InputStream} and calling the ... */// remove contexts created after we startedInputStream in/** The groovy script engine will run groovy scripts and reload them and ... */this.roots// set the delegate to FBS so the closure closes over the builderthis.rc//return null;//todo push through InvokerHelper.asList?// should be called on first build method only// the arguments come in like [named_args?, args..., closure?]// so peel off a hashmap from the front, and a closure from the// end and presume that is what they meant, since there is// no way to distinguish node(a:b,c,d) {..} from// node([a:b],[c,d], {..}), i.e. the user can deliberately confuse// the builder and there is nothing we can really do to prevent// that// lets register the builder as the delegate// pop the first context// first, short circuit// set the properties//noinspection unchecked// this used to be synchronized, but we also used to remove the// metaclass.  Since adding the metaclass is now a side effect, we// don't need to ensure the meta-class won't be observed and don't// need to hide the side effect.this.parentLoaderthis.groovyLoaderinitGroovyLoader(...)createRoots(...)URL[] rootsroots.length/** Get the <code>ClassLoader</code> that will serve as the parent ClassLoader of the ... *//** Get the class of the scriptName in question, so that you can instantiate ... */// attempt builder resolution// dispatch to factories if it is not a literal method// chain secondary exception// throw originalString content/** Run a script identified by name with a single argument. ... *//** Run a script identified by name with a given binding. ... *//** Creates a Script with a given scriptName and binding. ... */loadScriptByName(...)long mainEntryLastCheckentry.lastChecklong nowboolean returnValueentry.dependenciesScriptCacheEntry depEntrylong nextSourceCheckdepEntry.lastCheckdepEntry.sourceNewerdepEntry.lastModified/** Returns the GroovyClassLoader associated with this script engine instance. ... *//** sets a compiler configuration ... *///TODO: maybe do something here?// "." is used to transfer compilation dependencies, which will be// recollected later during compilation/* ignore */// remove all old entries including the "." entry// GROOVY-4013: If it is an inner class, tracking its dependencies doesn't really// serve any purpose and also interferes with the caching done to track dependencies// skip// local is kept as hard reference to avoid garbage collection// we put the old dependencies into local cache so createCompilationUnit// can pick it up. We put that entry under the name "."// this is a precompiled class!// Get the URLConnection// Now this is a bit unusual// If we didn't find anything, report on all the exceptions that occurred.// We need to get the input stream and close it to force the open// file descriptor to be released. Otherwise, we will reach the limit// for number of files open at one time.// Do nothing: We were not going to use it anyway.// getResourceConnection() opening the inputstream, let's ensure all streams are closed// check if maybe dependency was recompiled, but this one here not/* Class A depends on class B and they both are compiled once.  If class A is then ... *//** A helper class for printing indented text. This can be used stand-alone or, more commonly, from Builders. ... */int indentLevel;String indent;Writer out;boolean addNewlines;boolean autoIndent;/** Creates an IndentPrinter backed by a PrintWriter pointing to System.out, with an indent of two spaces. ... *//** Creates an IndentPrinter backed by the supplied Writer, with an indent of two spaces. ... *//** Creates an IndentPrinter backed by the supplied Writer, ... *//** Create an IndentPrinter to the given PrintWriter ... */this.addNewlinesthis.indentthis.autoIndent/** Prints a string followed by an end of line character. ... */printIndent(...)/** Prints a string. ... *//** Prints a character. ... *//** A Map.Entry implementation. *//** Prints the current indent level. */Object key;/** Prints an end-of-line character (if enabled via addNewLines property). ... */this.keythat.keythat.valuethis.indentLevel/** Helper method to handle object hashes for possibly null values */import QNameimport ListHashMapimport Stack/** A helper class for creating nested trees of Node objects for ... */new NodeBuilder(...)new Node(...)getCurrentNode(...)/** Represents an arbitrary tree node which can be used for structured metadata or any arbitrary XML-like tree. ... */Node.classNode parent;Object name;Map<> attributes;/** Creates a new Node with the same name, no parent, shallow cloned attributes ... */Object newValueNodeList nodes/** A List implementation which is returned by queries on a {@link Node} ... */NodeList.class/** Creates a new NodeList containing the same elements as the ... */NodeList resultnew NodeList(...)Object nextNode n/** Creates a new Node named <code>name</code> and if a parent is supplied, adds ... *//** Creates a new Node named <code>name</code> with value <code>value</code> and ... *//** Creates a new Node named <code>name</code> with ... */this.parentthis.attributesgetParentList(...)MetaClass newMetaClassnew DelegatingMetaClass(...) { ... }NodeList$1Object parentValuevalue(...)List<> parentListNodeList nlsetValue(...)/** Appends a child to the current node. ... */Node nodeattributes(...)/** Removes a child of the current node. ... *//** Creates a new node as a child of the current node. ... *//** Replaces the current node with nodes defined using builder-style notation via a Closure. ... */parent(...)appendNodes(...)/** Replaces the current node with the supplied node. ... */List<> tailgetTail(...)appendNode(...)/** Provides lookup of elements by non-namespaced name. ... */NodeList answerchildren(...)Object childNode childNodeint afterIndexObject temp/** Provides lookup of elements by QName. ... */NodeList temp/** Returns the text value of all of the elements in the collection. ... */String previousTextStringBuilder buffertext(...)replaceNode(...)// wrap the standard MetaClass with the delegate/** Adds sibling nodes (defined using builder-style notation via a Closure) after the current node. ... */Node childbuildChildrenFromClosure(...)NodeBuilder bNode newNode/** Extension point for subclasses to override the metaclass. The default ... */Node$1/** A helper class for creating nested trees of data */IndentPrinter out;new IndentPrinter(...)new OutputStreamWriter(...)Map<> attributesboolean hasAttributes/** Returns the textual representation of the current node and all its child nodes. ... */Collection<> collString childText/** Returns an <code>Iterator</code> of the children of the node. ... *//** Returns a <code>List</code> of the nodes children. ... *//** Returns a <code>Map</code> of the attributes of the node or an empty <code>Map</code> ... *//** Provides lookup of attributes by key. ... */printName(...)printAttributes(...)/** Returns an <code>Object</code> representing the name of the node. ... *//** Returns an <code>Object</code> representing the value of the node. ... *//** Adds or replaces the value of the node. ... *//** Returns the parent of the node. ... */printList(...)/** Adds or replaces the parent of the node. ... *//** Provides lookup of elements by non-namespaced name ... */String attributeNamedepthFirst(...)getByName(...)Object childNodeName/** Provides lookup of elements by name. ... */QName qn/** Provides a collection of all the nodes in the tree ... */depthFirstRest(...)asIterator(...)List<> childrenincrementIndent(...)decrementIndent(...)boolean firstMap<String,Object> optionsnew ListHashMap<String,Object>(...)boolean preordercallClosureForNode(...)import GStringimport MetaPropertyimport ParameterizedTypeimport Type/** A builder for creating object graphs.<br> ... */new ObjectFactory(...)new ObjectBeanFactory(...)new ObjectRefFactory(...)new HashMap<String,Class<>>(...)breadthFirst(...)breadthFirstRest(...)Stack<> stacknew Stack<>(...)List<> nextLevelChildrengetDirectChildren(...)reverse(...)List<> working/** Calls the provided closure for all the nodes in the tree ... */new ArrayList<NodeReference>(...)Stack<Tuple2<Object,Integer>> stacknew Stack<Tuple2<Object,Integer>>(...)new Tuple2<Object,Integer>(...)Pattern.CASE_INSENSITIVEString NODE_CLASS;String NODE_NAME;String OBJECT_ID;String LAZY_REF;String CLASSNAME_RESOLVER_KEY;String CLASSNAME_RESOLVER_REFLECTION;String CLASSNAME_RESOLVER_REFLECTION_ROOT;Pattern PLURAL_IES_PATTERN;// Regular expression pattern used to identify words ending in 'y' preceded by a consonantChildPropertySetter childPropertySetter;ClassNameResolver classNameResolver;IdentifierResolver identifierResolver;NewInstanceResolver newInstanceResolver;ObjectFactory objectFactory;ObjectBeanFactory objectBeanFactory;ObjectRefFactory objectRefFactory;ReferenceResolver referenceResolver;RelationNameResolver relationNameResolver;Map<String,Class<>> resolvedClasses;boolean lazyReferencesAllowed;List<NodeReference> lazyReferences;String beanFactoryName;new DefaultClassNameResolver(...)new DefaultNewInstanceResolver(...)new DefaultRelationNameResolver(...)new DefaultChildPropertySetter(...)new DefaultIdentifierResolver(...)new DefaultReferenceResolver(...)addPostNodeCompletionDelegate(...)new Closure<>(...) { ... }ObjectGraphBuilder$1Tuple2<Object,Integer> next/** Returns the list of any direct String nodes of this node. ... */List<String> answerresolveLazyReferences(...)dispose(...)/** Returns the current name of the 'bean' node. *//** Returns the current ChildPropertySetter. *//** Returns the classLoader used to load a node's class. *//** Returns the current ClassNameResolver. *//** Returns the current NewInstanceResolver. *//** Returns the current RelationNameResolver. *//** Returns true if references can be resolved lazily *//** Sets the name for the 'bean' node. */this.beanFactoryName/** Sets the current ChildPropertySetter.<br> ... */this.childPropertySetterObjectGraphBuilder selfnew ChildPropertySetter(...) { ... }Closure<> cls/** Sets the classLoader used to load a node's class. */this.classLoader/** Sets the current ClassNameResolver.<br> ... */this.classNameResolvernew ClassNameResolver(...) { ... }makeClassName(...)Map<> classNameResolverOptionsString resolverNamenew ReflectionClassNameResolver(...)/** Sets the current IdentifierResolver.<br> ... *//** Writes the node to the specified <code>PrintWriter</code>. ... */new NodePrinter(...)this.identifierResolver/** Converts the text of this GPathResult to a Integer object. ... */textIsEmptyOrNull(...)toInteger(...)new IdentifierResolver(...) { ... }/** Converts the text of this GPathResult to a Long object. ... */toLong(...)/** Converts the text of this GPathResult to a Float object. ... */toFloat(...)/** Converts the text of this GPathResult to a Double object. ... *//** Sets whether references can be resolved lazily or not. */toDouble(...)this.lazyReferencesAllowed/** Converts the text of this GPathResult to a BigDecimal object. ... *//** Sets the current NewInstanceResolver.<br> ... */this.newInstanceResolver/** Converts the text of this GPathResult to a BigInteger object. ... */new NewInstanceResolver(...) { ... }/** Sets the current ReferenceResolver.<br> ... */this.referenceResolvernew ReferenceResolver(...) { ... }// TODO Is protected static a bit of a smell?// TODO perhaps set nodeClass to be Class<? extends Node>/** Sets the current RelationNameResolver.<br> ... */this.relationNameResolver// we're probably just a StringString objectIdgetIdentifierFor(...)getReferenceFor(...)/** Strategy for setting a child node on its parent.<br> ... *//** Strategy for resolving a classname. *//** Default impl that calls parent.propertyName = child<br> ... */Object propertyimport PropertyChangeEvent/** List decorator that will trigger PropertyChangeEvents when a value changes.<br> ... */List<> delegate;PropertyChangeSupport pcs;Closure<> test;String SIZE_PROPERTY;String CONTENT_PROPERTY;/** Default impl that capitalizes the classname. */toUpperCase(...)/** Build objects using reflection to resolve class names. */String root;this.rootObject currentNodeClass<> klassthis.testnew PropertyChangeSupport(...)fireElementEvent(...)new ElementAddedEvent(...)new MultiElementAddedEvent(...)new ElementClearedEvent(...)Type typegetGenericType(...)new ElementRemovedEvent(...)new MultiElementRemovedEvent(...)new ElementUpdatedEvent(...)firePropertyChange(...)new PropertyChangeEvent(...)ParameterizedType ptypeType[] actualTypeArgumentsgetActualTypeArguments(...)Type typeArgumentint oldSizefireAddWithTest(...)actualTypeArguments.lengthNoSuchFieldException efireElementAddedEvent(...)fireSizeChangedEvent(...)List<> valuesfireMultiElementAddedEvent(...)/** Default impl, always returns 'id' *//** Default impl that calls Class.newInstance() */fireElementClearedEvent(...)new ObservableIterator(...)new ObservableListIterator(...)fireElementRemovedEvent(...)/** Default impl, always returns 'refId' *//** Default impl that returns parentName and childName accordingly. *//** Handles the common English regular plurals with the following rules. ... */boolean matchesIESRuleString childNamePluralSet<> delegateSetnew HashSet<Object>(...)/** Follow the most conventional pattern, returns the parentName ... *//** Strategy for picking the correct synthetic identifier. *//** Returns the name of the property that will identify the node.<br> ... *//** Strategy for creating new instances of a class.<br> ... *//** Create a new instance of Class klass. ... *//** Strategy for picking the correct synthetic reference identifier. *//** Returns the name of the property that references another node.<br> ... *//** Strategy for resolving a relationship property name. *//** Returns the mapping name of child -&gt; parent ... *//** Returns the mapping name of parent -&gt; child ... */NodeReference refresolveParentRelationName(...)ref.parentNameref.parentref.childNameref.refIdresolveChildRelationName(...)ObjectGraphBuilder ogbuilderString classnameresolveClassname(...)ogbuilder.classNameResolverresolveClass(...)ObjectGraphBuilder.NODE_NAMEObjectGraphBuilder.NODE_CLASSresolveInstance(...)ogbuilder.resolvedClassesogbuilder.classLoaderfireMultiElementRemovedEvent(...)Object oldValuefireElementUpdatedEvent(...)Iterator<> iterDelegate;int cursor;this.iterDelegateObservableList.thisogbuilder.newInstanceResolvergetParentContext(...)String childNameogbuilder.relationNameResolvergetListIterator(...)nextIndex(...)previousIndex(...)// observable interfaceaddPropertyChangeListener(...)getPropertyChangeListeners(...)removePropertyChangeListener(...)hasListeners(...)new ChangeType(...)ChangeType ADDED;ChangeType UPDATED;ChangeType REMOVED;ChangeType CLEARED;ChangeType MULTI_ADD;ChangeType MULTI_REMOVE;ChangeType NONE;Object oldValue;Object newValue;ogbuilder.childPropertySetterChangeType type;ObservableList.CONTENT_PROPERTYString nodenamethis.indexordinal(...)getBeanFactoryName(...)toLowerCase(...)ChangeType.ADDEDString refPropertyogbuilder.referenceResolverObject refIdChangeType.UPDATEDChangeType.REMOVEDBoolean lazyList<> values;ChangeType.oldValueChangeType.newValueisLazyReferencesAllowed(...)ChangeType.CLEAREDogbuilder.identifierResolverObjectGraphBuilder.LAZY_REFObject parentChangeType.MULTI_ADDogbuilder.lazyReferencesnew NodeReference(...)ChangeType.MULTI_REMOVEObject parent;String parentName;String childName;// GROOVY-7783 use Sets for O(1) performance for containsString refId;// GROOVY-7783 use Set for O(1) performance for containsthis.parentNamethis.childNamethis.refId// let custom factories be resolved first// set child first// set parent afterwards/* String classname = value.toString(); ... */// ignore, will try lazy reference// assume we got a true reference to the object/** Map decorator that will trigger PropertyChangeEvents when a value changes.<br> ... */Map<> delegate;String CLEARED_PROPERTY;/** Set decorator that will trigger PropertyChangeEvents when a value changes.<br> ... */Set<E> delegate;new HashSet<E>(...)this.pcsfirePropertyEvent(...)new PropertyClearedEvent(...)new PropertyAddedEvent(...)new PropertyUpdatedEvent(...)new MultiPropertyEvent(...)new ObservableIterator<E>(...)new PropertyEvent[]new PropertyRemovedEvent(...)// Map interfaceMap<> valuesfirePropertyClearedEvent(...)boolean newKeySet<E> duplicatesE eList<E> valuesnew ArrayList<E>(...)firePropertyAddedEvent(...)firePropertyUpdatedEvent(...)List<PropertyEvent> eventsnew ArrayList<PropertyEvent>(...)E elementfireMultiPropertyEvent(...)firePropertyRemovedEvent(...)ChangeType MULTI;Map<> values;ObservableMap.CLEARED_PROPERTYnew Stack<E>(...)String MULTI_PROPERTY;...[] EMPTY_PROPERTY_EVENTS;...[] events;ChangeType.MULTIevents.lengththis.eventsPropertyEvent[] copy/** A helper class for sorting objects via a closure to return the field ... */new NumberAwareComparator<Object>(...)Iterator<E> iterDelegate;Stack<E> stack;List<Closure<>> closures;boolean equalityCheck;NumberAwareComparator<Object> numberAwareComparator;ObservableSet<>.thisObservableSet<>.CONTENT_PROPERTY// GROOVY-7822 use Set for O(1) performance for containsthis.equalityCheckthis.closuresObject value1/** Systematically generate permutations. ... */...[] a;BigInteger numLeft;BigInteger total;List<E> items;/** WARNING: Don't make n too large. ... */Object value2this.items/** Dynamic groovy proxy for another object.  All method ... */Object adaptee;/** This method is for convenience. ... */import ProxyGeneratorAdapterimport GroovyCastException/** Classes to generate 'Proxy' objects which implement interfaces, ... */getFactorial(...)/** Compute factorial (TODO: expose this) ... */MetaClassHelper.EMPTY_TYPE_ARRAYBigInteger factProxyGenerator.classgetInteger(...)/** Generate next permutation (algorithm from Rosen p. 284) ... */int tempnew ProxyGenerator(...)int rint sList<E> ans...[] EMPTY_INTERFACE_ARRAY;Map<Object,Object> EMPTY_CLOSURE_MAP;Set<String> EMPTY_KEYSET;ClassLoader override;boolean emptyMethods;Integer GROOVY_ADAPTER_CACHE_DEFAULT_SIZE;ProxyGenerator INSTANCE;LRUCache<> adapterCache;/** The adapter cache is used to cache proxy classes. When, for example, a call like: ... */// TODO should we make ProxyGenerator singleton?/** Instructs <code>ProxyGenerator</code> to dump generated Groovy ... */this.debug/** Changes generated methods to have empty implementations. ... */this.emptyMethodsthis.overrideinstantiateAggregateFromBaseClass(...)Map<String,Closure<>> m// Find largest index j with a[j] < a[j+1]// Find index k such that a[k] is smallest integer// greater than a[j] to the right of a[j]// Interchange a[j] and a[k]// Put tail end of permutation after jth position in increasing order/** Base interface for customizing where resources can be found for the <code>GroovyScriptEngine</code>. *//** Retrieve a URLConnection to a script referenced by name. ... */// TODO Auto-generated constructor stubinstantiateAggregate(...)instantiateAggregateFromInterface(...)List<Class<>> interfacesimport ClassExpressionimport LogASTTransformationimport Localeimport static GeneralUtils.nullX/** This local transform adds a logging ability to your program using ... */LogASTTransformation.LoggingStrategyLogASTTransformation.AbstractLoggingStrategyV2String LOGGER_NAME;String LOGGERFACTORY_NAME;classNode(...)new MethodCallExpression(...)new ClassExpression(...)getCategoryName(...)MethodCallExpression conditionArgumentListExpression.EMPTY_ARGUMENTSLocale.ENGLISHnullX(...)Map<Object,Object> mapimport AttributeExpressionProxyGeneratorAdapter adaptercreateAdapter(...)import LoggingStrategy/** This class contains the logic of how to weave a Java Util Logging logger into the host class. */Logger.classLevel.classClassNode LOGGER_CLASSNODE;ClassNode LEVEL_CLASSNODE;AttributeExpression logLevelExpressionnew AttributeExpression(...)ArgumentListExpression argsnew ArgumentListExpression(...)new GroovyCastException(...)instantiateDelegate(...)instantiateDelegateWithBaseClass(...)String PRIORITY_NAME;/** Creates a proxy with a delegate object. ... */delegatingProxy(...)Class<>[] intfsClass<> baseSet<String> keys// log4j api is inconsistent, so trace requires special handlingboolean useDelegateCacheKey keynew CacheKey(...)Class<> bintfs.lengthString LOG_MANAGER_NAME;new ValueProvider<>(...) { ... }new ProxyGeneratorAdapter(...)ProxyGenerator$1new Comparator<Class<>>(...) { ... }String FACTORY_NAME;isTrait(...)Comparator<Class<>> INTERFACE_COMPARATOR;boolean useDelegate;Set<String> methods;ClassReference delegateClass;ClassReference baseClass;...[] interfaces;this.useDelegatethis.baseClassnew ClassReference(...)this.delegateClassthis.interfacesnew ClassReference[]interfaces.lengthClass<>[] interfacesCopyinterfacesCopy.lengththis.methodsCacheKey cacheKeycacheKey.emptyMethodscacheKey.useDelegatecacheKey.baseClasscacheKey.delegateClasscacheKey.interfacescacheKey.methodsimport GroovyLangLexerimport GroovyLexerimport AbstractActionimport Actionimport BorderFactoryimport ButtonGroupimport JButtonimport JComponentimport JFileChooserimport JFrameimport JLabelimport JPanelimport JPopupMenuimport JScrollPaneimport JSplitPaneimport JTextAreaimport JTextPaneimport JToggleButtonimport UIManagerimport WindowConstantsimport Borderimport BadLocationExceptionimport BorderLayoutimport Dimensionimport Fontimport Insetsimport ActionEventimport ActionListenerimport MouseAdapterimport MouseEventimport StringReader/** A weak reference which delegates equals and hashcode to the referent. *//** Swing application to graphically display the tokens produced by the lexer. */new JSplitPane(...)new JScrollPane(...)new HScrollableTextPane(...)new JButton(...)Class<> thisClassnew JPanel(...)new BorderLayout(...)new JTextArea(...)new JLabel(...)new HashMap<Integer,String>(...)ClassReference that// According to https://shipilev.net/blog/2016/arrays-wisdom-ancients/#_conclusion// toArray(new T[0]) seems faster, safer, and contractually cleaner, and therefore should be the default choice now.// Traits order *must* be preserved// See GROOVY-7285import Generatednew AbstractAction(...) { ... }LexerFrame$2/** Utility class for working with AnnotatedNodes */Generated.classClassNode GENERATED_TYPE;JFileChooser jfcnew JFileChooser(...)int responsemarkAsGenerated(...)showOpenDialog(...)LexerFrame.thisJFileChooser.APPROVE_OPTIONsafeScanScript(...)getSelectedFile(...)new Font(...)Font.PLAINClass<GroovyLexer> TOKEN_TYPES_CLASS;boolean shouldAnnotateisGenerated(...)addAnnotation(...)new AnnotationNode(...)Font MONOSPACED_FONT;JSplitPane jSplitPane1;JScrollPane jScrollPane1;JScrollPane jScrollPane2;JTextPane tokenPane;JButton jbutton;JPanel mainPanel;JTextArea scriptPane;JLabel tokenStreamLabel;Map<Integer,String> tokens;List<?> annots/** Constructor used when invoking as a standalone application *//** Constructor used when invoking for a specific file */jbInit(...)setSize(...)listTokens(...)JPopupMenu popupnew JPopupMenu(...)addMouseListener(...)new MouseAdapter(...) { ... }LexerFrame$1show(...)getX(...)getY(...)setDefaultCloseOperation(...)WindowConstants.DISPOSE_ON_CLOSEgetDeclaredFields(...)import SpreadExpressionimport TupleExpressionimport Queueimport Predicateimport static AnnotatedNodeUtils.isGeneratedimport static AnnotatedNodeUtils.markAsGeneratedimport static ClassHelper.isPrimitiveTypeimport static ClassHelper.isObjectTypeimport static ClassHelper.isPrimitiveBooleanimport static ArrayTypeUtils.dimensionimport static ArrayTypeUtils.elementType/** Utility class for working with ClassNodes */Object fieldValue/** Formats a type name into a human readable version. For arrays, appends "[]" to the formatted ... */ClassNode itint dim/** Return an existing method if one exists or else create a new method and mark it as {@code @Generated}. ... */getClientProperty(...)MethodNode existingMethodNode resulteof(...)select(...)int start/** Add a method and mark it as {@code @Generated}. ... */getLineStartOffset(...)getColumn(...)addMethod(...)requestFocus(...)BadLocationException exAction loadFileAction;scanScript(...)new StringReader(...)Exception ex/** Add an inner class that is marked as {@code @Generated}. ... */addClass(...)/** Add a method that is marked as {@code @Generated}. ... */ConstructorNode consNodeaddConstructor(...)/** Add methods from the super class. ... */ClassNode parentnew LinkedHashMap<String,MethodNode>(...)getDeclaredMethodsMap(...)/** Adds methods from all interfaces. Existing entries in the methods map ... */ClassNode ifaceMap<String,MethodNode> declaredMethodsEntry<String,MethodNode> entryMap<>.Entry<String,MethodNode>putIfAbsent(...)/** Gets methods from all interfaces. Methods from interfaces visited early ... */Map<String,MethodNode> methodsMapaddDeclaredMethodsFromInterfaces(...)/** Adds methods from interfaces and parent interfaces. Existing entries in the methods map take precedence. ... */List<?> cnInterfacesisObjectType(...)ClassNode[] interfaces/** Returns true if the given method has a possibly matching static method with the given name and arguments. ... */boolean foundSpreadTupleExpression tupleExpression argint nonDefaultParametershasInitialExpression(...)GroovyLangLexer lexernew GroovyLangLexer(...)/** Return true if we have a static accessor */int lineButtonGroup bggetPropNameForAccessor(...)new ButtonGroup(...)PropertyNode pNodegetStaticProperty(...)int tokenCntisPrimitiveBoolean(...)/** Returns the property name, e.g. age, given an accessor name, e.g. getAge. ... */setEditable(...)int prefixLengthsetText(...)isValidAccessorName(...)JToggleButton tokenButtonnew JToggleButton(...)nextToken(...)setFont(...)/** Detect whether the given accessor name starts with "get", "set" or "is" followed by at least one character. ... */addActionListener(...)setToolTipText(...)putClientProperty(...)setMargin(...)new Insets(...)setFocusPainted(...)insertString(...)getDocument(...)insertComponent(...)PropertyNode found/** Detect whether a static property with the given name is within the class ... */setCaretPosition(...)GroovyLangLexer.EOFPropertyNode pnBadLocationException ex1/** Detect whether a given ClassNode is a inner class (non-static). ... *//** Check if the source ClassNode is compatible with the target ClassNode */Border bordercreateEmptyBorder(...)setOrientation(...)JSplitPane.VERTICAL_SPLITimplementsInterface(...)setBorder(...)setMinimumSize(...)new Dimension(...)List<ConstructorNode> constructorsgetDeclaredConstructors(...)ConstructorNode nextBorderLayout.CENTER/** Determine if an explicit (non-generated) constructor is in the class. ... */List<ConstructorNode> declaredConstructorsConstructorNode constructorNodeBorderLayout.NORTHgetContentPane(...)JSplitPane.LEFTgetViewport(...)JSplitPane.RIGHTsetColumnHeaderView(...)setResizeWeight(...)/** Determine if the given ClassNode values have the same package name. ... */LexerFrame lexerFramesetLookAndFeel(...)getSystemLookAndFeelClassName(...)Exception ignoregetPackageName(...)/** Searches the class for a field that matches specified name. */new LexerFrame(...)new Predicate<FieldNode>(...) { ... }FileReader fileReadersetVisible(...)/** Searches the class for a field that matches specified name and test. */Queue<ClassNode> todonew ArrayDeque<ClassNode>(...)getSize(...).widthgetSize(...)getParent(...)d.width//if(e.isPopupTrigger())// create lexer// Ignoreimport ConstructorCallExpressionimport ExpressionStatementimport static Collectors.toListimport static MethodCallUtils.appendSimport static MethodCallUtils.toStringXimport static GeneralUtils.forSimport static GeneralUtils.listX/** Utility class for working with ConstructorNodes */IllegalArgumentException.classStringBuilder.classInvokerHelper.classClassNode EXCEPTION;ClassNode IMMUTABLE_TYPE;ClassNode STRINGBUILDER_TYPE;ClassNode INVOKER_TYPE;/** Return the first statement from the constructor code if it is a call to super or this, otherwise null. ... */getExpression(...)Set<ClassNode> donenew HashSet<ClassNode>(...)ConstructorCallExpression cceList<Statement> statementListgetStatements(...)ClassNode nextpoll(...)ClassNode superType// do fuzzy match for spread case: count will be number of non-spread args// handle varargs case// fuzzy match any spread to a varargs// handle parameters with default values// TODO handle spread with nonDefaultParams?// assume explicit static method call checked first so we can assume a simple check here// allow constructors added by other transforms if flagged as Generatedimport BinaryExpressionimport CastExpressionimport PropertyExpressionimport static Types.BITWISE_ANDimport static Types.BITWISE_ORimport static Types.BITWISE_XORimport static Types.DIVIDEimport static Types.LEFT_SHIFTimport static Types.MINUSimport static Types.MULTIPLYimport static Types.PLUSimport static Types.POWERimport static Types.RIGHT_SHIFTgetFirstIfSpecialConstructorCall(...)import static Types.RIGHT_SHIFT_UNSIGNEDimport static StaticTypeCheckingVisitor.inferLoopElementTypeisSpecialCall(...)isThisExpression(...)isSuperExpression(...)Expression validNames/** Determines if a type matches another type (or array thereof). ... */Parameter nameMethodCallExpression namesMethodCallExpression isNameValidisTypeOrArrayOfType(...)Expression sbExpression toStringtoStringX(...)/** Determines if a type is derived from Number (or array thereof). ... */Statement errorBlockappendS(...)ClassHelper.Number_TYPEisNumberOrArrayOfNumber(...)forS(...)listX(...)...[] HANDLED_TYPES;/** Converts expressions like ConstantExpression(40) + ConstantExpression(2) ... */ClassNode wrapperTypegetWrapper(...)getOperation(...)Expression lefttransformInlineConstants(...)getLeftExpression(...)Expression rightgetRightExpression(...)Object leftVconfigure(...)int typeExpression leftXExpression rightXboolean isShiftNumber leftsafeNumber(...)Number rightNumber resultrightShiftUnsigned(...)and(...)or(...)xor(...)power(...)isWrapperInteger(...)isWrapperByte(...)byteValue(...)isWrapperLong(...)isWrapperShort(...)shortValue(...)isWrapperFloat(...)floatValue(...)isWrapperDouble(...)isWrapperCharacter(...)/** Transforms constants that would appear in annotations so they aren't lost. ... */PropertyExpression pegetObjectExpression(...)ClassNode clazzgetPropertyAsString(...)isEnum(...)isNumberType(...)BinaryExpression beExpression lhsExpression rhsisStringType(...)setLeftExpression(...)setRightExpression(...)new Function<PropertyNode,ConstantExpression>(...) { ... }List<Expression> listListIterator<Expression> it// handle blocks of blocksExpression e/** Converts simple expressions of constants into pre-evaluated simple constants. ... */isPrimaryClassNode(...)FieldNode fngetTypeClass(...)redirect(...)ConstantExpression ceVariableExpression vegetAccessedVariable(...)ClassNode targetTypeInteger integerBigDecimal decimaltransformBinaryConstantExpression(...)transformListOfConstants(...)/** Given a list of constants, transform each item in the list. ... */ListExpression newListboolean changedinferLoopElementType(...)Expression transformedException ignoredassert ...// GROOVY-9336// GROOVY-10068, et al.: retain field's type// TODO: Boolean, Character, String// GROOVY-9855: inline string concat// ignore, leave property expression in place and we'll report laterimport static GeneralUtils.isNullX/** Utility class for commonly called methods */MethodCallExpression appendMethodCallExpression toStringisNullX(...)import ImmutableOptionsimport ArrayExpressionimport ReflectionMethodInvokerDate.classReflectionMethodInvoker.classImmutableOptions.classimport static BeanUtils.decapitalizeimport static ClassHelper.isPrimitiveVoid/** Utility class for working with MethodNodes *//** Return the method node's descriptor including its ... */Parameter pformatTypeName(...)/** Return the method node's descriptor which includes its return type, ... */methodDescriptor(...)int nParametersString prettyName/** For a method node potentially representing a property, returns the name of the property. ... */ClassNode DATE_TYPE;ClassNode REFLECTION_INVOKER_TYPE;Class<? extends Annotation> IMMUTABLE_OPTIONS_CLASS;ClassNode IMMUTABLE_OPTIONS_TYPE;String MEMBER_KNOWN_IMMUTABLE_CLASSES;int nameLengthString MEMBER_KNOWN_IMMUTABLES;Set<String> BUILTIN_IMMUTABLES;/* Currently leaving BigInteger and BigDecimal in list but see: ... */Set<String> BUILTIN_IMMUTABLE_ANNOTATIONS;Expression smcenew ArrayExpression(...)isPrimitiveVoid(...)prettyTypeName(...)/** Gets the code for a method (or constructor) as a block. ... */builtinOrDeemedType(...)/** Check if the {@link MethodNode} instance is getter candidate ... */getGenericsTypes(...).lengthGenericsType optionalTypeisPlaceholder(...)isWildcard(...)ClassNode valueTypehasImmutableAnnotation(...)isBuiltinImmutable(...)/* && isPrimitiveVoid(mNode.getReturnType()) *//* || isWrapperBoolean(mNode.getReturnType()) */AnnotationNode nextimport VisibilityOptionsmatchingImmutableMarkerName(...)import static Opcodes.ACC_PROTECTEDAnnotation[] annotationsVisibilityOptions.classClassNode VISIBILITY_OPTIONS_TYPE;/** Determine the correct modifiers by looking for a potential @VisibilityOptions annotation. ... */String visIdVisibility visAnnotation nextannotationType(...)getVisForAnnotation(...)AnnotationNode visAnnoVisibility.UNDEFINEDgetModifier(...)Map<String,Expression> visMembersString idConstructorNode.classgetVisibility(...)MethodNode.classImmutablePropertyUtils.IMMUTABLE_OPTIONS_TYPEClassNode.classList<String> immutablesimport MetaClassImplimport SwitchPoint/** The one and only implementation of a meta class. ... */new SwitchPoint(...)SwitchPoint switchPoint;MetaClassImpl impl;//TODO Joche: replace with real implementation// TODO Jochen: replace with new MetaMethodListExpression listExpression/** Backport of Java8 Function. ... */Expression listItemExpressioncheckPropertyList(...)List<String> immutableClasses//"javax.annotation.concurrent.Immutable", // its RetentionPolicy is CLASS, can not be got via reflection// supported by Findbugs and IntelliJ IDEAimport MethodType/** This class represents a reference to the most actual incarnation of a Metaclass. ... */new PrivilegedExceptionAction<MethodHandle>(...) { ... }findSpecial(...)ReevaluatingReference<>.classmethodType(...)PrivilegedActionException eMethodHandle FALLBACK_HANDLE;/** Backport of Java8 Supplier. ... */Supplier<T> valueSupplier;Function<T,SwitchPoint> validationSupplier;WeakReference<Class<T>> clazzRef;MethodHandle returnRef;this.valueSupplierthis.validationSuppliernew WeakReference<Class<T>>(...)replacePayLoad(...)T payloadMethodHandle refconstant(...)SwitchPoint spguardWithTest(...)T refThrowable throwable//TODO Jochen: move the findSpecial to a central place together with others to easy security configuration/** Allows to throw a checked exception unchecked. ... */thrownInsteadOf(...)char ZERO;/** Copied from https://github.com/apache/commons-io/blob/master/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java ... */StringBuilder builder;/** Constructs a new {@link StringBuilder} instance with default capacity. *//** Constructs a new {@link StringBuilder} instance with the specified capacity. ... *//** Constructs a new instance with the specified {@link StringBuilder}. ... *//** Appends a single character to this Writer. ... *//** Appends a character sequence to this Writer. ... *//** Appends a portion of a character sequence to the {@link StringBuilder}. ... *//** Closing this writer has no effect. *//** Flushing this writer has no effect. *//** Writes a String to the {@link StringBuilder}. ... *//** Writes a portion of a character array to the {@link StringBuilder}. ... */import Lookupimport AtomicReference/** Returns the underlying builder. ... *//** Returns {@link StringBuilder#toString()}. ... *//** Helper for {@link groovy.lang.GroovyObject} ... */// no-opnew ClassValue<AtomicReference<Lookup>>(...) { ... }GroovyObjectHelper$1new AtomicReference<Lookup>(...)import static ElementType.ANNOTATION_TYPEimport static ElementType.CONSTRUCTORimport static ElementType.FIELDimport static ElementType.METHODimport static ElementType.PACKAGEimport static ElementType.PARAMETERimport static ElementType.TYPEimport static RetentionPolicy.RUNTIME/** Annotation to indicate experimental and still to be refined API, which may change at any time *//** Get the {@link Lookup} instance of the {@link GroovyObject} instance ... */Class<? extends GroovyObject> groovyObjectClassAtomicReference<Lookup> lookupAtomicRefempty(...)import MetaClassConstantimport ReevaluatingReference/** A MetaClass within Groovy defines the behaviour of any given Groovy or Java class */ReevaluatingReference<MetaClassConstant<T>> implRef;this.implRefgetPayload(...)isMemberClass(...)/** A Realm is the representation of a metaclass layer in a tree of realm objects. */new ClassValue<MetaClassConstant<?>>(...) { ... }Realm$1new MetaClassConstant<>(...)new Realm(...)Realm ROOT;Realm parent;ClassValue<MetaClassConstant<?>> cv;Supplier<MetaClassConstant<T>> valueSuppliernew Supplier<MetaClassConstant<T>>(...) { ... }Function<MetaClassConstant<T>,SwitchPoint> validationSuppliernew Function<MetaClassConstant<T>,SwitchPoint>(...) { ... }getSwitchPoint(...)ReevaluatingReference<MetaClassConstant<T>> refnew ReevaluatingReference<MetaClassConstant<T>>(...)MetaClassConstant<>.classnew MetaClass<T>(...)List<Class<?>> classListnew ArrayList<Class<?>>(...)/** Because antlr4 does not support generating lexer with specified interface, ... */Lookup callerClass<?> clazzisNonStaticInnerClass(...)doLookup(...)isAnonymousClass(...)findGetLookupMethod(...)String GET_LOOKUP_METHOD_NAME;Lookup LOOKUP;Lookup NULL_LOOKUP;ClassValue<AtomicReference<Lookup>> LOOKUP_MAP;import ParserPluginimport Reduction/** A parser plugin for the new parser. */canReopenSource(...)setSource(...)new StringReaderSource(...)AstBuilder buildernew AstBuilder(...)isGroovydocEnabled(...)isRuntimeGroovydocEnabled(...)buildAST(...)import ParserPluginFactory/** A parser plugin factory for the new parser. */new Antlr4ParserPlugin(...)import Parser/** Because antlr4 does not support generating parser with specified interface, ... */import CharStreamsimport LexerNoViableAltExceptionimport ATNimport LexerATNSimulatorimport LexerAtnManager/** The lexer for Groovy programming language, which is based on the lexer generated by Antlr4 */fromReader(...)setInterpreter(...)new PositionAdjustingLexerATNSimulator(...)getATN(...)LexerAtnManager.INSTANCEresetAcceptPosition(...)seek(...)this.charPositionInLine// if some lexical error occurred, stop parsing!import FailedPredicateExceptionimport ParserATNSimulatorimport ParserAtnManager/** The parser for Groovy programming language, which is based on the parser generated by Antlr4 */boolean GROOVY_PARSER_PROFILING_ENABLED;ParserAtnManager.INSTANCEsetProfile(...)new LightWeightFailedPredicateException(...)// `FailedPredicateException` is used to change the control flow,// so its stack trace can be eliminated for better performanceimport Tuple3import CompileStaticimport NonSealedimport Sealedimport Traitimport ANTLRErrorListenerimport CommonTokenStreamimport ParserRuleContextimport RecognitionExceptionimport Recognizerimport PredictionModeimport Intervalimport ParseCancellationExceptionimport ParseTreeimport TerminalNodeimport AdditiveExprAltContextimport AndExprAltContextimport AnnotatedQualifiedClassNameContextimport AnnotationContextimport AnnotationNameContextimport AnnotationsOptContextimport AnonymousInnerClassDeclarationContextimport ArgumentsContextimport ArrayInitializerContextimport AssertStatementContextimport AssignmentExprAltContextimport BlockContextimport BlockStatementContextimport BlockStatementsContextimport BlockStatementsOptContextimport BooleanLiteralAltContextimport BreakStatementContextimport BuiltInTypeContextimport CastExprAltContextimport CastParExpressionContextimport CatchClauseContextimport CatchTypeContextimport ClassBodyContextimport ClassBodyDeclarationContextimport ClassDeclarationContextimport ClassNameContextimport ClassOrInterfaceModifierContextimport ClassOrInterfaceModifiersContextimport ClassOrInterfaceModifiersOptContextimport ClassOrInterfaceTypeContextimport ClassicalForControlContextimport ClosureContextimport ClosureOrLambdaExpressionContextimport CommandArgumentContextimport CommandExprAltContextimport CommandExpressionContextimport CompactConstructorDeclarationContextimport CompilationUnitContextimport ConditionalExprAltContextimport ConditionalStatementContextimport ContinueStatementContextimport CreatedNameContextimport CreatorContextimport DimContextimport DoWhileStmtAltContextimport DynamicMemberNameContextimport ElementValueArrayInitializerContextimport ElementValueContextimport ElementValuePairContextimport ElementValuePairsContextimport ElementValuesContextimport EmptyDimsContextimport EmptyDimsOptContextimport EnhancedArgumentListElementContextimport EnhancedArgumentListInParContextimport EnhancedForControlContextimport EnhancedStatementExpressionContextimport EnumConstantContextimport EnumConstantsContextimport EqualityExprAltContextimport ExclusiveOrExprAltContextimport ExpressionContextimport ExpressionInParContextimport ExpressionListContextimport ExpressionListElementContextimport FieldDeclarationContextimport FinallyBlockContextimport FloatingPointLiteralAltContextimport ForControlContextimport ForInitContextimport ForStmtAltContextimport ForUpdateContextimport FormalParameterContextimport FormalParameterListContextimport FormalParametersContextimport GroovyParserRuleContextimport GstringContextimport GstringPathContextimport GstringValueContextimport IdentifierContextimport IdentifierPrmrAltContextimport IfElseStatementContextimport ImportDeclarationContextimport InclusiveOrExprAltContextimport IndexPropertyArgsContextimport IntegerLiteralAltContextimport KeywordsContextimport LabeledStmtAltContextimport LambdaBodyContextimport ListContextimport LocalVariableDeclarationContextimport LogicalAndExprAltContextimport LogicalOrExprAltContextimport LoopStmtAltContextimport MapContextimport MapEntryContextimport MapEntryLabelContextimport MapEntryListContextimport MemberDeclarationContextimport MethodBodyContextimport MethodDeclarationContextimport MethodNameContextimport ModifierContextimport ModifiersContextimport ModifiersOptContextimport MultipleAssignmentExprAltContextimport MultiplicativeExprAltContextimport NamePartContextimport NamedPropertyArgsContextimport NewPrmrAltContext/** Represents a syntax error of groovy program */import NonWildcardTypeArgumentsContextint LEXER;import NullLiteralAltContextimport PackageDeclarationContextimport ParExpressionContextimport PathElementContextint PARSER;import PathExpressionContextimport PostfixExpressionContextimport PowerExprAltContextimport PrimitiveTypeContextimport QualifiedClassNameContextimport QualifiedClassNameListContextimport QualifiedNameContextimport QualifiedNameElementContextimport QualifiedStandardClassNameContextint source;import RegexExprAltContextimport RelationalExprAltContextimport ResourceContextimport ResourceListContextimport ResourcesContextimport ReturnStmtAltContextimport ReturnTypeContextimport ScriptStatementsContextimport ShiftExprAltContextimport StandardLambdaExpressionContextimport StandardLambdaParametersContextimport StatementContextimport StringLiteralContextimport SuperPrmrAltContextimport SwitchBlockStatementGroupContextimport SwitchLabelContextimport SwitchStatementContextimport SynchronizedStmtAltContextimport ThisFormalParameterContextimport ThisPrmrAltContextimport ThrowStmtAltContextimport TryCatchStatementContextimport TypeArgumentContextimport TypeArgumentsContextimport TypeArgumentsOrDiamondContextimport TypeBoundContextimport TypeContextimport TypeDeclarationContextimport TypeListContextimport TypeNamePairContextimport TypeNamePairsContextimport TypeParameterContextimport TypeParametersContextimport UnaryAddExprAltContextimport UnaryNotExprAltContextimport VariableDeclarationContextimport VariableDeclaratorContextimport VariableDeclaratorIdContextimport VariableDeclaratorsContextimport VariableInitializerContextimport VariableInitializersContextimport VariableModifierContextimport VariableModifiersContextimport VariableModifiersOptContextimport VariableNamesContextimport WhileStmtAltContextimport DescriptiveErrorStrategyimport AtnManagerimport StringUtilsimport EnumHelperimport CodeVisitorSupportimport EnumConstantClassNodeimport ModifierNodeimport PackageNodeimport AnnotationConstantExpressionimport BitwiseNegationExpressionimport BooleanExpressionimport ClosureListExpressionimport DeclarationExpressionimport ElvisOperatorExpressionimport EmptyExpressionimport GStringExpressionimport LambdaExpressionimport MapEntryExpressionimport MethodPointerExpressionimport MethodReferenceExpressionimport NamedArgumentListExpressionimport NotExpressionimport PostfixExpressionimport PrefixExpressionimport RangeExpressionimport SpreadMapExpressionimport TernaryExpressionimport UnaryMinusExpressionimport UnaryPlusExpressionimport AssertStatementimport BreakStatementimport CaseStatementimport CatchStatementimport ContinueStatementimport DoWhileStatementimport ForStatementimport IfStatementimport ReturnStatementimport SwitchStatementimport SynchronizedStatementimport ThrowStatementimport TryCatchStatementimport WhileStatementimport ClosureUtilsimport SyntaxErrorMessageimport Numbersimport Collectorsimport Streamimport static GroovyLangParser.ARROWimport static GroovyLangParser.SwitchBlockStatementExpressionGroupContextimport static GroovyLangParser.SwitchExprAltContextimport static GroovyLangParser.SwitchExpressionContextimport static GroovyLangParser.SwitchExpressionLabelContextimport static GroovyLangParser.YieldStatementContextimport static GroovyLangParser.YieldStmtAltContextimport static GroovyParser.ADDimport static GroovyParser.ASimport static GroovyParser.CASEimport static GroovyParser.DECimport static GroovyParser.DEFimport static GroovyParser.DEFAULTimport static GroovyParser.FINALimport static GroovyParser.GEimport static GroovyParser.GTimport static GroovyParser.INimport static GroovyParser.INCimport static GroovyParser.INSTANCEOFimport static GroovyParser.LEimport static GroovyParser.LTimport static GroovyParser.NON_SEALEDimport static GroovyParser.NOT_INimport static GroovyParser.NOT_INSTANCEOFimport static GroovyParser.PRIVATEimport static GroovyParser.RANGE_EXCLUSIVE_FULLimport static GroovyParser.RANGE_EXCLUSIVE_LEFTimport static GroovyParser.RANGE_EXCLUSIVE_RIGHTimport static GroovyParser.RANGE_INCLUSIVEimport static GroovyParser.SAFE_INDEXimport static GroovyParser.SEALEDimport static GroovyParser.STATICimport static GroovyParser.SUBimport static GroovyParser.VARimport static PositionConfigureUtils.configureASTimport static GeneralUtils.cloneParamsimport static GeneralUtils.closureXimport static TypeUtil.isPrimitiveTypeimport static DefaultGroovyMethods.asBooleanimport static DefaultGroovyMethods.lastimport Groovydocimport GroovydocHolderimport static StringUtils.matches/** A utilities for managing groovydoc, e.g. ... */GroovydocHolder<>.DOC_COMMENTString GROOVYDOC_PREFIX;String RUNTIME_GROOVYDOC_PREFIX;String VALUE;Pattern SPACES_PATTERN;boolean groovydocEnabled, ...;this.groovydocEnabledthis.runtimeGroovydocEnabled/** Attach doc comment to member node as meta data */GroovyParser.GroovyParserRuleContextString docCommentNodeTextfindDocCommentByNode(...)attachDocCommentAsMetaData(...)attachGroovydocAnnotation(...)/* Attach doc comment to member node as meta data */putNodeMetaData(...)new Groovydoc(...)/* Attach Groovydoc annotation to the target element */AnnotatedNode annotatedNodeAnnotationNode annotationNodeGroovydoc.classParserRuleContext parentContextboolean sameTypeNodeBeforeParseTree childparentContext.childrenList<? extends TerminalNode> nlListNL(...)int nlListSize/** Builds the AST from the parse tree generated by Antlr4. */new LinkedList<ClassNode>(...)// if no doc comment node found and no siblings of same type before the node,// try to find doc comment node of its parent// e.g. ClassBodyDeclarationContext == ClassBodyDeclarationContext// doc comments are treated as NL// The exception should never be thrown!import static GroovyLangParser.ABSTRACTimport static GroovyLangParser.FINALimport static GroovyLangParser.NATIVEimport static GroovyLangParser.STATICimport static GroovyLangParser.VOLATILE/** Process modifiers for AST nodes */Map<Class<>,List<Integer>> INVALID_MODIFIERS_MAP;AstBuilder astBuilder;List<ModifierNode> modifierNodeList;this.astBuilderthis.modifierNodeListnew ArrayDeque<List<InnerClassNode>>(...)Map<ModifierNode,Integer> modifierNodeCounternew LinkedHashMap<ModifierNode,Integer>(...)new ArrayDeque<GroovyParserRuleContext>(...)ClassHelper.double_TYPEClassHelper.float_TYPEClassHelper.short_TYPEClassHelper.byte_TYPEClassHelper.char_TYPEClassHelper.boolean_TYPEint visibilityModifierCntgetIntegerSafe(...)ModifierNode modifierNodeInteger cntisRepeatable(...)createParsingFailedException(...)isVisibilityModifier(...)new Consumer<ModifierNode>(...) { ... }CharStream charStreamcreateCharStream(...)this.sourceUnitthis.moduleNodenew ModuleNode(...)this.lexerthis.parsernew GroovyLangParser(...)new CommonTokenStream(...)setErrorHandler(...)new DescriptiveErrorStrategy(...)this.groovydocManagernew GroovydocManager(...)this.tryWithResourcesASTTransformationnew TryWithResourcesASTTransformation(...)getReader(...)GroovyParserRuleContext resultAtnManager.READ_LOCKTokenStream tokenStreambuildCST(...)PredictionMode.LLPredictionMode.SLLconvertException(...)setPredictionMode(...)removeErrorListeners(...)addErrorListeners(...)compilationUnit(...)CompilationFailedException cfevisit(...)ASTNode nodeStatement stmtgetDeclarationStatements(...)ClassNode nodethis.classNodeListisPackageInfoDeclaration(...)ClassNode packageInfoisBlankScript(...)ReturnStatement.RETURN_NULL_OR_VOIDconfigureScriptClassNode(...)this.numberFormatError// t    1: class modifiers value; 2: class member modifiers valuegetOpcode(...)containsVisibilityModifier(...)calcModifiersOpValue(...)new Predicate<ModifierNode>(...) { ... }isAnnotation(...)new Function<ModifierNode,AnnotationNode>(...) { ... }getAnnotationNode(...)anyMatch(...)int modifierTypefindFirst(...)isNonVisibilityModifier(...)Opcodes.ACC_PROTECTEDOpcodes.ACC_PRIVATEclearVisibilityModifiers(...)new Consumer<AnnotationNode>(...) { ... }/* , TRANSIENT */// Transient is left open for properties for legacy reasons but should be removed before ClassCompletionVerifier runs (CLASSGEN)// local variable does not attach annotationsPositionInfo thatnew Function<? extends ScriptStatementContext,ASTNode>(...) { ... }that.linethat.columnPackageNode packageNodesetPackageName(...)addAnnotations(...)configureAST(...)ImportNode importNodeboolean hasStaticSTATIC(...)boolean hasStarMUL(...)boolean hasAliasctx.aliasList<AnnotationNode> annotationNodeListString qualifiedNameaddStaticStarImport(...)last(...)getStaticStarImports(...)import static GroovyParser.ASSIGNimport static GroovyParser.BuiltInPrimitiveTypeimport static GroovyParser.CapitalizedIdentifierimport static GroovyParser.DOTimport static GroovyParser.ExpressionContextimport static GroovyParser.Identifierimport static GroovyParser.LBRACKimport static GroovyParser.LPARENimport static GroovyParser.PathExpressionContextimport static GroovyParser.PostfixExprAltContextimport static GroovyParser.PostfixExpressionContextimport static GroovyParser.StringLiteralimport static GroovyParser.YIELD/** Some semantic predicates for altering the behaviour of the lexer and parser */sorted(...)mapToInt(...)List<? extends QualifiedNameElementContext> identifierListint identifierListSizelimit(...)ModifierNode.MODIFIER_OPCODE_MAPnew Function<? extends QualifiedNameElementContext,String>(...) { ... }addStaticImport(...)getStaticImports(...)addStarImport(...)getStarImports(...)new ToIntFunction<Integer>(...) { ... }Pattern NONSPACES_PATTERN;Pattern LETTER_AND_LEFTCURLY_PATTERN;Pattern NONSURROGATE_PATTERN;Pattern SURROGATE_PAIR1_PATTERN;Pattern SURROGATE_PAIR2_PATTERN;addImport(...)int c// statement { -------------------------------------------------------------Expression conditionExpressionctx.ceBooleanExpression booleanExpressionnew BooleanExpression(...)CharStream.EOFAssertStatement resultnew AssertStatement(...)ctx.meBinaryExpression binaryExpressionint c1Types.ASSIGNString str1int c2String str2Statement ifBlockunpackStatement(...)/** Check whether following a method name of command expression. ... */ctx.tbStatement elseBlockELSE(...)List<ParseTree> peacChildrenctx.fb(...).childrennew IfStatement(...)Statement resultParseTree peacChildTuple2<Parameter,Expression> controlTupleStatement loopBlocknew ForStatement(...)EmptyExpression.INSTANCEDeclarationListStatement declarationListStatementList<DeclarationExpression> declarationExpressionsgetDeclarationExpressions(...)List<ParseTree> pecChildrennew ClosureListExpression(...)ParseTree pecChildtranslateExpressionList(...)PathExpressionContext pecint tpec.t/** Distinguish between method declaration and method call/constructor declaration */List<Expression> expressionList...[] MODIFIER_ARRAY;/** Distinguish between local variable declaration and method call, e.g. `a b` */int tokenType2int tokenType3int nextCodePointcodePointAt(...)int tokeTypeN// single $ is not a valid identifier// VOID == tokenType ||ModifierManager modifierManagernew ModifierManager(...)processParameter(...)ClosureListExpression closureListExpressionForStatement.FOR_LOOP_DUMMYTuple2<BooleanExpression,Statement> conditionAndBlockcreateLoopConditionExpressionAndBlock(...)new WhileStatement(...)new DoWhileStatement(...)boolean resourcesExistsboolean catchExistsboolean finallyExistsTryCatchStatement tryCatchStatementnew TryCatchStatement(...)new Consumer<ExpressionStatement>(...) { ... }addResource(...)reduce(...)new LinkedList<CatchStatement>(...)new Function<? extends CatchClauseContext,List<CatchStatement>>(...) { ... }new BinaryOperator<List<CatchStatement>>(...) { ... }import Tuple/** A SyntaxErrorReportable is a recognizer that can report syntax error */new Consumer<CatchStatement>(...) { ... }addCatch(...)transform(...)Tuple2<Integer,Integer> NO_OFFSET;throwSyntaxError(...)PositionInfo positionInfogenPositionInfo(...)new GroovySyntaxError(...)getSyntaxErrorSource(...)new PositionInfo(...)getErrorLine(...)new Function<? extends ResourceContext,ExpressionStatement>(...) { ... }List<ExpressionStatement> declarationStatementsboolean isVariableDeclarationboolean isVariableAccessBinaryExpression assignmentExpressiontransformResourceAccess(...)new ExpressionStatement(...)new DeclarationExpression(...)new VariableExpression(...)/** Multi-catch(1..*) clause will be unpacked to several normal catch clauses, so the return type is List ... */getErrorColumn(...)import static GeneralUtils.ASSIGNimport static GeneralUtils.binXimport static GeneralUtils.catchSimport static GeneralUtils.notNullXimport static GeneralUtils.tryCatchSnew Function<ClassNode,CatchStatement>(...) { ... }/** Transform try-with-resources to try-catch-finally ... */int resourceCount;int throwableCount;int primaryExCount;int suppressedExCount;new CatchStatement(...)dynamicType(...)getResourceStatements(...)isBasicTryWithResourcesStatement(...)transformBasicTryWithResourcesStatement(...)transformExtendedTryWithResourcesStatement(...)getCatchStatements(...)getFinallyStatement(...)Expression targetExpressionVariableExpression variableExpression/** Transforms: ... */TryCatchStatement newTryWithResourcestryCatchS(...)getTryStatement(...)TryCatchStatement newTryCatchFinallyBlockStatement blockStatementExpressionStatement firstResourceDeclarationgetResourceStatement(...)new Function<? extends QualifiedClassNameContext,ClassNode>(...) { ... }String primaryExceptionNamenextPrimaryExName(...)String firstResourceIdentifiercreateFinallyBlockForNewTryCatchStatement(...)makeVariableDeclarationFinal(...)createBlockStatement(...)ClassHelper.THROWABLE_TYPEskip(...)SwitchStatement resultnew LinkedList<Statement>(...)createCatchBlockForOuterNewTryCatchStatement(...)String throwableNamenextThrowableName(...)Parameter catchParametercatchS(...)String suppressedExceptionNamenextSuppressedExName(...)TryCatchStatement newTryCatchcreateCloseResourceStatement(...)createAddSuppressedStatement(...)notNullX(...)MethodCallExpression closeMethodCallExpressionsetSafe(...)MethodCallExpression addSuppressedMethodCallExpression/** See https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html ... */binX(...)nextResourceName(...)new Function<? extends SwitchBlockStatementGroupContext,List<Statement>>(...) { ... }/* try ResourceSpecification ... *//* try { ... */// final VariableModifiers_minus_final R Identifier = Expression;// Throwable #primaryException = null;// Block// close resource and propagate throwable(s)// 2nd, 3rd, ..., n'th resources declared in resources// transform remaining resources// catch (Throwable #t) {// #primaryException = #t;// throw #t;// if (#primaryException != null)// try { #resource?.close() } catch (Throwable #suppressed) { #primary.addSuppressed(#suppressed) }// else #resource?.close()import BailErrorStrategyimport InputMismatchExceptionimport NoViableAltException/** Provide friendly error messages when parsing errors occurred. */CharStream charStream;this.charStreamParserRuleContext contextcontext.exceptionnew BinaryOperator<List<Statement>>(...) { ... }getPredictionMode(...)List<CaseStatement> caseStatementListnew LinkedList<CaseStatement>(...)reportNoViableAlternative(...)reportInputMismatch(...)reportFailedPredicate(...)new ParseCancellationException(...)new InputMismatchException(...)TokenStream tokensString inputgetStartToken(...)getStartIndex(...)getStopIndex(...)getOffendingToken(...)escapeWSAndQuote(...)notifyErrorListeners(...)createNoViableAlternativeErrorMessage(...)getTokenErrorDisplay(...)createInputMismatchErrorMessage(...)createFailedPredicateErrorMessage(...)// stop parsingList<Statement> defaultStatementListint defaultStatementListSizenew Consumer<Statement>(...) { ... }isTrue(...)import AtomicLong/** Manage ATN to avoid memory leak */long tgetLongSafe(...)new SwitchStatement(...)ReentrantReadWriteLock RRWL;ReentrantReadWriteLock.WriteLock WRITE_LOCK;ReentrantReadWriteLock.WriteLockReentrantReadWriteLock.ReadLock READ_LOCK;ReentrantReadWriteLock.ReadLockString DFA_CACHE_THRESHOLD_OPT;long DFA_CACHE_THRESHOLD;new AtomicLong(...)int labelCntATN atn;AtomicLong counter;this.atnshouldClearDfaCache(...)clearDFA(...)List<Token> firstLabelHoldernew ArrayList<Token>(...)/** Manage ATN for lexer to avoid memory leak */new AtnWrapper(...)AtnManager.AtnWrapperGroovyLangLexer._ATNnew LexerAtnManager(...)String GROOVY_CLEAR_LEXER_DFA_CACHE;boolean TO_CLEAR_LEXER_DFA_CACHE;AtnWrapper lexerAtnWrapper;LexerAtnManager INSTANCE;checkAndClear(...)import GroovyLangParser/** Manage ATN for parser to avoid memory leak */GroovyLangParser._ATNnew ParserAtnManager(...)AtnWrapper parserAtnWrapper;ParserAtnManager INSTANCE;new Function<? extends SwitchLabelContext,Object>(...) { ... }new BinaryOperator<Object>(...) { ... }Tuple2<Token,Expression> tupleboolean isLastnew CaseStatement(...)CASE(...)getSymbol(...)DEFAULT(...)new SynchronizedStatement(...)GroovyParserRuleContext gprcnew ReturnStatement(...)new ThrowStatement(...)addStatementLabel(...)String labelnew BreakStatement(...)ReturnStatement returnStatementnew ContinueStatement(...)/** <pre> ... */List<Tuple3<List<Statement>,Boolean,Boolean>> statementInfoListnew Function<? extends SwitchBlockStatementExpressionGroupContext,Tuple3<List<Statement>,Boolean,Boolean>>(...) { ... }Boolean isArrownew Function<Tuple3<List<Statement>,Boolean,Boolean>,List<Statement>>(...) { ... }String variableNameStatement declarationStatementSwitchStatement switchStatementMethodCallExpression callClosureclosureX(...)validateSwitchExpressionLabels(...)LBRACE(...)noneMatch(...)new Predicate<Tuple3<List<Statement>,Boolean,Boolean>>(...) { ... }Boolean hasYieldOrThrowStatementgetV3(...)int switchExpressionVariableSeq;int[] arrowCntHolderboolean[] isArrowHoldernew boolean[]boolean[] hasResultStmtHolderList<Statement> resultnew Function<? extends SwitchExpressionLabelContext,Object>(...) { ... }Tuple3<Token,List<Expression>,Integer> tupleboolean isArrowBlockStatement codeBlockList<Statement> statementsint statementsCntStatement exprOrBlockStatementboolean[] hasYieldHolderboolean[] hasThrowHoldernew CodeVisitorSupport(...) { ... }AstBuilder$1visitReturnStatement(...)List<Statement> branchStatementListExpression resultExprExpression exprMap<String,List<SwitchExpressionLabelContext>> acMapflatMap(...)groupingBy(...)new Function<? extends SwitchBlockStatementExpressionGroupContext,Stream<? extends ? extends SwitchExpressionLabelContext>>(...) { ... }new Function<SwitchExpressionLabelContext,String>(...) { ... }e.acList<SwitchExpressionLabelContext> lastSelcListnew BinaryOperator<List<SwitchExpressionLabelContext>>(...) { ... }get(...).acInteger acTypectx.ac// } statement -------------------------------------------------------------isUsingGenerics(...)setUsingGenerics(...)ClassNode anInterfaceboolean isAnnotationAT(...)boolean isEnumENUM(...)boolean isInterfaceINTERFACE(...)List<ModifierNode> modifierNodeListgetNodeMetaData(...)Optional<ModifierNode> finalModifierNodeOptionalOptional<ModifierNode> sealedModifierNodeOptionalOptional<ModifierNode> nonSealedModifierNodeOptionalboolean isFinalisPresent(...)boolean isSealedboolean isNonSealedboolean isRecordRECORD(...)boolean hasRecordHeaderboolean hasPermitsPERMITS(...)getClassModifiersOpValue(...)boolean syntheticPublicClassNode outerClassboolean isInterfaceWithDefaultMethodscontainsDefaultMethods(...)EXTENDS(...)IMPLEMENTS(...)ModifierNode mnmakeEnumNode(...)Opcodes.ACC_STATICnew ClassNode(...)setSyntheticPublic(...)AnnotationNode sealedAnnotationNodemakeCached(...)Sealed.classctx.psListExpression permittedSubclassesListExpressionnew Function<ClassNode,ClassExpression>(...) { ... }setNodeMetaData(...)NonSealed.classTRAIT(...)Trait.classCLASS(...)ctx.scsClassNode[] scsscs.lengthsetSuperClass(...)setInterfaces(...)ctx.isinitUsingGenerics(...)Opcodes.ACC_ABSTRACThackMixins(...)transformRecordHeaderToProperties(...)Opcodes.ACC_ANNOTATIONaddInterface(...)ClassHelper.Annotation_TYPEOptional<FieldNode> fieldNodeOptionalhandle(...)FormalParameterContext parameterCtxModifierManager parameterModifierManagerClassNode originTypedeclareProperty(...)List<MethodDeclarationContext> methodDeclarationContextListnew LinkedList<MethodDeclarationContext>(...)new Function<? extends ClassBodyDeclarationContext,MemberDeclarationContext>(...) { ... }new Predicate<MemberDeclarationContext>(...) { ... }nonNull(...)new Function<MemberDeclarationContext,Object>(...) { ... }new Predicate<Object>(...) { ... }import GroovyParser/** Utilities for configuring node positions *//** Sets location(lineNumber, colNumber, lastLineNumber, lastColumnNumber) for node using standard context information. ... */Token startgetStart(...)Token stopgetStop(...)setLineNumber(...)setColumnNumber(...)configureEndPosition(...)String stopTextMethodDeclarationContext methodDeclarationContextint stopTextLengthcontainsAny(...)createModifierManager(...)int newLineCntcountChar(...)new Consumer<? extends ClassBodyDeclarationContext>(...) { ... }setLastLineNumber(...)setLastColumnNumber(...)getLastLineNumber(...)getLastColumnNumber(...)Tuple2<Integer,Integer> endPositionendPosition(...)new Function<? extends EnumConstantContext,FieldNode>(...) { ... }InnerClassNode anonymousInnerClassNodeFieldNode enumConstantaddEnumConstant(...)createEnumConstantInitExpression(...)TupleExpression argumentListExpressionList<Expression> expressionsList<MapEntryExpression> mapEntryExpressionListgetMapEntryExpressions(...)// e.g. GStringEnd contains newlines, we should fix the location infonew Function<MapEntryExpression,Expression>(...) { ... }/** Utilities for handling strings */setWrapped(...)new Consumer<Expression>(...) { ... }String BACKSLASH;Pattern HEX_ESCAPES_PATTERN;Pattern OCTAL_ESCAPES_PATTERN;Pattern STANDARD_ESCAPES_PATTERN;Pattern LINE_ESCAPE_PATTERN;replaceAll(...)new Closure<Void>(...) { ... }StringUtils$1isLengthOdd(...)new String(...)toChars(...)StringUtils$2Map<Character,Character> STANDARD_ESCAPES;String resultStringUtils$3Character characternew Function<? extends TypeParameterContext,GenericsType>(...) { ... }int NONE_SLASHY;int SLASHY;int DOLLAR_SLASHY;new IntFunction<GenericsType[]>(...) { ... }replaceHexEscapes(...)replaceLineEscape(...)ClassNode baseTypeGenericsType genericsTypeaddTypeAnnotations(...)replaceEscapes(...)replaceStandardEscapes(...)replaceOctalEscapes(...)StringUtils$4count(...)chars(...)new IntPredicate(...) { ... }/** The modified implementation is based on StringUtils#replace(String text, String searchString, String replacement, int max), Apache commons-lang3-3.6 ... */int endint replLengthint increase/** Copied from Apache commons-lang3-3.6 ... */int INDEX_NOT_FOUND;new Function<? extends TypeContext,ClassNode>(...) { ... }Statement sParameter[] headercloneParams(...)AstBuilder$2new Predicate<Parameter>(...) { ... }visitPropertyExpression(...)attachTupleConstructorAnnotationToRecord(...)ClassNode tupleConstructorTypeList<AnnotationNode> annosAnnotationNode tupleConstructorList<InnerClassNode> anonymousInnerClassListMethodNode methodNodenew LinkedList<InnerClassNode>(...)validateParametersOfMethodDeclaration(...)createConstructorOrMethodNodeForClass(...)createScriptMethodNode(...)new Consumer<InnerClassNode>(...) { ... }setEnclosingMethod(...)isSyntheticPublic(...)isAnnotationDeclaration(...)setInStaticContext(...)getVariableScope(...)validateMethodDeclaration(...)boolean isAbstractMethodboolean hasMethodBodyctx.tctx.ctboolean isInterfaceOrAbstractClassisAnnotationDefinition(...)processMethodNode(...)getClassMemberModifiersOpValue(...)boolean hasReturnType/** Provides access to built-in {@link GroovyRunner} instances ... */new Junit3TestRunner(...)new Junit3SuiteRunner(...)new Junit4TestRunner(...)GroovyRunner JUNIT3_TEST;/* These runners were originally included directly in GroovyShell. ... */GroovyRunner JUNIT3_SUITE;GroovyRunner JUNIT4_TEST;createConstructorNodeForClass(...)getModifierCount(...)/** Utility method to check through reflection if the class appears to be a ... */createMethodNodeForClass(...)Class<?> testCaseClassattachAnnotations(...)setAnnotationDefault(...)ConstructorCallExpression thisOrSuperConstructorCallExpressioncheckThisAndSuperConstructorCall(...)VOID(...)new DeclarationListStatement(...)createGroovyTokenByType(...)processVariableExpression(...)ASSIGN(...)/** Run the specified class extending TestCase as a unit test. ... */Object testSuiteinvokeConstructorOf(...)ClassNode variableTypeList<DeclarationExpression> declarationExpressionListcreateMultiAssignmentDeclarationListStatement(...)createFieldDeclarationListStatement(...)Class<?> testSuiteClassnew Consumer<DeclarationExpression>(...) { ... }/** Run the specified class extending TestSuite as a unit test. ... */DeclarationExpression declarationExpression/** Utility method to check via reflection if the parsed class appears to be a JUnit4 ... */hasRunWithAnnotation(...)hasTestAnnotatedMethod(...)Class<?> junitCoreClassExpression initialValueObject defaultValuefindDefaultValueByType(...)List<?> failuresisFieldDeclaration(...)declareField(...)Object fsetClassNode(...)Class<? extends Annotation> runWithAnnotationClassisAnnotationPresent(...)PropertyExpander expandernew PropertyExpander(...)Class<? extends Annotation> testAnnotationClass// fall throughnew PropertyNode(...)addProperty(...)CompileStatic.classvisitProperty(...)/** Classes which can run scripts should implement this interface. ... *//** Returns {@code true} if this runner is able to ... *//** Runs the given class. ... */import ServiceConfigurationErrorimport ServiceLoaderimport ReadWriteLock/** Registry of services that implement the {@link GroovyRunner} interface. ... */new GroovyRunnerRegistry(...)GroovyRunnerRegistry.classnew Function<? extends TypeNamePairContext,VariableExpression>(...) { ... }GroovyRunnerRegistry INSTANCE;/* Implementation notes ... */Map<String,GroovyRunner> runnerMap;// Lazily initialized and loaded, should be accessed internally using getMap()List<GroovyRunner> cachedValues;/* Cached unmodifiable List used for iteration. Any method that mutates ... */ReadWriteLock rwLock;/** Returns a reference to the one and only registry instance. ... */// package-private for use in testing to avoid calling ServiceLoader.loadnew LinkedHashMap<String,GroovyRunner>(...)/** Lazily initialize and load the backing Map. A {@link LinkedHashMap} ... */Map<String,GroovyRunner> mapload(...)/** Loads {@link GroovyRunner} instances using the {@link ServiceLoader} facility. ... */getMap(...)loadDefaultRunners(...)loadWithLock(...)SecurityException seServiceConfigurationError sceregister(...)junit3TestRunner(...)junit3SuiteRunner(...)junit4TestRunner(...)ServiceLoader<GroovyRunner> serviceLoaderGroovyRunner.class/** Registers the given instance with the registry. This is ... *//** Returns an iterator for all runners that are registered. ... *//** Returns the number of registered runners. ... *//** Returns {@code true} if the registry contains no runners, else ... *//** Returns {@code true} if a runner was registered with the ... *//** Returns {@code true} if registry contains the given ... *//** Returns the registered runner for the specified key. ... *//** Registers a runner with the specified key. ... *//** Removes a registered runner from the registry. ... *//** Adds all entries from the given Map to the registry. ... */Entry<? extends String,? extends GroovyRunner> entryMap<>.Entry<? extends String,? extends GroovyRunner>/** Clears all registered runners from the registry and resets ... *//** Set of all keys associated with registered runners. ... */new LinkedHashSet<E>(...)/** Returns a collection of all registered runners. ... */List<GroovyRunner> valuesnew Function<? extends VariableDeclaratorContext,DeclarationExpression>(...) { ... }new Token(...)ctx.start/** Returns a set of entries for registered runners. ... */// Preserve insertion order// direct read// initialize and load (recursive call), result ignored// getMap() already loaded using a null classloadernew Function<? extends VariableInitializerContext,Expression>(...) { ... }// racy, multiple threads may set cachedValues but rather have that than take a write lockboolean hasArgumentListboolean hasCommandArgumentExpression baseExprMethodCallExpression methodCallExpressionisInsideParentheses(...)getOriginalText(...)Expression argumentscreateMethodCallExpression(...)validateInvalidMethodDefinition(...)createCallMethodCallExpression(...)new Function<? extends CommandArgumentContext,Object>(...) { ... }CommandArgumentContext commandArgumentContext/* Validate the following invalid cases: ... */isBuiltInType(...)MethodCallExpression mceExpression methodCallArgumentsList<Expression> methodCallArgumentExpressionListint argumentCntExpression lastArgumentExpressionhasImplicitParameter(...)Expression primaryExprcreateConstantExpression(...)Expression pathExpressioncreatePathExpression(...)new PropertyExpression(...)// expression { ------------------------------------------------------------getAndAdd(...)new Function<Object,AtomicInteger>(...) { ... }TerminalNode staticTerminalNodeExpression namePartExprDOT(...)boolean isSafeChaincreateDotExpression(...)SAFE_DOT(...)SAFE_CHAIN_DOT(...)METHOD_POINTER(...)new MethodPointerExpression(...)METHOD_REFERENCE(...)new MethodReferenceExpression(...)SPREAD_DOT(...)AttributeExpression attributeExpressionsetSpreadSafe(...)PropertyExpression propertyExpressionCreatorContext creatorContextnew BinaryExpression(...)createGroovyToken(...)SAFE_INDEX(...)Expression firstKeyExpressionint mapEntryExpressionListSizeNamedPropertyArgsContext namedPropertyArgsContextLBRACK(...)new SpreadMapExpression(...)getKeyExpression(...)Expression argumentsExprString baseExprTextnew ConstructorCallExpression(...)ClassNode.SUPERClassNode.THISClosureExpression closureExpressionExpression argumentsExpressionArgumentListExpression argumentListExpressionTupleExpression tupleExpressionNamedArgumentListExpression namedArgumentListExpressionsetArguments(...)/** Array utilities. ... *//** Concatenate arrays and ignore null array ... */new Function<ClassNode,GenericsType>(...) { ... }createGenericsType(...)int resultLengthCOMMA(...)new LinkedList<Expression>(...)new LinkedList<MapEntryExpression>(...)new Predicate<T[]>(...) { ... }new Function<T[],Integer>(...) { ... }e.lengthnew BinaryOperator<Integer>(...) { ... }T[] resultArrayarrays.lengthint currT[] arrayarray.lengthnew Function<? extends EnhancedArgumentListElementContext,Expression>(...) { ... }MapEntryExpression mapEntryExpressionvalidateDuplicatedNamedParameter(...)new TupleExpression(...)new NamedArgumentListExpression(...)Expression keyExpressionString parameterNameboolean isDuplicatedNamedParameternew Predicate<MapEntryExpression>(...) { ... }parseStringLiteral(...)StringLiteral(...)ConstantExpression constantExpressionint slashyTypegetSlashyType(...)boolean startsWithSlashremoveCR(...)trimQuotations(...)/** Returns a new String which is the same as the original except the first letter ... */char[] cStringUtils.SLASHYStringUtils.DOLLAR_SLASHYStringUtils.NONE_SLASHY/** This is the complement the behavior of the decapitalize(string) method. ... */String restisLowerCase(...)Expression indexExpr// Funky rule so that names like 'pNAME' will still work.Expression pathExprctx.opPostfixExpression postfixExpressionnew PostfixExpression(...)NOT(...)new NotExpression(...)BITNOT(...)new BitwiseNegationExpression(...)CastExpression castnew CastExpression(...)createBinaryExpression(...)ctx.leftctx.rightisNonStringConstantOutsideParentheses(...)new UnaryPlusExpression(...)String integerLiteralTextString floatingPointLiteralTextConstantExpression resultparseInteger(...)parseDecimal(...)new UnaryMinusExpression(...)new PrefixExpression(...)Token opToken antlrTokenctx.rangeOpnew RangeExpression(...)ctx.dlOpctx.dgOpctx.tgOpasExpression(...)ELVIS(...)new ElvisOperatorExpression(...)ctx.connew TernaryExpression(...)Expression leftExprTypes.LEFT_SQUARE_BRACKET// primary { ---------------------------------------------------------------// } expression ------------------------------------------------------------THIS(...)SUPER(...)// } primary ---------------------------------------------------------------Expression enclosingInstanceExpressionsetName(...)ConstructorCallExpression constructorCallExpressionsetUsingAnonymousInnerClass(...)ArrayExpression arrayExpressionList<Tuple3<Expression,List<AnnotationNode>,TerminalNode>> dimListnew Function<? extends DimContext,Tuple3<Expression,List<AnnotationNode>,TerminalNode>>(...) { ... }TerminalNode invalidDimLBrackBoolean exprEmptyList<Tuple3<Expression,List<AnnotationNode>,TerminalNode>> emptyDimListnew LinkedList<Tuple3<Expression,List<AnnotationNode>,TerminalNode>>(...)List<Tuple3<Expression,List<AnnotationNode>,TerminalNode>> dimWithExprListTuple3<Expression,List<AnnotationNode>,TerminalNode> latestDimTuple3<Expression,List<AnnotationNode>,TerminalNode> dimClassNode elementTypecreateArrayType(...)Expression[] emptiesnew Expression[]fill(...)Expression.EMPTY_ARRAYnew Function<Tuple3<Expression,List<AnnotationNode>,TerminalNode>,Expression>(...) { ... }import MemJavaFileObjectimport FileObjectimport ForwardingJavaFileManagerimport JavaCompilerimport JavaFileManagerimport JavaFileObjectimport SimpleJavaFileObjectimport StandardJavaFileManagerimport ToolProviderimport ByteArrayOutputStream/** A shell for compiling or running pure Java code */new Function<Tuple3<Expression,List<AnnotationNode>,TerminalNode>,List<AnnotationNode>>(...) { ... }String MAIN_METHOD_NAME;JavaShellClassLoader jscl;Locale locale;/** Initializes a newly created {@code JavaShell} object *//** Initializes a newly created {@code JavaShell} object ... */new JavaShellClassLoader(...)JavaShell.classint anonymousClassCountIterator<InnerClassNode> itgetInnerClasses(...)InnerClassNode innerClassisAnonymous(...)ClassNode superClassgetScriptClassDummy(...)String innerClassNamenextAnonymousClassName(...)InnerClassNode anonymousInnerClassnew EnumConstantClassNode(...)setAnonymous(...)createMapEntryList(...)/** Run main method ... */Method mainMethodnew Function<? extends MapEntryContext,MapEntryExpression>(...) { ... }Expression keyExprExpression valueExpr/** Compile and return the main class ... */doCompile(...)findClass(...)new MapEntryExpression(...)/** Compile and return all classes ... */Map<String,Class<?>> classesnew LinkedHashMap<String,Class<?>>(...)BuiltInPrimitiveType(...)createExpressionList(...)new Function<? extends ExpressionListElementContext,Expression>(...) { ... }validateExpressionListElement(...)ctx.canSpreadnew SpreadExpression(...)getMethodAsString(...)isImplicitThis(...)// literal { ---------------------------------------------------------------IntegerLiteral(...)Number numFloatingPointLiteral(...)BooleanLiteral(...)// gstring { ---------------------------------------------------------------// } literal ---------------------------------------------------------------List<ConstantExpression> stringLiteralListnew LinkedList<ConstantExpression>(...)String cngetClassMap(...)compileAll(...)JavaCompiler compilergetSystemJavaCompiler(...)BytesJavaFileManager bjfmnew BytesJavaFileManager(...)getStandardFileManager(...)StringBuilderWriter outJavaCompiler.CompilationTaskCompilationTask taskgetTask(...)new MemJavaFileObject(...)Map<String,byte[]> classMapnew JavaShellCompilationException(...)setClassMap(...)/** When and only when {@link #compile(String, String)} or {@link #compileAll(String, String)} is invoked, ... */new ConcurrentHashMap<String,Class<?>>(...)String beginGStringBegin(...)String beginQuotationbeginQuotation(...)List<ConstantExpression> partStringsGStringPart(...)new Function<? extends TerminalNode,ConstantExpression>(...) { ... }parseGStringPart(...)List<Expression> valuesMap<String,byte[]> classMap;Map<String,Class<?>> classCache;new Function<String,Class<?>>(...) { ... }this.classMapnew HashMap<String,BytesJavaFileObject>(...)new Function<? extends GstringValueContext,Expression>(...) { ... }StringBuilder verbatimTextparseGStringBegin(...)GStringEnd(...)parseGStringEnd(...)boolean isVariableExpressionnew GStringExpression(...)ARROW(...)StringBuilder textinsert(...)deleteCharAt(...)Map<String,BytesJavaFileObject> fileObjectMap;JavaFileManager.LocationJavaFileObject.KindBytesJavaFileObject bjfonew BytesJavaFileObject(...)new LinkedHashMap<String,byte[]>(...)hasArrow(...)GStringPathPart(...)Expression propertyExpressionnew BiConsumer<String,BytesJavaFileObject>(...) { ... }new Function<? extends TerminalNode,Expression>(...) { ... }new ByteArrayOutputStream(...)ByteArrayOutputStream baos;create(...)kind.extensionnew BinaryOperator<Expression>(...) { ... }// } gstring ---------------------------------------------------------------createLambda(...)new LambdaExpression(...)VariableExpression variableBlockStatement codeClosureExpression resultnew ClosureExpression(...)List<Parameter> parameterListnew LinkedList<Parameter>(...)/** Map utilities. ... */Map<K,V> mapnew LinkedHashMap<K,V>(...)List<? extends FormalParameterContext> formalParameterListvalidateVarArgParameter(...)new Function<? extends FormalParameterContext,Parameter>(...) { ... }validateParameterList(...)FormalParameterContext formalParameterContextELLIPSIS(...)Parameter otherParameterprocessFormalParameter(...)new Function<? extends ClassOrInterfaceModifierContext,ModifierNode>(...) { ... }new ModifierNode(...)ctx.mnew Function<? extends ModifierContext,ModifierNode>(...) { ... }new Function<? extends VariableModifierContext,ModifierNode>(...) { ... }List<List<AnnotationNode>> dimListnew Function<? extends AnnotationsOptContext,List<AnnotationNode>>(...) { ... }// type { ------------------------------------------------------------------classOrInterfaceType(...)GenericsType.EMPTY_ARRAYnew Function<? extends TypeArgumentContext,GenericsType>(...) { ... }QUESTION(...)ClassNode[] upperBoundsClassNode lowerBoundsetWildcard(...)// } type ------------------------------------------------------------------new Function<? extends VariableDeclaratorIdContext,VariableExpression>(...) { ... }new Function<? extends BlockStatementContext,Statement>(...) { ... }new Predicate<Statement>(...) { ... }Object astNodenew Function<? extends AnnotationContext,AnnotationNode>(...) { ... }String annotationNameList<Tuple2<String,Expression>> annotationElementValuesnew Consumer<Tuple2<String,Expression>>(...) { ... }new LinkedList<Tuple2<String,Expression>>(...)new BiConsumer<String,Expression>(...) { ... }toMap(...)new Function<? extends ElementValuePairContext,Tuple2<String,Expression>>(...) { ... }new Function<Tuple2<String,Expression>,String>(...) { ... }new Function<Tuple2<String,Expression>,Expression>(...) { ... }new Supplier<LinkedHashMap<String,Expression>>(...) { ... }new AnnotationConstantExpression(...)new Function<? extends ElementValueContext,Expression>(...) { ... }new Function<? extends AnnotatedQualifiedClassNameContext,ClassNode>(...) { ... }createClassNode(...)ClassNode arrayTypeClassNode resultproxyClassNode(...)/** Visit tree safely, no NPE occurred when the tree is null. ... */// e.g. obj.a(1, 2) or obj.a 1, 2isSafe(...)isSpreadSafe(...)// e.g. m(1, 2) or m 1, 2Expression thisExprsetInitialExpression(...)new Function<? extends PathElementContext,Object>(...) { ... }PathElementContext pathElementContextList<ExpressionStatement> expressionStatementListappendStatementsToBlockStatement(...)new BinaryOperator<Statement>(...) { ... }containsAnnotations(...)containsNonVisibilityModifier(...)// the mixins of interface and annotation should be nullsetMixins(...)Map<ClassNode,Object> TYPE_DEFAULT_VALUE_MAP;getStatementBlock(...)Number insideParenLevelString tokenTextTypes.RANGE_OPERATORTypes.ANY/** Sets the script source position. */ClassNode scriptClassNodeStatement firstStatementStatement lastStatementObject nmdnew SyntaxException(...)ctx.stopcollectSyntaxError(...)GroovySyntaxError groovySyntaxErrorcollectException(...)CompilePhase.PARSINGaddFatalError(...)new SyntaxErrorMessage(...)new ANTLRErrorListener<>(...) { ... }AstBuilder$3addErrorListener(...)createANTLRErrorListener(...)List<ExpressionStatement> declarationStatements;this.declarationStatementsnew Function<DeclarationExpression,ExpressionStatement>(...) { ... }List<String> declarationListStatementLabelsgetStatementLabels(...)new Consumer<String>(...) { ... }new Function<ExpressionStatement,DeclarationExpression>(...) { ... }ModuleNode moduleNode;GroovyLangLexer lexer;GroovyLangParser parser;GroovydocManager groovydocManager;TryWithResourcesASTTransformation tryWithResourcesASTTransformation;List<ClassNode> classNodeList;Deque<ClassNode> classNodeStack;Deque<List<InnerClassNode>> anonymousInnerClassesDefinedInMethodStack;Deque<GroovyParserRuleContext> switchExpressionRuleContextStack;Tuple2<GroovyParserRuleContext,Exception> numberFormatError;int visitingClosureCount;int visitingLoopStatementCount;int visitingSwitchStatementCount;int visitingAssertStatementCount;int visitingArrayInitializerCount;int SLL_THRESHOLD;String QUESTION_STR;String DOT_STR;String SUB_STR;String ASSIGN_STR;String VALUE_STR;String DOLLAR_STR;String CALL_STR;String THIS_STR;String SUPER_STR;String VOID_STR;String SLASH_STR;String SLASH_DOLLAR_STR;String TDQ_STR;String TSQ_STR;String SQ_STR;String DQ_STR;String DOLLAR_SLASH_STR;String VAR_STR;Map<String,String> QUOTATION_MAP;String PACKAGE_INFO;String PACKAGE_INFO_FILE_NAME;String CLASS_NAME;String INSIDE_PARENTHESES_LEVEL;String IS_INSIDE_INSTANCEOF_EXPR;String IS_SWITCH_DEFAULT;String IS_NUMERIC;String IS_STRING;String IS_INTERFACE_WITH_DEFAULT_METHODS;String IS_INSIDE_CONDITIONAL_EXPRESSION;String IS_COMMAND_EXPRESSION;String IS_BUILT_IN_TYPE;String PATH_EXPRESSION_BASE_EXPR;String PATH_EXPRESSION_BASE_EXPR_GENERICS_TYPES;String PATH_EXPRESSION_BASE_EXPR_SAFE_CHAIN;String CMD_EXPRESSION_BASE_EXPR;String TYPE_DECLARATION_MODIFIERS;String COMPACT_CONSTRUCTOR_DECLARATION_MODIFIERS;String CLASS_DECLARATION_CLASS_NODE;String VARIABLE_DECLARATION_VARIABLE_TYPE;String ANONYMOUS_INNER_CLASS_SUPER_CLASS;String INTEGER_LITERAL_TEXT;String FLOATING_POINT_LITERAL_TEXT;String ENCLOSING_INSTANCE_EXPRESSION;String IS_YIELD_STATEMENT;String PARAMETER_MODIFIER_MANAGER;String PARAMETER_CONTEXT;String IS_RECORD_GENERATED;String RECORD_HEADER;String RECORD_TYPE_NAME;ClassNode RECORD_TYPE_CLASS;// parsing have to wait util clearing is complete.// The more tokens to parse, the more possibility SLL will fail and the more parsing time will waste.// The option `groovy.antlr4.sll.threshold` could be tuned for better parsing performance, but it is disabled by default.// If the token count is greater than `groovy.antlr4.sll.threshold`, use LL directly.// if some syntax error occurred in the lexer, no need to retry the powerful LL mode// local variable declaration(s)// add "return null" if script has no statements/methods/classes// e.g. import static java.lang.Math.*// e.g. import static java.lang.Math.pow// e.g. import java.util.*// e.g. import java.util.Map// e.g. for(int i in 0..<10) {}// e.g. for(int i = 0; i < 10; i++) {}// merge several LinkedList<CatchStatement> instances into one LinkedList<CatchStatement> instance// FIXME Groovy will ignore variableModifier of parameter in the catch clause// In order to make the new parser behave same with the old one, we do not process variableModifier*// FIXME The old parser does not set location info for the parameter of the catch clause.// we could make it better//this.configureAST(new Parameter(e, this.visitIdentifier(ctx.identifier())), ctx.Identifier()),// check whether processing the last label. if yes, block statement should be attached.// this.configureAST(blockStatement, tuple.getKey())// this.configureAST(codeBlock, tuple.getKey())// e.g. class A {}// GROOVY-9259// we put the class already in output to avoid the most inner classes// will be used as first class later in the loader. The first class// there determines what GCL#parseClass for example will return, so we// have here to ensure it won't be the inner class// e.g. SOME_ENUM_CONSTANT(a: "1", b: "2")// e.g. static { }// e.g.  { }// method code must be a BlockStatement// if classNode is not null, the method declaration is for class declaration// script method declaration// 1: normal method declaration; 2: abstract method declaration; 3: normal method declaration OR abstract method declaration// script// method should not be declared abstract in the script// trait// annotation// non-abstract method without body in the non-script(e.g. class, enum, trait) is not allowed!// the code of annotation method/* if (!modifierManager.contains(DEF)) { ... */// e.g. def (int a, int b) = [1, 2]// if classNode is not null, the variable declaration is for class declaration. In other words, it is a field declaration// Tweak start of first declaration// expand properties early so AST transforms will be handled correctly// To avoid ambiguities, command chain expression should not be used in array initializer// the old parser does not support either, so no breaking changes// SEE http://groovy.329449.n5.nabble.com/parrot-Command-expressions-in-array-initializer-tt5752273.html// e.g. obj.a 1, 2// e.g. m {} a, b  OR  m(...) a, b// The error should never be thrown.// e.g. m 1, 2// e.g. "$m" 1, 2// e.g. "m" 1, 2// e.g. a[x] b, new A() b, etc.// check the method call tails with a closure// e.g. x y a b     we call "x y" as the base expression// e.g. x y a b// the branch should never reach, because a.b.c will be parsed as a path expression, not a method call// the following code will process "a b" of "x y a b"// e.g. x y a.b// e.g. x y a// e.g. obj??.a  OR obj??.@a// e.g. obj.&m// e.g. obj::m// e.g. obj*.@a// e.g. obj*.p// e.g. list[1, 3, 5]// this is a special way to signify a cast, e.g. Person[name: 'Daniel.Sun', location: 'Shanghai']// expecting list of MapEntryExpressions later so use SpreadMap to smuggle empty MapExpression to later stages// e.g. (obj.x)(), (obj.@x)()// e.g. obj.@a(1, 2)// whether attributeExpression is spread safe or not, we must reset it as false// e.g. obj.a(1, 2)// void and primitive type AST node must be an instance of VariableExpression// e.g. void()// e.g. int(), long(), float(), etc.// e.g. m()// e.g. "$m"()// e.g. "m"()// e.g. this(...), super(...)// class declaration is not allowed in the closure,// so if this and super is inside the closure, it will not be constructor call.// e.g. src/test/org/codehaus/groovy/transform/MapConstructorTransformTest.groovy:// @MapConstructor(pre={ super(args?.first, args?.last); args = args ?: [:] }, post = { first = first?.toUpperCase() })// e.g. 1(), 1.1(), ((int) 1 / 2)(1, 2), {a, b -> a + b }(1, 2), m()()// normal arguments, e.g. 1, 2// named arguments, e.g. x: 1, y: 2// the branch should never reach, because named arguments must not be empty// e.g. obj.m { }// e.g. m { }// e.g. "$m" { }// e.g. "m" { }// e.g. 1 { }, 1.1 { }, (1 / 2) { }, m() { }, { -> ... } { }// e.g. obj.@a  OR  obj?.@a// e.g. obj.p  OR  obj?.p// e.g. arguments like  1, 2 OR  someArg, e -> e// e.g. arguments like  x: 1, y: 2// e.g. arguments like x: 1, 'a', y: 2, 'b', z: 3// remove CR in the multiline string// the slashy string can span rows, so we have to remove CR for it//handle escapes.// e.g. a[*[1, 2]]// e.g. a[1]// e.g. a[1, 2]// powerassert requires different column for values, so we have to copy the location of op// GROOVY-9391// reset// e.g. a == 6 ?: 0// it is a special multiple assignment whose variable count is only one, e.g. (a) = [1]// the LHS expression should be a variable which is not inside any parentheses//                                && !(THIS_STR.equals(leftExpr.getText()) || SUPER_STR.equals(leftExpr.getText()))     // commented, e.g. this = value // this will be transformed to $this// e.g. p = 123// e.g. obj.p = 123//                                && !(((BinaryExpression) leftExpr).getRightExpression() instanceof ListExpression)    // commented, e.g. list[1, 2] = [11, 12]// e.g. map[a] = 123 OR map['a'] = 123 OR map["$a"] = 123// create instance of class// should never reach here// GROOVY-8947// if the anonymous class is created in a script, no anonymousInnerClassList is available.// create array// and remove the final modifier from classNode to allow the sub class// if the key is variable and not inside parentheses, convert it to a constant, e.g. [a:1, b:2]// statements like `foo(String a)` is invalid// remove the tailing $// e.g. "${}"// e.g. <>// GROOVY-8991: Difference in behaviour with closure and lambda//this.configureAST((Statement) this.visit(ctx.statement()), ctx);// type in the "instanceof" expression should not have proxy to redirect to it// method call obj*.m(): "safe"(false) and "spreadSafe"(true)// property access obj*.p: "safe"(true) and "spreadSafe"(true)// so we have to reset safe here.// if the generics types meta data is not empty, it is a generic method call, e.g. obj.<Integer>a(1, 2)// if DeclarationListStatement contains more than 1 declarations, maybe it's better to create a block to hold them// clear existing statement labels before setting labels/** Just hold an object ... */T object;import RandomAccess/** Represents view of reversed list ... */List<E> delegate;import GroovyStarter/** The tool to simulate running script files via groovy command ... *//** Run the script file specified by the file path ... *//** Run the script file specified by the classpath ... */runScript(...)ScriptRunner.class/** Sets a system property from a {@code name=value} String. ... */setSystemPropertyFrom(...)SecurityException ignore/** Retrieves a System property, or returns some default value if: ... */RuntimeException ignore/** Retrieves a System property, or null if: ... */getSystemPropertySafe(...)/** Retrieves a Boolean System property, or returns false if: ... */getBoolean(...)/** Retrieves an Integer System property ... *//** Retrieves an Long System property ... */getLong(...)// suppress exceptionimport SuppressFBWarningsimport ReferenceQueueimport SoftReferenceimport AbstractCollectionimport AbstractMapimport AbstractSetimport ConcurrentModificationExceptionimport EnumSetimport Hashtableimport IdentityHashMapimport ReentrantLockimport BiFunction/** An advanced hash table supporting configurable garbage collection semantics ... */ReferenceType.WEAKReferenceType.STRONG/** An option specifying which Java reference type should be used to refer ... *//* The basic strategy is to subdivide the table among Segments, ... */new ReferenceType(...)ReferenceType STRONG;/** Indicates a normal Java strong reference should be used */ReferenceType WEAK;/** Indicates a {@link WeakReference} should be used */ReferenceType SOFT;/** Indicates a {@link SoftReference} should be used *//** Behavior-changing configuration options for the map */new Option(...)Option IDENTITY_COMPARISONS;/** Indicates that referential-equality (== instead of .equals()) should ... */ReferenceType DEFAULT_KEY_TYPE;/* ---------------- Constants -------------- */ReferenceType DEFAULT_VALUE_TYPE;int DEFAULT_INITIAL_CAPACITY;/** The default initial capacity for this table, ... */float DEFAULT_LOAD_FACTOR;/** The default load factor for this table, used when not ... */int DEFAULT_CONCURRENCY_LEVEL;/** The default concurrency level for this table, used when not ... */int MAXIMUM_CAPACITY;/** The maximum capacity, used if a higher value is implicitly ... */int MAX_SEGMENTS;/** The maximum number of segments to allow; used to bound ... */int RETRIES_BEFORE_LOCK;/** Number of unsynchronized retries in size and containsValue ... */int segmentMask;/** Mask value for indexing into segments. The upper bits of a ... *//* ---------------- Fields -------------- */int segmentShift;/** Shift value for indexing within segments. */...[] segments;/** The segments, each of which is a specialized hash table */boolean identityComparisons;Set<K> keySet;Set<Entry<K,V>> entrySet;Collection<V> values;/** Applies a supplemental hash function to a given hashCode, which ... *//* ---------------- Small Utilities -------------- */... >>> .../** Returns the segment that should be used for key with given hash ... */identityHashCode(...)/* ---------------- Inner Classes -------------- *//** A weak-key reference which stores the key hash needed for reclamation. */int hash;this.hash/** A soft-key reference which stores the key hash needed for reclamation. */Object keyRef;this.keyRef/** ConcurrentReferenceHashMap list entry. Note that this is never exported ... */Object valueRef;HashEntry next;this.nextnewKeyReference(...)this.valueRefnewValueReference(...)new WeakKeyReference<K>(...)ReferenceType.SOFTnew SoftKeyReference<K>(...)new WeakValueReference<V>(...)new SoftValueReference<V>(...)dereferenceValue(...)new HashEntry<>[]/** Segments are specialized versions of hash tables.  This ... *//* Segments maintain a table of entry lists that are ALWAYS ... */int count;/** The number of elements in this segment's region. */int modCount;/** Number of updates that alter the size of the table. This is ... */int threshold;/** The table is rehashed when its size exceeds this threshold. ... */...[] table;/** The per-segment table. */float loadFactor;/** The load factor for the hash table.  Even though this value ... */ReferenceQueue<Object> refQueue;/** The collected weak-key reference queue for this segment. ... */ReferenceType keyType;ReferenceType valueType;this.keyTypethis.valueTypethis.identityComparisonssetTable(...)newArray(...)new Segment<>[]/** Sets table to new HashEntry array. ... */newTable.lengthnew ReferenceQueue<Object>(...)/** Returns properly casted first entry of bin for given hash. */HashEntry<K,V>[] tabtab.lengthnew HashEntry<K,V>(...)/** Reads value field of an entry under lock. Called if value ... */removeStale(...)/* Specialized implementations of map methods */HashEntry<K,V> ekeyEq(...)e.hashkey(...)Object opaquee.valueRefreadValueUnderLock(...)e.nextV vreplaceInternal2(...)boolean replacedreplaceInternal(...)V oldValueV newValueremoveInternal(...)putInternal(...)/** This method must be called with exactly one of <code>value</code> and ... */HashEntry<K,V> firstV resultValueint reducedrehash(...)newHashEntry(...)HashEntry<K,V>[] oldTableint oldCapacityoldTable.lengthHashEntry<K,V>[] newTableint sizeMaskint reduceHashEntry<K,V> nextHashEntry<K,V> lastRunint lastIdxHashEntry<K,V> lastlast.nextlast.hashHashEntry<K,V> pp.nextK keyp.hashHashEntry<K,V> n/** Remove: match on key only if value is null, else match both. */e.keyRefHashEntry<K,V> newFirstK pKeyKeyReference refkeyRef(...)keyHash(...)/** Creates a new, empty map with the specified initial ... *//* ---------------- Public operations -------------- */int sshiftint ssizeint cap...<<=...this.segmentsOption.IDENTITY_COMPARISONSthis.segments.lengthnew Segment<K,V>(...)/** Creates a new, empty map with the specified initial capacity ... *//** Creates a new, empty map with the specified initial capacity, ... *//** Creates a new, empty reference map with the specified key ... *//** Creates a new, empty reference map with the specified reference types ... *//** Creates a new, empty map with a default initial capacity (16), ... *//** Creates a new map with the same mappings as the given map. ... *//** Returns <tt>true</tt> if this map contains no key-value mappings. ... */Segment<K,V>[] segmentsint[] mcsegments.lengthint mcsum...[...].count...[...].modCount/** Returns the number of key-value mappings in this map.  If the ... */long sumlong checkhashOf(...)segmentFor(...)/** Tests if the specified object is a key in this table. ... *//** Returns <tt>true</tt> if this map maps one or more keys to the ... */boolean foundint sumboolean cleanSweep/** Legacy method testing if some key maps into the specified value ... *//** Maps the specified key to the specified value in this table. ... *//** * ... */Segment<K,V> segmentapplyIfPresent(...)/** Copies all of the mappings from the specified map to this one. ... */Entry<? extends K,? extends V> e/** Removes the key (and its corresponding value) from this map. ... *//** Removes all of the mappings from this map. *//** Removes any stale entries whose keys have been finalized. Use of this ... *//** Returns a {@link Set} view of the keys contained in this map. ... */Set<K> ksnew KeySet(...)/** Returns a {@link Collection} view of the values contained in this map. ... */Collection<V> vsnew Values(...)/** Returns a {@link Set} view of the mappings contained in this map. ... */Set<Entry<K,V>> esnew EntrySet(...)/** Returns an enumeration of the keys in this table. ... */new KeyIterator(...)/** Returns an enumeration of the values in this table. ... */new ValueIterator(...)/* ---------------- Iterator Support -------------- */int nextSegmentIndex;int nextTableIndex;...[] currentTable;HashEntry<K,V> nextEntry;HashEntry<K,V> lastReturned;K currentKey;// Strong reference to weak key (prevents gc)advance(...)nextEntry.nextSegment<K,V> segseg.countseg.tablecurrentTable.lengthConcurrentReferenceHashMap<>.thisnextEntry(...)/* This class is needed for JDK5 compatibility. */K key;V value;eq(...)/** Custom Entry class used by EntryIterator.next(), that relays setValue ... *//** Set our entry's value and writes it through to the map. The ... */new WriteThroughEntry(...)new InitializableEntry<>(...)InitializableEntry<> entry;boolean cached;this.cachednew CachedEntryIterator(...)new EntryIterator(...)Entry<?,?> e/** Save the state of the <tt>ConcurrentReferenceHashMap</tt> instance to a ... *//* ---------------- Serialization Support -------------- */defaultWriteObject(...)writeObject(...)/** Reconstitute the <tt>ConcurrentReferenceHashMap</tt> instance from a ... */defaultReadObject(...)readObject(...)/* Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved. ... *//* Written by Doug Lea with assistance from members of JCP JSR-166 ... */// Spread bits to regularize both segment and index locations,// using variant of single-word Wang/Jenkins hash.// read-volatile// recheck// delete mapping// something to remove// nothing to do. Leave things as they were.// add or replace old mapping// ensure capacity// adjust from possible weak cleanups// write-volatile/* Reclassify nodes in each list to new Map.  Because we are ... */// We need to guarantee that any existing reads of old Map can//  proceed. So we cannot yet null out each bin.//  Single node on list// Reuse trailing consecutive sequence at same slot// Clone all remaining nodes// Skip GC'd weak refs// a ref remove operation compares the Reference instance// All entries following removed node can stay// in list, but all preceding ones need to be// cloned.// Skip GC'd keys// replace the reference queue to avoid unnecessary stale cleanups// Find power-of-two sizes best matching arguments/* We keep track of per-segment modCounts to avoid ABA ... */// If mcsum happens to be zero, then we know we got a snapshot// before any modifications at all were made.  This is// probably common enough to bother tracking.// Try a few times to get accurate count. On failure due to// continuous async changes in table, resort to locking.// force retry// Resort to locking all segments// See explanation of modCount use above// Try a few times without locking/* Skip GC'd keys */// Initialize each segment to be minimally sized, and let grow.// Read the keys and values, and put the mappings in the table/** A {@code LazyInitializable} is an object that can be initialized lazily. ... */doInit(...)/** do initialization *//** Check if the object is initialized. ... *//** Mark the object initialized. ... *//** This is a basic implementation of a map able to forget its keys could be weak/soft/strong references. This ... *//** Creates a new, empty map with the key weak reference *//** Creates a new, empty map with the key weak reference and the specified initial capacity ... *//** Creates a new, empty map with the specified key reference type ... *//** Creates a new, empty map with the specified key reference type and initial capacity ... *//** Get the key specified value, or put the default value and return it if the key is absent ... */applyIfAbsent(...)new Function<K,V>(...) { ... }import ObjectHolderimport GuardedByimport Immutableimport ThreadSafeimport InvalidObjectExceptionimport ObjectInputStreamimport AbstractQueueimport ConcurrentLinkedQueueimport static Collections.unmodifiableMapimport static Collections.unmodifiableSetimport static DrainStatus.IDLEimport static DrainStatus.PROCESSINGimport static DrainStatus.REQUIRED/** A hash table supporting full concurrency of retrievals, adjustable expected ... */availableProcessors(...)getRuntime(...)ceilingNextPowerOfTwo(...)new DiscardingQueue(...)int NCPU;/** The number of CPUs *//* This class performs a best-effort bounding of a ConcurrentHashMap using a ... */long MAXIMUM_CAPACITY;/** The maximum weighted capacity of the map. */int NUMBER_OF_READ_BUFFERS;/** The number of read buffers to use. */int READ_BUFFERS_MASK;/** Mask value for indexing into the read buffers. */int READ_BUFFER_THRESHOLD;/** The number of pending read operations before attempting to drain. */int READ_BUFFER_DRAIN_THRESHOLD;/** The maximum number of read operations to perform per amortized drain. */int READ_BUFFER_SIZE;/** The maximum number of pending reads per buffer. */int READ_BUFFER_INDEX_MASK;/** Mask value for indexing into the read buffer. */int WRITE_BUFFER_DRAIN_THRESHOLD;/** The maximum number of write operations to perform per amortized drain. */Queue<?> DISCARDING_QUEUE;/** A queue that discards all entries. */Integer.SIZEnumberOfLeadingZeros(...)ConcurrentMap<K,Node<K,V>> data;// The backing data store holding the key-value associationsint concurrencyLevel;...[] readBufferReadCount;// These fields provide support to bound the map by a maximum capacityLinkedDeque<Node<K,V>> evictionDeque;AtomicLong weightedSize;AtomicLong capacity;Lock evictionLock;Queue<Runnable> writeBuffer;...[] readBufferWriteCount;...[] readBufferDrainAtWriteCount;...[] readBuffers;AtomicReference<DrainStatus> drainStatus;EntryWeigher<? super K,? super V> weigher;Queue<Node<K,V>> pendingNotifications;// These fields provide support for notifying a listener.EvictionListener<K,V> listener;/** Creates an instance based on the builder's configuration. */builder.concurrencyLevelbuilder.capacitynew ConcurrentHashMap<K,Node<K,V>>(...)builder.initialCapacitybuilder.weighernew ReentrantLock(...)new LinkedDeque<Node<K,V>>(...)new ConcurrentLinkedQueue<Runnable>(...)new AtomicReference<DrainStatus>(...)new long[]new AtomicLong[]new AtomicReference<>[][]new AtomicReference<>[]new AtomicReference<Node<K,V>>(...)builder.listenernew ConcurrentLinkedQueue<Node<K,V>>(...)DiscardingListener.INSTANCE/** Ensures that the object is not null. *//** Ensures that the argument expression is true. *//** Ensures that the state expression is true. *//** Retrieves the maximum weighted capacity of the map. ... *//* ---------------- Eviction Support -------------- *//** Sets the maximum weighted capacity of the map and eagerly evicts entries ... */checkArgument(...)lazySet(...)this.capacitydrainBuffers(...)evict(...)notifyListener(...)/** Determines whether the map has exceeded its capacity. *//** Evicts entries from the map while it exceeds the capacity and appends ... */hasOverflowed(...)Node<K,V> nodenode.keymakeDead(...)/** Performs the post-processing work required after a read. ... */int bufferIndexreadBufferIndex(...)long writeCountrecordRead(...)drainOnReadIfNeeded(...)/** Returns the index to the read buffer to record into. */getId(...)/** Records a read in the buffer and return its write count. ... */AtomicLong counter/** Attempts to drain the buffers if it is determined to be needed when ... */long pendingboolean delayableDrainStatus statusshouldDrainBuffers(...)tryToDrainBuffers(...)/** Performs the post-processing work required after a write. ... *//** Attempts to acquire the eviction lock and apply the pending operations, up ... */tryLock(...)compareAndSet(...)/** Drains the read and write buffers up to an amortized threshold. */drainReadBuffers(...)drainWriteBuffer(...)/** Drains the read buffers, each up to an amortized threshold. */drainReadBuffer(...)/** Drains the read buffer up to an amortized threshold. */AtomicReference<Node<K,V>> slotapplyRead(...)/** Updates the node's location in the page replacement policy. */moveToBack(...)Runnable task/** Attempts to transition the node from the <tt>alive</tt> state to the ... */isAlive(...)WeightedValue<V> retirednew WeightedValue<V>(...)expect.valueexpect.weight/** Atomically transitions the node from the <tt>alive</tt> state to the ... */WeightedValue<V> currentcurrent.valuecurrent.weight/** Atomically transitions the node to the <tt>dead</tt> state and decrements ... */WeightedValue<V> dead/** Notifies the listener of entries that were evicted. */onEviction(...)/** Adds the node to the page replacement policy. */Node<K,V> node;int weight;this.weight/** Removes a node from the page replacement policy. *//** Updates the weighted size and evicts an entry on overflow. */int weightDifference;this.weightDifference/* ---------------- Concurrent Map Support -------------- *//** Returns the weighted size of this map. ... */AtomicReference<Node<K,V>>[] buffercheckNotNull(...)afterRead(...)/** Returns the value to which the specified key is mapped, or {@code null} ... *//** Adds a node to the list and the data store. If an existing node is found, ... */int weightweightOf(...)WeightedValue<V> weightedValuenew Node<K,V>(...)Node<K,V> priorafterWrite(...)new AddTask(...)WeightedValue<V> oldWeightedValueint weightedDifferenceoldWeightedValue.weightnew UpdateTask(...)oldWeightedValue.value/** If the specified key is not already associated with a value, ... */compute(...)ObjectHolder<Node<K,V>> objectHoldernew ObjectHolder<Node<K,V>>(...)Function<K,Node<K,V>> fnew Function<K,Node<K,V>>(...) { ... }setObject(...)getObject(...)node.weightedValueweightedValue.weightweightedValue.valuemakeRetired(...)new RemovalTask(...)tryToRetire(...)WeightedValue<V> newWeightedValue/** Returns a unmodifiable snapshot {@link Set} view of the keys contained in ... */ascendingKeySetWithLimit(...)/** Returns an unmodifiable snapshot {@link Set} view of the keys contained in ... */orderedKeySet(...)descendingKeySetWithLimit(...)int initialCapacityentrySingleton(...)weightedSize(...)Set<K> keysnew LinkedHashSet<K>(...)Iterator<Node<K,V>> iteratordescendingIterator(...)next(...).key/** Returns an unmodifiable snapshot {@link Map} view of the mappings contained ... */ascendingMapWithLimit(...)orderedMap(...)descendingMapWithLimit(...)/** The draining status of the buffers. */new DrainStatus(...) { ... }ConcurrentLinkedHashMap$DrainStatus$1/** A drain is not taking place. */ConcurrentLinkedHashMap$DrainStatus$2/** A drain is required due to a pending write modification. */ConcurrentLinkedHashMap$DrainStatus$3/** A drain is in progress. */DrainStatus IDLE;DrainStatus REQUIRED;DrainStatus PROCESSING;/** Determines whether the buffers should be drained. ... *//** A value, its weight, and the entry's status. *//** If the entry is available in the hash-table and page replacement policy. *//** If the entry was removed from the hash-table and is awaiting removal from ... *//** If the entry was removed from the hash-table and the page replacement ... *//** A node contains the key, the weighted value, and the linkage pointers on ... */Node prev;Node next;WeightedValue<V> weightedValue;/** Creates a new, unlinked node. */this.weightedValuethis.prev/** Retrieves the value held by the current <tt>WeightedValue</tt>. */get(...).value/** An adapter to safely externalize the keys. */ConcurrentLinkedHashMap<>.thisConcurrentLinkedHashMap map;map.data/** An adapter to safely externalize the key iterator. */Iterator<K> iterator;K current;checkState(...)/** An adapter to safely externalize the values. *//** An adapter to safely externalize the value iterator. */Iterator<Node<K,V>> iterator;Node<K,V> current;current.key/** An adapter to safely externalize the entries. */Entry<?,?> entry/** An adapter to safely externalize the entry iterator. *//** An entry that allows updates to write through to the map. */new SimpleEntry<K,V>(...)/** A weigher that enforces that the weight falls within a valid range. */this.weigher/** A queue that discards all additions and is always empty. */emptyIterator(...)/** A listener that ignores all notifications. */new DiscardingListener(...)DiscardingListener INSTANCE;new SerializationProxy<K,V>(...)new InvalidObjectException(...)/** A proxy that is serialized instead of the map. The page-replacement ... */Map<K,V> data;long capacity;map.concurrencyLevelnew HashMap<K,V>(...)map.capacitymap.listenermap.weigherConcurrentLinkedHashMap<K,V> mapweigher(...)listener(...)maximumWeightedCapacity(...)concurrencyLevel(...)new Builder<K,V>(...)/** A builder that creates {@link ConcurrentLinkedHashMap} instances. It ... *//* ---------------- Builder -------------- */int initialCapacity;/** Specifies the initial capacity of the hash table (default <tt>16</tt>). ... */this.initialCapacity/** Specifies the maximum weighted capacity to coerce the map to and may ... *//** Specifies the estimated number of concurrently updating threads. The ... */this.concurrencyLevel/** Specifies an optional listener that is registered for notification when ... */this.listener/** Specifies an algorithm to determine how many the units of capacity a ... */new BoundedEntryWeigher<K,V>(...)singleton(...)asEntryWeigher(...)/** Specifies an algorithm to determine how many the units of capacity an ... *//** Creates a new {@link ConcurrentLinkedHashMap} instance. ... */new ConcurrentLinkedHashMap<K,V>(...)/* Copyright 2010 Google Inc. All Rights Reserved. ... */// From Hacker's Delight, Chapter 3, Harry S. Warren Jr.// must write under lock// The data store and its maximum capacity// The eviction support// The notification queue and listener// Attempts to evict entries from the map if it exceeds the maximum// capacity. If the eviction fails due to a concurrent removal of the// victim, that removal may cancel out the addition that triggered this// eviction. The victim is eagerly unlinked before the removal task so// that if an eviction is still required then a new victim will be chosen// for removal.// If weighted values are used, then the pending operations will adjust// the size to reflect the correct weight// Notify the listener only if the entry was evicted// A buffer is chosen by the thread's id so that tasks are distributed in a// pseudo evenly manner. This helps avoid hot entries causing contention// due to other threads trying to append to the same buffer.// The location in the buffer is chosen in a racy fashion as the increment// is not atomic with the insertion. This means that concurrent reads can// overlap and overwrite one another, resulting in a lossy buffer.// An entry may be scheduled for reordering despite having been removed.// This can occur when the entry was concurrently read while a writer was// removing it. If the entry is no longer linked then it does not need to// be processed.// ignore out-of-order write operations// add may not have been processed yet// Discard all entries// Discard all pending reads// Apply all pending writes// the entry is present// the return value of `computeIfAbsent` is different from the one of `putIfAbsent`.// if the key is absent in map, the return value of `computeIfAbsent` is the newly computed value, but `putIfAbsent` return null.// prior should keep the value with the same meaning of the return value of `putIfAbsent`, so reset it as null here.// retry as an intermediate update may have replaced the value with// an equal instance that has a different reference identity/** A class that can determine the weight of an entry. The total weight threshold ... *//** Measures an entry's weight to determine how many units of capacity that ... *//* Copyright 2012 Google Inc. All Rights Reserved. ... *//** A listener registered for notification when an entry is evicted. An instance ... *//** A call-back notification that the entry was evicted. ... */import NotThreadSafe/** Linked list implementation of the {@link Deque} interface where the link ... */E first;/** Pointer to first node. ... */// discarded elements inhabit more than one generation.// element are cleared to help a generational garbage collector if the// NullPointerException throws in the byte code. The links to a removed// more convenient sentinel element to avoid the insertion of null checks with// machine. The first and last elements are manipulated instead of a slightly// This class provides a doubly-linked list that is optimized for the virtualE last;/** Pointer to last node. ... *//** Links the element to the front of the deque so that it becomes the first ... */E fsetPrevious(...)setNext(...)/** Links the element to the back of the deque so that it becomes the last ... */E l/** Unlinks the non-null first element. */E nextgetNext(...)/** Unlinks the non-null last element. */E prevgetPrevious(...)/** Unlinks the non-null element. */// A fast-path containment check/** Moves the element to the front of the deque so that it becomes the first ... */unlink(...)linkFirst(...)/** Moves the element to the back of the deque so that it becomes the last ... */linkLast(...)peekFirst(...)checkNotEmpty(...)peekLast(...)offerLast(...)offerFirst(...)pollFirst(...)unlinkFirst(...)unlinkLast(...)// A fast-path removalpollLast(...)boolean modifiednew AbstractLinkedIterator(...) { ... }LinkedDeque$1LinkedDeque$2E cursor;/** Creates an iterator that can can traverse the deque. ... */computeNext(...)/** Retrieves the next element to traverse to or <tt>null</tt> if there are ... *//** An element that is linked on the {@link Deque}. *//** Retrieves the previous element or <tt>null</tt> if either the element is ... *//** Sets the previous element or <tt>null</tt> if there is no link. *//** Retrieves the next element or <tt>null</tt> if either the element is ... *//** Sets the next element or <tt>null</tt> if there is no link. *//* Copyright 2011 Google Inc. All Rights Reserved. ... *//** A class that can determine the weight of a value. The total weight threshold ... *//** Measures an object's weight to determine how many units of capacity that ... *//** A common set of {@link Weigher} and {@link EntryWeigher} implementations. ... *//** A entry weigher backed by the specified weigher. The weight of the value ... */new EntryWeigherView<K,V>(...)/** A weigher where an entry has a weight of <tt>1</tt>. A map bounded with ... */SingletonEntryWeigher.INSTANCE/** A weigher where a value has a weight of <tt>1</tt>. A map bounded with ... */SingletonWeigher.INSTANCE/** A weigher where the value is a byte array and its weight is the number of ... */ByteArrayWeigher.INSTANCE/** A weigher where the value is a {@link Iterable} and its weight is the ... */IterableWeigher.INSTANCE/** A weigher where the value is a {@link Collection} and its weight is the ... */CollectionWeigher.INSTANCE/** A weigher where the value is a {@link List} and its weight is the number ... */ListWeigher.INSTANCE/** A weigher where the value is a {@link Set} and its weight is the number ... */SetWeigher.INSTANCE/** A weigher where the value is a {@link Map} and its weight is the number of ... */MapWeigher.INSTANCEWeigher<? super V> weigher;new SingletonEntryWeigher(...)SingletonEntryWeigher INSTANCE;new SingletonWeigher(...)SingletonWeigher INSTANCE;new ByteArrayWeigher(...)ByteArrayWeigher INSTANCE;value.lengthnew IterableWeigher(...)IterableWeigher INSTANCE;new CollectionWeigher(...)CollectionWeigher INSTANCE;new ListWeigher(...)ListWeigher INSTANCE;new SetWeigher(...)SetWeigher INSTANCE;new MapWeigher(...)MapWeigher INSTANCE;/** This class represents an error that is thrown when a bug is ... */String message;// message stringException exception;// optional exception/** constructs a bug error using the given text ... *//** Constructs a bug error using the given exception ... *//** Constructs a bug error using the given exception and ... */this.exceptionthis.message/** Returns a String representation of this class by calling <code>getMessage()</code>. ... *//** Returns the detail message string of this error. The message ... *//** Returns the bug text to describe this error *//** Sets the bug text to describe this error */boolean fatal;this.fatal/** An interface for use by all Groovy compiler exceptions. */import MixinNodeint FS;int PUBLIC_FS;ClassNode enumClassGenericsType gtOpcodes.ACC_ENUMMixinNode.EMPTY_ARRAYClassHelper.Enum_Type// set super class and generics info// "enum X" -> class X extends Enum<X>import static ClassHelper.isPrimitiveByteimport static ClassHelper.isPrimitiveCharimport static ClassHelper.isPrimitiveDoubleimport static ClassHelper.isPrimitiveFloatimport static ClassHelper.isPrimitiveIntimport static ClassHelper.isPrimitiveLongimport static ClassHelper.isPrimitiveShortisPrimitiveInt(...)isPrimitiveLong(...)isPrimitiveDouble(...)isPrimitiveByte(...)isPrimitiveChar(...)isPrimitiveFloat(...)isPrimitiveShort(...)/** Base class for any AST node. This class supports basic information used in all nodes of the AST: ... */int lineNumber;int columnNumber;int lastLineNumber;int lastColumnNumber;Map<?,?> metaDataMap;this.lineNumberthis.columnNumberthis.lastLineNumberthis.lastColumnNumber/** Sets the source position using another ASTNode. ... *//** Copies all node meta data from the other node to this one ... */copyNodeMetaData(...)/** Base class for any AST node which is capable of being annotated */List<AnnotationNode> annotations;ClassNode declaringClass;boolean synthetic;List<AnnotationNode> retCollections.EMPTY_LISTthis.declaringClassGroovydoc.EMPTY_GROOVYDOC/** Returns true for default constructors added by the compiler. ... */removeNodeMetaData(...)/** Indicates if this node was added by the compiler. ... *//** Sets this node as a node added by the compiler. ... */this.syntheticimport static Objects.requireNonNull/** Represents an annotation which can be attached to interfaces, classes, methods, fields, parameters, and other places. */int CONSTRUCTOR_TARGET;int METHOD_TARGET;int FIELD_TARGET;int PARAMETER_TARGET;int LOCAL_VARIABLE_TARGET;int ANNOTATION_TARGET;int PACKAGE_TARGET;int TYPE_PARAMETER_TARGET;int TYPE_USE_TARGET;int RECORD_COMPONENT_TARGET;int TYPE_TARGET;int ALL_TARGETS;//GROOVY-7151Map<String,Expression> members;boolean runtimeRetention, ...;int allowedTargets;this.classNodenew LinkedHashMap<String,Expression>(...)assertMembers(...)/** Flag corresponding to <code>RetentionPolicy.RUNTIME</code>. ... */this.runtimeRetention/** Sets the internal flag if the current annotation has ... *//** Flag corresponding to <code>RetentionPolicy.SOURCE</code>. ... */this.sourceRetention/** Sets the internal flag if the current annotation has <code>RetentionPolicy.SOURCE</code>. ... *//** Flag corresponding to <code>RetentionPolicy.CLASS</code>. ... */this.classRetention/** Sets the internal flag if the current annotation has an explicit <code>RetentionPolicy.CLASS</code>. ... */this.allowedTargetsStringBuilder memberTextEntry<String,Expression> nextMap<>.Entry<String,Expression>new Function<Expression,String>(...) { ... }/* explicit */import StringJoiner/** Helper class for converting AST into text. */String typegetClassText(...)StringJoiner resultnew StringJoiner(...)getParameterText(...)exceptions.lengthClassNode exceptionisNative(...)isSynchronized(...)isTransient(...)isVolatile(...)import ExpressionTransformer/** Transforms expressions in a whole class. Transformed expressions are usually not visited. */transformExpression(...)Entry<String,Expression> entryvisitConstructorOrMethod(...)isParameterSpecified(...)visitClosureExpression(...)visitClassCodeContainer(...)// statements:setBooleanExpression(...)getBooleanExpression(...)setMessageExpression(...)getMessageExpression(...)setExpression(...)getLoopBlock(...)setCollectionExpression(...)getCollectionExpression(...)getIfBlock(...)getElseBlock(...)CaseStatement caseStatementgetCaseStatements(...)getDefaultStatement(...)/** Transfers the source position to target including its property expression if it has one. ... */// "for(T x : y)" or "for(x in y)"import ErrorCollectingvisitPackage(...)visitImports(...)visitContents(...)visitObjectInitializerStatements(...)isBuiltIn(...)ImportNode importStarNodeImportNode importStaticNodeImportNode importStaticStarNodegetObjectInitializerStatements(...)visitDeclarationExpression(...)visitStatement(...)visitCaseStatement(...)visitCatchStatement(...)visitDoWhileLoop(...)visitExpressionStatement(...)visitForLoop(...)visitIfElse(...)visitSwitch(...)visitSynchronizedStatement(...)visitThrowStatement(...)visitTryCatchFinally(...)visitWhileLoop(...)// skip built-in propertiesimport GroovyInterceptableimport Rangeimport Tuple0import Tuple1import Tuple10import Tuple11import Tuple12import Tuple13import Tuple14import Tuple15import Tuple16import Tuple4import Tuple5import Tuple6import Tuple7import Tuple8import Tuple9import ManagedIdentityConcurrentMapimport TypeUtilimport GeneratedLambdaimport SerializedLambdaimport static StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf/** Helper for {@link ClassNode} and classes handling them.  Contains a set of ... */Character.TYPEByte.TYPEShort.TYPEInteger.TYPELong.TYPEFloat.TYPEGString.classRange<>.classPattern.classCharacter.classByte.classShort.classLong.classDouble.classFloat.classBigDecimal.classBigInteger.classNumber.classReference<>.classIterator<>.classGeneratedLambda.classTuple0.classTuple1<>.classTuple2<>.classTuple3<>.classTuple4<>.classTuple5<>.classTuple6<>.classTuple7<>.classTuple8<>.classTuple9<>.classTuple10<>.classTuple11<>.classTuple12<>.classTuple13<>.classTuple14<>.classTuple15<>.classTuple16<>.classBinding.classThrowable.classboolean.classchar.classbyte.classlong.classshort.classdouble.classfloat.classAnnotation.classElementType.classAutoCloseable.classSerializable.classSerializedLambda.classOverride.classDeprecated.classEnum<>.classTuple<>.classStream<>.classIterable<>.classComparable<>.classGroovyInterceptable.classinverse(...)toSet(...)...[] classes;...[] TUPLE_CLASSES;...[] primitiveClassNames;ClassNode OBJECT_TYPE, ...;ClassNode DYNAMIC_TYPE;...[] types;String DYNAMIC_TYPE_METADATA;...[] EMPTY_TYPE_ARRAY;String OBJECT;SoftReference<ClassNode> classNodeSoftReferenceClassHelperCache.classCachenew SoftReference<ClassNode>(...)setAdditionalClassInformation(...)/** Creates an array of ClassNodes using an array of classes. ... */ClassNode[] cnsclasses.lengthcns.length/** Creates a ClassNode using a given class. ... */ClassNode cachedClassNode tcn.isPrimaryNodeprimitiveClassNames.lengthString cnameMap<ClassNode,ClassNode> PRIMITIVE_TYPE_TO_WRAPPER_TYPE_MAP;/** Creates a ClassNode containing the wrapper of a ClassNode ... */Map<ClassNode,ClassNode> WRAPPER_TYPE_TO_PRIMITIVE_TYPE_MAP;/** Test to determine if a ClassNode is a primitive type. ... *//** Test to determine if a ClassNode is a type belongs to the list of types which ... */ClassNode cachedTypenew ManagedIdentityConcurrentMap<Class<>,SoftReference<ClassNode>>(...)ManagedIdentityConcurrentMap<Class<>,SoftReference<ClassNode>> classCache;findSAM(...)isSAMType(...)/** Checks if the type is a generated function, i.e. closure or lambda. ... */implementsAnyInterfaces(...)/** Returns the single abstract method of a class node, if it is a SAM type, or null otherwise. ... */MethodNode samMethodNode mnhasUsableImplementation(...)MethodNode foundgetCompileUnit(...)/** Returns a super class or interface for a given class depending on supplied ... */getNextSuperClass(...)ClassNode facegetUnresolvedInterfaces(...)implementsInterfaceOrIsSubclassOf(...)getUnresolvedSuperClass(...)Set<String> OBJECT_METHOD_NAME_SET;// uncached constants// the next items require conversion to int when initializing// Functional interface must be an interface at first, or the following exception will occur:// java.lang.invoke.LambdaConversionException: Functional interface SamCallable is not an interface// ignore methods that will have an implementation// Avoid unnecessary checking for `Object` methods as possible as we could// we have two methods, so no SAM// GROOVY-10540: GroovyObject declared and Verifier not run yet//ACC_ABSTRACT|ACC_STATIC|ACC_PROTECTED|ACC_PRIVATE|ACC_PUBLICimport ClassNodeUtilsimport FieldExpressionimport ParameterUtilsimport EnumMapimport static MethodNodeUtils.getCodeAsBlockimport static ClassHelper.SEALED_TYPEimport static RecordTypeASTTransformation.recordNativeimport static Opcodes.ACC_ABSTRACTimport static Opcodes.ACC_ANNOTATIONimport static Opcodes.ACC_ENUMimport static Opcodes.ACC_INTERFACE/** Represents a class in the AST. ... */new ArrayList<ClassNode>(...)Map<Object,List<MethodNode>> map;new Function<Map<Object,List<MethodNode>>,List<MethodNode>>(...) { ... }new Supplier<List<MethodNode>>(...) { ... }new LinkedHashMap<Object,List<MethodNode>>(...)new Function<Object,List<MethodNode>>(...) { ... }new ArrayList<MethodNode>(...)ClassNode THIS;ClassNode SUPER;int modifiers;boolean syntheticPublic;...[] mixins;List<Statement> objectInitializers;List<ConstructorNode> constructors;MapOfLists methods;List<MethodNode> methodsList;List<FieldNode> fields;List<PropertyNode> properties;Map<String,FieldNode> fieldIndex;CompileUnit compileUnit;boolean staticClass;boolean scriptBody;boolean script;ClassNode superClass;boolean isPrimaryNode;List<InnerClassNode> innerClasses;List<ClassNode> permittedSubclasses;List<AnnotationNode> typeAnnotations;List<RecordComponentNode> recordComponents;Map<CompilePhase,Map<Class<? extends ASTTransformation>,Set<ASTNode>>> transformInstances;/** The AST Transformations to be applied during compilation. */Object lazyInitLock;// use this to synchronize access for the lazy init// clazz!=null when resolvedboolean lazyInitDone;// only false when this classNode is constructed from a classClassNode componentType;// not null if if the ClassNode is an arrayClassNode redirect;// for the redirect// if not null this instance is handled as proxyboolean annotated;// flag if the classes or its members are annotated...[] genericsTypes;// type spec for genericsboolean usesGenerics;boolean placeholder;// of 1 element describing the name of the placeholder// if set to true the name getGenericsTypes consists/** Returns the {@code ClassNode} this node is a proxy for or the node itself. *//** Sets this instance as proxy for the given {@code ClassNode}. ... */isGenericsPlaceHolder(...)/** Returns a {@code ClassNode} representing an array of the type represented ... */node.componentTypeClass<?> typeredirect(...).isPrimaryNode/** Constructor used by {@code makeArray()} if no real class is available. */this.componentType/** Constructor used by {@code makeArray()} if a real class is available. *//** Creates a non-primary {@code ClassNode} from a real class. *//** The complete class structure will be initialized only when really needed ... */configureClassNode(...)MethodNode enclosingMethod;/** Tracks the enclosing method for local inner classes. */redirect(...).enclosingMethod/** Indicates that this class has been "promoted" to public by Groovy when in ... */this.syntheticPublicthis.modifiersthis.superClassthis.mixinsnew Predicate<ClassNode>(...) { ... }new MapOfLists(...)/** Sets the superclass of this {@code ClassNode}. */redirect(...).superClasslazyClassInit(...)getPermittedSubclasses(...)setPermittedSubclasses(...)this.permittedSubclassesredirect(...).mixinsnew Predicate<MethodNode>(...) { ... }Set<ClassNode> resultnew LinkedHashSet<ClassNode>(...)getAllInterfaces(...)Map<String,MethodNode> resultgetDeclaredMethodsFromSuper(...)redirect(...).nameredirect(...).modifiersnew ArrayList<PropertyNode>(...)new ArrayList<ConstructorNode>(...)ConstructorNode constructorparametersEqual(...)redirect(...).modulenew Function<ModuleNode,PackageNode>(...) { ... }redirect(...).compileUnitgetUnit(...)ClassNode rsetDeclaringClass(...)setOwner(...)r.fieldsr.fieldIndexnew LinkedHashMap<String,FieldNode>(...)PropertyNode nodesetGetterBlock(...)setSetterBlock(...)new Function<PropertyNode,String>(...) { ... }new Predicate<String>(...) { ... }new Predicate<PropertyNode>(...) { ... }r.constructorsConstructorNode nodenew ConstructorNode(...)r.methodsListr.methods/** If a method with the given name and parameters is already defined then it is returned ... */MethodNode otherMethodNode node/** Adds a synthetic method as part of the compilation process. */FieldNode nodeaddFieldFirst(...)(...).componentTypeMixinNode[] mixinsgetMixins(...)MixinNode existingMixinNode[] newMixinsnew MixinNode[]mixins.length/** Finds a field matching the given name in this class. ... *//** Finds a field matching the given name in this class or a parent class. ... */getOuterField(...)ClassNode outerList<ClassNode> result/** Adds a statement to the object initializer. ... */String classInitializerList<MethodNode> declaredMethodsgetOrAddStaticConstructorNode(...)getCodeAsBlock(...)addStatements(...)List<Statement> blockStatementsMethodNode constructorListIterator<Statement> litrBinaryExpression bExpFieldExpression fExpgetFieldName(...)Statement tmpStmt/** This methods returns a list of all methods of the given name ... *//** This methods creates a list of all methods with this name of the ... */List<MethodNode> result/** Finds a method matching the given name and parameters in this class. ... *//** Finds a method matching the given name and parameters in this class ... */ClassHelper.GROOVY_OBJECT_TYPEdeclaresInterface(...)ClassNode snsetCompileUnit(...)visitField(...)ConstructorNode cnvisitConstructor(...)visitMethods(...)List<MethodNode> methodListList<MethodNode> newMethodListvisitMethod(...)List<MethodNode> changedMethodListgetGetterMethod(...)MethodNode getterMethodboolean booleanReturnOnlyisVoidMethod(...)/** Is this class declared in a static method (such as a closure / inner class declared in a static method) */redirect(...).staticClassredirect(...).scriptBodyredirect(...).scriptClassHelper.SCRIPT_TYPEboolean placeholderStringBuilder retgetUnresolvedName(...)/** Determines if the type has a possibly-matching instance method with the given name and arguments. ... */hasCompatibleNumberOfArgs(...)ClassNode inisDefault(...)TupleExpression argsint nArgsboolean matchhasCompatibleType(...)hasExactMatchingCompatibleType(...)int lastParamIndexisPotentialVarArg(...)/** Checks if the given method has a possibly matching static method with the ... */hasPossibleStaticMethod(...)/** Checks if the {@link ClassNode} instance represents a native {@code record}. ... */recordNative(...)/** Gets the record components of record type. ... */getRecordComponents(...)/** Sets the record components for record type. ... */setRecordComponents(...)this.recordComponentsisSealed(...)/** Returns the concrete class this classnode relates to. However, this method ... */ClassNode componentredirect(...).componentType/** Marks if the current class uses annotations or not. */this.annotatedClassNode upperthis.genericsTypesthis.placeholderthis.usesGenericsClassNode nn.isPrimaryNoden.componentTypeGroovyASTTransformation annotationgetAnnotation(...)GroovyASTTransformation.classMap<Class<? extends ASTTransformation>,Set<ASTNode>> transformsgetTransforms(...)phase(...)Set<ASTNode> nodesnew Function<Class<? extends ASTTransformation>,Set<ASTNode>>(...) { ... }new LinkedHashSet<ASTNode>(...)getTransformInstances(...)Map<String,FieldNode> indexnew EnumMap<CompilePhase,Map<Class<? extends ASTTransformation>,Set<ASTNode>>>(...)CompilePhase.classCompilePhase phasenew LinkedHashMap<Class<? extends ASTTransformation>,Set<ASTNode>>(...)addTypeAnnotation(...)// don't use the ClassHelper here!// add in the methods implemented in this class// don't add duplicate methods// append interface// arrays could be "T[]" or "[LT;"// let's check if it already uses a mixin// while anything inside a static initializer block is appended// we don't want to append in the case we have a initialization// expression of a static field. In that case we want to add// before the other statements// add given statements for explicitly declared static fields just after enum-special fields// are found - the $VALUES binary expression marks the end of such fields.// now let's visit the contents of the class// create snapshot of the method list to avoid ConcurrentModificationException// visit the method nodes added while iterating,// e.g. synthetic method for constructor reference// if the newly added method nodes found, visit them// GROOVY-7363: There can be multiple matches for a getter returning a generic parameter type, due to// the generation of a bridge method. The real getter is really the non-bridge, non-synthetic one as it// has the most specific and exact return type of the two. Picking the bridge method results in loss of// type information, as it down-casts the return type to the lower bound of the generic parameter.// TODO: this won't strictly be true when using list expansion in argument calls// prefer super method if it matches betterimport BytecodeExpression/** Abstract base class for any GroovyCodeVisitor which by default ... */Statement resourceStatement catchStatementafterSwitchConditionExpressionVisited(...)Statement caseStatementgetTrueExpression(...)getFalseExpression(...)visitTernaryExpression(...)visitListOfExpressions(...)getSizeExpression(...)getValueExpression(...)getMethodName(...)visitMethodPointerExpression(...)visitBinaryExpression(...)getValues(...)visitTupleExpression(...)// hook for subclass to do something after switch condition, but before case(s)/** Represents the entire contents of a compilation step which consists of one or ... */new ArrayList<ModuleNode>(...)new LinkedHashMap<String,ClassNode>(...)new LinkedHashMap<String,SourceUnit>(...)new LinkedHashMap<String,InnerClassNode>(...)List<ModuleNode> modules;Map<String,ClassNode> classes;Map<String,ClassNode> classesToCompile;Map<String,SourceUnit> classNameToSource;Map<String,InnerClassNode> generatedInnerClasses;List<ClassNode> answerModuleNode modulesetUnit(...)addClasses(...)/** Appends all of the fully-qualified class names in this ... *//** Adds a class to the unit. */ClassNode storedSourceUnit nodeSourceSourceUnit storedSourceString txtisScriptBody(...)/** this method actually does not compile a class. It's only ... */String nodeName// null means a compilation error prevented groovy from building an AST// we have a duplicate class!// One possibility for this is, that we declared a script and a// class in the same file and named the class like the file// same class in same source/** Represents a constructor declaration */getFirstStatement(...)// declaration, or the "it" argument to a closure.// An implicitly created variable, such as a variable in a script that's doesn't have an explicitboolean closureShare;boolean staticContext;/** Represents the anonymous inner class for an enum constant. This subtype is ... *//** Represents a field (member variable) */ClassNode type;ClassNode owner;Expression initialValueExpression;boolean dynamicTyped;boolean holder;ClassNode originType;ClassNode fldTypethis.initialValueExpressionthis.originTypeisDynamicTyped(...)renameField(...)import WideningCategories/** This class is used to describe generic type signatures for ClassNodes. ... */ClassNode lowerBound;...[] upperBounds;boolean placeholder, ...;this.lowerBoundthis.upperBoundsboolean wildcardgetLowerBound(...)getUpperBounds(...)genericsBounds(...)upperBounds.lengthClassHelper.OBJECTappendName(...)GenericsType typeString parentClassNodeNamethis.resolvedthis.wildcard/** Determines if the provided type is compatible with this specification. ... */ClassNode upperBoundcheckGenerics(...)compareGenericsWithBound(...)/** Compares the bounds of this generics specification against the given type ... *//** Given a parameterized type (List&lt;String&gt; for example), checks that its ... */GenericsType[] cnTypesGenericsType[] redirectBoundGenericTypesMap<GenericsTypeName,GenericsType> boundPlaceHoldersextractPlaceholders(...)Map<GenericsTypeName,GenericsType> classNodePlaceholdersparameterizeType(...)WideningCategories.LowestUpperBoundClassNodeallMatch(...)redirectBoundGenericTypes.lengthGenericsType redirectBoundTypeGenericsType classNodeTypeGenericsTypeName namenew GenericsTypeName(...)GenericsTypeName gtnGenericsType boundGenericsTypeisCompatibleWith(...)getOrDefault(...)/** Represents {@link GenericsType} name. ... */// TODO: ensure type is not primitive// T extends Object should just be printed as T// GROOVY-10583// diamond always matches// check for "? super T" vs "T"// check for "? extends T & I" vs "T" or "I"// check for "? extends/super X" vs "T extends/super X"// test bound and type in reverse for lower bound vs upper bound// check that provided type extends or implements all upper bounds// if the provided type is a subclass of the upper bound(s) then// check that the generic types supplied are compatible with this// for example, this spec could be "Type<X>" but type is "Type<Y>"// if there are no bounds, the generic type is basically Object and everything is compatible// not placeholder or wildcard; no covariance allowed for type or bound(s)// GROOVY-10556: "T" vs "C<T extends C<?>>" bound// if the bound is not using generics or the class node is a raw type, there's nothing to compare// the class nodes are on different types// in this situation, we must choose the correct execution path : either the bound// is an interface and we must find the implementing interface from the classnode// to compare their parameterized generics, or the bound is a regular class and we// must compare the bound with a superclass// iterate over all interfaces to check if any corresponds to the bound we are// comparing to// when we obtain an interface, the types represented by the interface// class node are not parameterized. This means that we must create a// new class node with the parameterized types that the current class node// has defined.// another special case here, where the bound is a "virtual" type// we must then check the superclass and the interfaces// may happen if generic type is Foo<T extends Foo> and ClassNode is Foo -> Foo// ? supports single bound only// ex: class Comparable<Integer> <=> bound Comparable<? super T>// check for recursive generic typedef, like in <T extends Comparable<? super T>>// GROOVY-6095, GROOVY-9338// "?" (from Comparable<?>) does not satisfy anything// ex: class Comparable<Integer> <=> bound Comparable<? extends T & I>// GROOVY-10576: "?" vs "? extends Object" (citation required) or no match// GROOVY-10010// TODO: the check for isWildcard should be replaced with a more complete check/** A special visitor for working with the structure of a class. In general, your ... *//** Visit a ClassNode. *//** Visit a ConstructorNode. *//** Visit a MethodNode. *//** Visit a FieldNode. *//** Visit a PropertyNode. *//** An implementation of the visitor pattern for working with ASTNodes. */// statements// expressions// expressions:visitListExpression(...)visitBooleanExpression(...)/** Returns the inverse view of this map, and duplicated key is not allowed ... *//** Returns the inverse view of this map ... */Map<V,K> resultMapnew LinkedHashMap<V,K>(...)/** Represents an import statement. */String alias;String fieldName;String packageName;boolean isStar;/** An import of a single type, i.e.&#160;{@code import pack.Type} or {@code import pack.Type as Alias} ... */this.aliasthis.isStarthis.packageNamethis.fieldName/** An import of all types in a package, i.e.&#160;{@code import pack.*} ... *//** An import of all static members of a type, i.e.&#160;{@code import static pack.Type.*} ... *//** An import of a static field or method of a type, i.e.&#160;{@code import static pack.Type.name} or {@code import static pack.Type.name as alias} ... */String typeNameImportNode nodenode.typeEntry<K,V> entrynode.aliasnode.fieldNamenode.packageNamenode.isStarnode.isStatic// Because we can not rely on 3rd party library(excluding antlr, asm), we have to implement our own utils such as the `inverse` method...// Actually `BiMap` of Guava and `BidiMap` of commons-collections are both suitable for this scenario./** Represents an inner class declaration */ClassNode outerClass;VariableScope scope;boolean anonymous;ClassHelper.EMPTY_TYPE_ARRAYthis.outerClassouterClass.innerClasses/** Represents an inner class defined as helper for an interface */this.scopethis.anonymousList<> callSites;setCallSites(...)import ReaderSourceReaderSource source;/** Attempts to find AstBuilder 'from code' invocations. When found, converts them into calls ... */boolean shouldContinueWalkingisBuildInvocation(...)handleTargetMethodCallExpression(...)/** Reports an error back to the source unit. ... *//** Converts a ClosureExpression into the String source. ... */convertClosureToSource(...)// continue normal tree walkingimport static ClassNodeUtils.formatTypeNameimport static MethodNodeUtils.methodDescriptorimport static GenericsUtils.toGenericTypesStringimport static Opcodes.ACC_FINAL/** Represents a method declaration. */ClassNode returnType;...[] parameters;boolean hasDefaultValue;Statement code;boolean dynamicReturnType;VariableScope variableScope;...[] exceptions;String typeDescriptor;// cached datathis.exceptionsthis.codesetReturnType(...)/** The type descriptor for a method node is a string containing the name of the method, its return type, ... */invalidateCachedData(...)VariableScope scopenew VariableScope(...)this.hasDefaultValuethis.parametersParameter paraputDeclaredVariable(...)setVariableScope(...)this.dynamicReturnTypethis.returnTypethis.variableScopeStatement firstList<Statement> listGroovyCodeVisitor transformergetTransformer(...)ASTNode it/** Sets the flag for this method to indicate it is a script body implementation. ... *//** Indicates that this method has been "promoted" to public by ... */constructorModifiers(...)methodModifiers(...)MissingPropertyException ignoredgetThrowsClauseText(...)getParametersText(...)toGenericTypesString(...)getModifiersText(...)Statement node// todo: inner class nodes don't have a constructors field available// all properties are also always fields// todo: inner class nodes don't have an objectInitializers field available// todo: is there anything to do with the module ???/** Represents a mixin which can be applied to any ClassNode to implement mixins */AnnotatedNode targetExpression useClassesExpression exClassNode targetClassMethodNode clinitaddSyntheticMethod(...)import static GroovyParser.ABSTRACTimport static GroovyParser.NATIVEimport static GroovyParser.PROTECTEDimport static GroovyParser.PUBLICimport static GroovyParser.STRICTFPimport static GroovyParser.SYNCHRONIZEDimport static GroovyParser.TRANSIENTimport static GroovyParser.VOLATILE/** Represents a modifier */Opcodes.ACC_NATIVEOpcodes.ACC_SYNCHRONIZEDOpcodes.ACC_TRANSIENTOpcodes.ACC_VOLATILEOpcodes.ACC_STRICTInteger type;Integer opcode;// ASM opcodeAnnotationNode annotationNode;boolean repeatable;int ANNOTATION_TYPE;Map<Integer,Integer> MODIFIER_OPCODE_MAP;this.opcodeimport BaseScriptASTTransformationimport static GeneralUtils.classX/** Represents a module, which consists typically of a class declaration ... */this.repeatableModifierNode.ANNOTATION_TYPEthis.annotationNode/** Check whether the modifier is not an imagined modifier(annotation, def) */isDef(...)isModifier(...)ModifierNode thatthat.typethat.textthat.annotationNode// no flag for specifying a default method in the JVM spec, hence no ACC_DEFAULT flag in ASM// Only annotations are repeatable/** An interface to mark a node being able to handle metadata. *//** Gets the node meta data. ... */Map<> metaDataMapgetMetaDataMap(...)new ListHashMap<>(...)setMetaDataMap(...)Map<> otherMetaDataMap/** Sets the node meta data. ... */Object old/** Sets the node meta data but allows overwriting values. ... *//** Removes a node meta data entry. ... *//** Returns an unmodifiable view of the current node metadata. ... */new ArrayList<ImportNode>(...)/** Represents a package in the AST. *//** Represents a parameter on a constructor or method call. The type name is ... */Expression defaultValue;boolean inStaticContext;this.defaultValuethis.inStaticContextnew LinkedHashMap<String,ImportNode>(...)/** Represents a property (member variable, a getter and setter) */FieldNode field;Statement getterBlock;Statement setterBlock;String getterName;String setterName;this.getterBlockthis.setterBlock/** If an explicit getterName has been set, return that, otherwise return the default name for the property. ... */String defaultNamehasMethod(...)this.getterNamethis.setterNameisInStaticContext(...)/** Represents record component ... */RecordComponentNode thatClassCodeExpressionTransformer trn;List<ClassNode> classes;this.trnList<MethodNode> methods;List<ImportNode> imports;List<ImportNode> starImports;Map<String,ImportNode> staticImports;Map<String,ImportNode> staticStarImports;CompileUnit unit;PackageNode packageNode;String description;boolean createClassForStatements;SourceUnit context;boolean importsResolved;ClassNode scriptDummy;String mainClassName;BlockStatement statementBlock;isPackageInfo(...)ClassNode mainClasscreateStatementsClass(...)setModule(...)addToCompileUnit(...)visitStaticMethodCallExpression(...)visitShortTernaryExpression(...)getImport(...)Map<String,ImportNode> aliasesvisitPrefixExpression(...)visitNotExpression(...)new Function<Object,Map<String,ImportNode>>(...) { ... }visitArrayExpression(...)visitMapExpression(...)visitMapEntryExpression(...)visitRangeExpression(...)visitSpreadExpression(...)visitSpreadMapExpression(...)visitUnaryMinusExpression(...)visitUnaryPlusExpression(...)visitBitwiseNegationExpression(...)visitCastExpression(...)visitConstantExpression(...)visitClassExpression(...)visitVariableExpression(...)visitAttributeExpression(...)visitFieldExpression(...)visitGStringExpression(...)visitArgumentlistExpression(...)visitClosureListExpression(...)visitBytecodeExpression(...)import static Opcodes.ACC_VOLATILE/** interface to mark a AstNode as Variable. Typically these are ... *//** Returns the name of the variable. *//** Returns the type of the variable. *//** Returns the type before wrapping primitives type of the variable. *//** Returns the expression used to initialize the variable or null of there ... *//** Returns true if there is an initialization expression. *//** Returns true if this variable is used in a static context. ... */new Function<ImportNode,String>(...) { ... }new Function<ImportNode,ImportNode>(...) { ... }/** Records declared and referenced variabes for a given scope.  Helps determine ... */VariableScope parent;ClassNode classScope;Map<String,Variable> declaredVariables;Map<String,Variable> referencedLocalVariables;Map<String,Variable> referencedClassVariables;new BinaryOperator<ImportNode>(...) { ... }/** Non-null iff this scope corresponds to a class; as opposed to a method, "if" statement, block statement, etc. *//** Returns true iff this scope corresponds to a class; as opposed to a method, "if" statement, block statement, etc. */this.classScopenew ImportNode(...)storeLastAddedImportNode(...)/** Gets a map containing the variables declared in this scope. This map cannot be modified. ... *//** Gets a map containing the class variables referenced by this scope. This not can not be modified. ... *//** Gets an iterator for the declared class variables. The remove operation is not supported. ... */ImportNode prevgetDeclaredVariables(...)/** Gets an iterator for the referenced local variables. The remove operation *is* supported. ... *//** Gets an iterator for the referenced class variables. The remove operation is not supported. ... */getReferencedClassVariables(...)new LinkedHashMap<String,Variable>(...)this.packageNodesetPackage(...)new PackageNode(...)this.descriptionsetScriptBaseClassFromConfig(...)encodeAsValidClassName(...)extractClassFromFileDescription(...)setScript(...)setScriptBody(...)String baseClassNamegetScriptBaseClass(...)BaseScriptASTTransformation.MY_TYPEMethodNode existingMainhandleMainMethodIfPresent(...)finalParam(...)VariableScope thatthat.classScopethat.inStaticContextthis.declaredVariablesthat.declaredVariablesthis.referencedLocalVariablesclassX(...)that.referencedLocalVariablesthis.referencedClassVariablessetIsScriptBody(...)that.referencedClassVariablesClassHelper.BINDING_TYPE/* If a main method is provided by user, account for it under run() as scripts generate their own 'main' so they can run. */Iterator<MethodNode> iterimport static DefaultGroovyMethodsSupport.closeQuietly/** This class handles converting Strings to ASTNode lists. *//** Compiles the specified source code and returns its statement block and ... */boolean retTypeMatches/** Compiles the specified source code and returns its statement block, the ... */boolean argTypeMatchesString scriptClassNameClassNode argTypemakeScriptClassName(...)GroovyCodeSource codeSourceClassNode retTypeList<ASTNode> nodesnew ArrayList<ASTNode>(...)int slashIdxint separatorIdxint dotIdxURI uriString schemeSpecificgetSchemeSpecificPart(...)URISyntaxException ignoreList<ClassNode> sortedList<ClassNode> todoint levelgetModules(...)ASTNode statementBlocknanoTime(...)Iterator<ClassNode> itClassNode scthis.classesthis.importsResolved// In order to keep binary compatibility// This method only exists as a workaround for GROOVY-6094ImportNode.class/* Collections.unmodifiableList( *//* ) */// modified by MacroClassTransform// register the new class with the compile unit// now let's use the file name to determine the class name// A script's contextual constructor should call its super class' contextual constructor, if it has one.// In practice this will always be true because currently this visitor is run before the AST transformations// (like @BaseScript) that could change this.  But this is cautious and anticipates possible compiler changes.// Fallback for non-standard base "script" classes with no context (Binding) constructor.// if script has both loose statements as well as main(), then main() is ignored// let's strip off everything after the last '.'// new let's strip everything up to and including the path separators// recalculate in case we have already done some strippingresolveClassNullable(...)annotation.classNamenew DecompiledAnnotationNode(...)annotation.membersimport AnnotationVisitorimport ClassReaderimport FieldVisitorimport MethodVisitorimport RecordComponentVisitorimport TypePathimport BufferedInputStreamimport static CompilerConfiguration.ASM_API_VERSION/** A utility class responsible for decompiling JVM class files and producing {@link ClassStub} objects reflecting their structure. */new ConcurrentHashMap<URI,SoftReference<ClassStub>>(...)addMemberIfFound(...)annotationValueToExpression(...)Map<URI,SoftReference<ClassStub>> stubCache;/** Caches stubs per URI. This cache is useful when performing multiple compilations in the same JVM/class loader and in tests. ... *//** Loads the URL contents and parses them with ASM, producing a {@link ClassStub} object representing the structure of ... */// According to http://michaelscharf.blogspot.jp/2006/11/javaneturlequals-and-hashcode-make.html, use java.net.URI instead.(...).descEnumConstantWrapper wrapperwrapper.constantresolveType(...)wrapper.enumDesccreateAnnotationNode(...)SoftReference<ClassStub> refClassStub stubDecompilingVisitor visitornew DecompilingVisitor(...)InputStream streamnew BufferedInputStream(...)new ClassReader(...)ClassReader.SKIP_FRAMESvisitor.resultnew SoftReference<ClassStub>(...)new AnnotationReader(...) { ... }AsmDecompiler$1stub.membersListExpression elementExprsClassStub result;List<AnnotationStub> annotationsAnnotationStub annotationnew ClassStub(...)fromInternalName(...)List<TypeAnnotationStub> annotationsgetTypeAnnotations(...)TypeAnnotationStub annotationresult.classNameresult.innerClassModifiersObject initLock;MethodStub stubnew MethodStub(...)result.methodsconfigureAnnotationNodeFromDefinition(...)new ArrayList<MethodStub>(...)lazyInit(...)isTargetAllowed(...)hasRuntimeRetention(...)hasSourceRetention(...)hasClassRetention(...)// there might be annotations not present in the classpath// e.g. java.lang.Synthetic (http://forge.ow2.org/tracker/?aid=307392&group_id=23&atid=100023&func=detail)// so skip them/** A helper class used to resolve references found in ASM-decompiled classes. ... */ClassNodeResolver resolver;this.resolvernew NoClassDefFoundError(...)ClassNode beingCompiledClassNodeResolver.LookupResultLookupResult lookupResultresolveName(...)getSort(...)Type.ARRAYresolveNonArrayType(...)getElementType(...)getDimensions(...)Type.OBJECTnew MethodVisitor(...) { ... }AsmDecompiler$DecompilingVisitor$1readAnnotationMembers(...)List<AnnotationStub> liststub.parameterAnnotationsimport RecordComponentNodeimport SignatureReaderimport SignatureVisitornew Function<Integer,List<AnnotationStub>>(...) { ... }stub.signatureparseClassSignature(...)stub.superNameint nInterfacesstub.interfaceNames.lengthstub.interfaceNamesnew ArrayList<AnnotationStub>(...)stub.permittedSubclassesAnnotationStub annotationStubnew AnnotationStub(...)List<ClassNode> permittedClassNode psnew HashMap<Integer,List<AnnotationStub>>(...)stub.recordComponentsAsmDecompiler$DecompilingVisitor$1$1stub.annotationDefaultstub.parameterNamesnew Function<RecordComponentStub,RecordComponentNode>(...) { ... }ClassNode[] typerc.descriptorClassNode rcTypeRecordComponentNode recordComponentnew RecordComponentNode(...)rc.namerc.signaturenew SignatureReader(...)new TypeSignatureParser(...) { ... }ClassSignatureParser$1applyErasure(...)List<ClassNode> interfacesFormalParameterParser parsernew FormalParameterParser(...) { ... }ClassSignatureParser$2flushTypeParameter(...)ClassSignatureParser$2$1ClassSignatureParser$2$2GenericsType[] typeParametersgetTypeParameters(...)typeParameters.length// collector/** Data structures holding class info to enable lazy loading */result.permittedSubclassesRecordComponentStub recordComponentStubnew RecordComponentStub(...)result.recordComponentsnew RecordComponentVisitor(...) { ... }AsmDecompiler$DecompilingVisitor$2FieldStub stubnew FieldStub(...)result.fieldsnew ArrayList<FieldStub>(...)new ArrayList<RecordComponentStub>(...)new FieldVisitor(...) { ... }AsmDecompiler$DecompilingVisitor$3visitAttribute(...)new TypeWrapper(...)String className;int accessModifiers;getDescriptor(...)String superName;...[] interfaceNames;List<MethodStub> methods;List<FieldStub> fields;List<String> permittedSubclasses;List<RecordComponentStub> recordComponents;new EnumConstantWrapper(...)int innerClassModifiers;// Used to store the real access modifiers for inner classesthis.classNamethis.accessModifiersthis.signaturethis.superNamethis.interfaceNamesAnnotationStub stubList<Object> listnew ArrayList<Object>(...)List<AnnotationStub> annotations;AsmDecompiler$AnnotationReader$1String methodName;String desc;Map<Integer,List<AnnotationStub>> parameterAnnotations;List<String> parameterNames;/* Class files generated for inner classes have an INNERCLASS ... */Object annotationDefault;this.methodNamethis.desc/** A {@link ClassNode} kind representing the classes coming from *.class files decompiled using ASM. ... */new LinkedHashMap<String,Object>(...)ClassStub classData;AsmReferenceResolver resolver;classData.classNamethis.classData/** Handle the case of inner classes returning the correct modifiers from ... */classData.innerClassModifiersclassData.accessModifiersclassData.fieldsFieldStub fieldfield.accessModifiersLong timestampgetTimestampFromFieldName(...)field.fieldNameresolveJvmClass(...)classData.signatureclassData.annotationsstub.classNameNoClassDefFoundError ignoredlazyInitSupers(...)boolean supersInitialized;configureClass(...)lazyInitMembers(...)boolean membersInitialized;classData.methodsMethodStub methodmethod.methodNamecreateConstructor(...)createMethodNode(...)createFieldNode(...)Supplier<FieldNode> fieldNodeSuppliernew Supplier<FieldNode>(...) { ... }new LazyFieldNode(...)Supplier<MethodNode> methodNodeSuppliernew Supplier<MethodNode>(...) { ... }method.accessModifiersnew LazyMethodNode(...)Supplier<ConstructorNode> constructorNodeSuppliernew Supplier<ConstructorNode>(...) { ... }new LazyConstructorNode(...)// check Groovy "sealed"// check Java "sealed"Map<String,Object> members;String enumDesc;String constant;this.enumDescthis.constantString descriptor;List<TypeAnnotationStub> typeAnnotations;this.descriptorTypeAnnotationStub stubnew TypeAnnotationStub(...)new ArrayList<TypeAnnotationStub>(...)import Java8import LazyInitializableimport GroovyCodeVisitorimport VariableScope/** Represents lazy constructor node, which will be initialized only when accessed ... */Supplier<ConstructorNode> constructorNodeSupplier;ConstructorNode delegate;this.constructorNodeSuppliernew ArrayList<GenericsType>(...)firstStatementIsSpecialConstructorCall(...)hasDefaultValue(...)isDynamicReturnType(...)isPackageScope(...)hasAnnotationDefault(...)String currentTypeParameter;List<ClassNode> parameterBounds;List<GenericsType> typeParameters;isStaticConstructor(...)ClassNode refconfigureTypeVariableReference(...)ClassNode[] theBoundTypesconfigureTypeVariableDefinition(...)FormalParameterParser$1visitClassBound(...)getGroovydoc(...)hasNoRealSourcePosition(...)setHasNoRealSourcePosition(...)/** Represents lazy field node, which will be initialized only when accessed ... */Supplier<FieldNode> fieldNodeSupplier;FieldNode delegate;this.fieldNodeSupplierClassNode ownerisHolder(...)setHolder(...)setOriginType(...)rename(...)/** Represents lazy method node, which will be initialized only when accessed ... */Supplier<MethodNode> methodNodeSupplier;MethodNode delegate;this.methodNodeSupplier/** Utility methods for lazy class loading. */field.descfield.signatureMemberSignatureParser$1nonGeneric(...)field.valueClassNode[] returnTypemethod.descgetArgumentTypes(...)ClassNode[] exceptionTypesmethod.exceptionsList<String> parameterNamesmethod.parameterNamesmethod.signatureMemberSignatureParser$2int exceptionIndex, ...;MemberSignatureParser$2$1MemberSignatureParser$2$2MemberSignatureParser$2$3String decompiledNamemethod.parameterAnnotationsEntry<Integer,List<AnnotationStub>> entryMap<>.Entry<Integer,List<AnnotationStub>>String baseName;List<GenericsType> arguments;finished(...)Object annDefaultmethod.annotationDefaultTypeSignatureParser outerTypeSignatureParser$1createWildcard(...)TypeSignatureParser$2names.lengthClassNode[] nodesClassNode[] upperClassNode lowerisNotParameterized(...)// ex: java.util.Collections#EMPTY_LIST/EMPTY_MAP/EMPTY_SETClassNode parameterizedType// seems wrong but otherwise some tests fail (e.g. TestingASTTransformsTest)GenericsType argumentClassNode[] implicitBoundsStackOverflowError ignoreClassNode baseGenericsType t/** Represents an annotation "constant" that may appear in annotation attributes ... */isParameterized(...)Map<String,Expression> attrs// GROOVY-10234: no type arguments -> raw type// GROOVY-10153, GROOVY-10651, GROOVY-10671: "?" or "? super T" (see ResolveVisitor#resolveWildcardBounding)// bound is not Object// TODO: self-referential type parameter// DecompiledClassNode may not have generics initialized/** Represents one or more arguments being passed into a method */ArgumentListExpression EMPTY_ARGUMENTS;// GROOVY-9980Expression rettransformExpressions(...)/** Represents an array object construction. ... */List<Expression> initExpressions;List<Expression> sizeExpressions;ClassNode elementType;ClassNode ret/** Represents an attribute access (accessing the field of a class) such as the expression "foo.@bar". */AttributeExpression retsetStatic(...)import Variable/** Represents two expressions and an operation */Expression leftExpression;Expression rightExpression;Token operation;boolean safe;this.leftExpressionthis.rightExpressionthis.operationthis.safethis.elementTypethis.sizeExpressionsthis.initExpressionsformatSizeExpressions(...)formatInitExpressions(...)new ClassCastException(...)/** Creates an assignment expression in which the specified expression ... */hasInitializer(...)VariableExpression lhsToken operatornewPlaceholder(...)/** Creates variable initialization expression in which the specified expression ... *//** Creates an array using an initializer (list of expressions corresponding to array elements) *//** Add another element to the initializer expressions *//** Get the initializer expressions */List<Expression> exprListList<Expression> sizes/** Get a particular initializer expression */Expression expression;this.expression/** Represents a boolean expression */// for consistency with AsmClassGenerator. see AsmClassGenerator.visitBooleanExpression./** Represents a typecast expression. */boolean ignoreAutoboxing;boolean coerce;boolean strict;CastExpression answersetCoerce(...)this.ignoreAutoboxingthis.coerce/** If strict mode is true, then when the compiler generates a cast, it will ... */this.strictCastExpression retisIgnoringAutoboxing(...)isCoerce(...)setStrict(...)isStrict(...)// TODO: add alternate for "as"?/** Represents access to a Java/Groovy class in an expression, such ... */import static AstToTextHelper.getParametersTextimport static ClosureUtils.hasImplicitParameter/** Represents a closure expression such as <pre>{ statement }</pre> ... */ClassHelper.CLOSURE_TYPE/** This gets the code statement of the closure. You can read this method to find out what actions ... *//** This sets the code statement of the closure. You can use this method in order to add more actions ... *//** This class represents a list of expressions used to ... *//** Represents a constant expression such as null, true, false. */ConstantExpression NULL;// compare against the field but call isXXXExpression() instead.// has its own instance so as to preserve line information. Consequently, to test for such an expression, don't// The following fields are only used internally; every occurrence of a user-defined expression of the same kindConstantExpression TRUE;ConstantExpression FALSE;ConstantExpression EMPTY_STRING;ConstantExpression PRIM_TRUE;ConstantExpression PRIM_FALSE;ConstantExpression VOID;// the following fields are only used internally; there are no user-defined expressions of the same kindConstantExpression EMPTY_EXPRESSION;String constantName;this.constantName//TODO: more cases here/** A constructor call. */Expression arguments;boolean usesAnonymousInnerClass;visitConstructorCallExpression(...)ConstructorCallExpression answerisUsingAnonymousInnerClass(...)isSuperCall(...)isThisCall(...)this.usesAnonymousInnerClass/** Represents one or more local variables. Typically it is a single local variable ... *//** Creates a declaration like "def v" or "int w = 0". ... *//** Creates a declaration like "def v" or "int w = 0" or "def (x, y) = [1, 2]". ... */newSymbol(...)getStartLine(...)getStartColumn(...)check(...)/** Represents a short ternary expression x ?: y, which is equal ... */getBool(...)BooleanExpression be/** This method returns the left hand side of the declaration cast to the VariableExpression type. ... */Expression leftExpression/** This method returns the left hand side of the declaration cast to the TupleExpression type. ... */isMultipleAssignmentDeclaration(...)VariableExpression vgetVariableExpression(...)TupleExpression tgetTupleExpression(...)setLength(...)/** This method sets the leftExpression for this BinaryExpression. The parameter must be ... *//** Placeholder for an empty expression. Empty expressions are used in closures ... */new EmptyExpression(...) { ... }EmptyExpression$1/** This method tells you if this declaration is a multiple assignment declaration, which ... */// all good// ASTNode overrides:throwUnsupportedOperationException(...)// AnnotatedNode overrides:// Expression overrides:visitEmptyExpression(...)EmptyExpression INSTANCE;/** Immutable singleton that is recommended for use when source range or any ... *//** Represents a base class for expressions which evaluate as an object *//** Return a copy of the expression calling the transformer on any nested expressions ... *//** Transforms the list of expressions ... *//** Provides a way to transform expressions *//** Transforms the given expression into another expression *//** Represents a field access such as the expression "this.foo". */boolean useRef;this.useRef/** Transforms the list of expressions, and checks that all transformed expressions have the given type. ... *//** Represents a String expression which contains embedded values inside ... */String verbatimText;List<ConstantExpression> strings;List<Expression> values;this.verbatimTextClassHelper.GSTRING_TYPEList<T> listthis.stringsnew ArrayList<ConstantExpression>(...)cast(...)import AstToTextHelper/** Represents a lambda expression such as one of these: ... */boolean serializable;visitLambdaExpression(...)String paramTextthis.serializableConstantExpression.classConstantExpression.EMPTY_STRING/** Represents a list expression [1, 2, 3] which creates a mutable List */List<Expression> expressions;boolean wrapped;ConstantExpression expression// If the first thing is an value, then we need a dummy empty string in front of it so that when we// toString it they come out in the correct order./** Represents an entry inside a map expression such as {@code 1 : 2} or {@code 'foo' : 'bar'}. */Expression keyExpression;Expression valueExpression;this.keyExpressionthis.valueExpression/** Represents a map expression [1 : 2, "a" : "b", x : y] which creates a mutable Map */List<MapEntryExpression> mapEntryExpressions;new ArrayList<MapEntryExpression>(...)this.expressions//TODO: get the type's of the expressions to specify the// list type to List<X> if possible./** Interface defining common methods for method calls. ... */this.mapEntryExpressionsClassHelper.MAP_TYPE/** A method call on an object or class. */new TupleExpression(...) { ... }MethodCallExpression$1Expression objectExpression;Expression method;boolean implicitThis;boolean spreadSafe;MethodNode target;Expression NO_ARGUMENTS;MapEntryExpression.classsetMethod(...)setObjectExpression(...)visitMethodCallExpression(...)MethodCallExpression answersetMethodTarget(...)// map type to Map<X> if possible./** This method returns the method name as String if it is no dynamic ... */this.objectExpressionString objectString methString argsString spreadString dereferencethis.implicitThis/** Sets a method call target for a direct method call. ... *//** Represents a method pointer on an object such as ... */this.targetExpression methodName;VariableExpression.THIS_EXPRESSIONExpression mname// TODO: set correct type here// if setting type and a MethodCall is the last expression in a method,// then the method will return null if the method itself is not void too!// (in bytecode after call: aconst_null, areturn)// GROOVY-8002: propagate position to (possibly new) method expression/** Represents a method reference or a constructor reference, ... *//** Represents one or more arguments being passed into a method by name */visitMethodReferenceExpression(...)Expression methodName/** Represents a postfix expression like foo++ or bar++ *//** Represents a prefix expression like ++foo or --bar *//** Represents a property access such as the expression "foo.bar". */Expression property;PropertyExpression ret/** Represents a range expression such as for iterating. ... */Expression from;Expression to;boolean exclusiveLeft;boolean exclusiveRight;this.exclusiveLeftthis.exclusiveRightClassHelper.RANGE_TYPEthis.spreadSafeisExclusiveLeft(...)isExclusiveRight(...)/** Represents a spread expression *x in the list expression [1, *x, 2]. *//** Represents a spread map expression *:m ... *//** A static method call on a class */ClassNode ownerType;/** Represents a ternary expression (booleanExpression) ? expression : expression */MetaMethod metaMethod;BooleanExpression booleanExpression;Expression trueExpression;Expression falseExpression;this.booleanExpressionthis.trueExpressionthis.falseExpressionnew StaticMethodCallExpression(...)getOwnerType(...)this.ownerTypethis.metaMethod/** Represents a local variable name, the simplest form of expression. e.g.&#160;"foo". */VariableExpression THIS_EXPRESSION;VariableExpression SUPER_EXPRESSION;String variable;boolean isDynamicTyped;Variable accessedVariable;this.accessedVariableexpressionArray.lengthsetAccessedVariable(...)/** Set the type of this variable. If you call this method from an AST transformation and that ... */// TODO: return Collections.unmodifiableList(expressions);// see also org.codehaus.groovy.ast.expr.MethodCallExpression.NO_ARGUMENTS// TODO: return getExpressions().iterator();/** Tells if this variable or the accessed variable is used in a closure context, like in the following ... */isClosureSharedVariable(...)/** Use this method to tell if a variable is used in a closure, like in the following example: ... *//** For internal use only. This flag is used by compiler internals and should probably ... *//** Returns the type which was used when this variable expression was created. For example, ... *//** Represents an assert statement. ... */Expression messageExpression;this.messageExpression/** A list of statements and a scope. *//** Represents a break statement in a switch or loop statement */String label;this.label/** Represents a case statement in a switch statement *//** Represents a catch (Exception var) { } statement */Parameter variable;this.variableList<Statement> statements;/** Creates a BlockStatement with a scope and children statements. ... */this.statements/** Represents a continue statement in a loop statement *//** Represents a do { ... } while (condition) loop in Groovy */Statement loopBlock;this.loopBlocknew EmptyStatement(...) { ... }EmptyStatement$1// Statement overrides:visitEmptyStatement(...)EmptyStatement INSTANCE;/** A simple statement such as a method call where the return value is ignored *//** Represents a standard for loop in Groovy */Parameter FOR_LOOP_DUMMY;Expression collectionExpression;/** Represents an if (condition) { ... } else { ... } statement in Groovy */Statement ifBlock;Statement elseBlock;this.collectionExpressionthis.ifBlockthis.elseBlock/** This is an AST Node that provides some sort of looping mechanism. Typically ... *//** Gets the loop block. *//** Sets the loop block. *//** A return statement */ReturnStatement RETURN_NULL_OR_VOID;/** Only used for synthetic return statements emitted by the compiler. ... */copyStatementLabels(...)/** Base class for any statement. */List<String> statementLabels;/** Represents a switch (object) { case value: ... case [1, 2, 3]: ...  default: ... } statement in Groovy. */new ArrayList<CaseStatement>(...)// TODO: @Deprecatednew LinkedList<String>(...)ifPresent(...)new Consumer<List<String>>(...) { ... }// last label by default which is added first by APPList<CaseStatement> caseStatements;Statement defaultStatement;this.defaultStatementthis.caseStatements/** Represents a synchronized statement *//** Represents a throw statement *//** Represents a try { ... } catch () finally {} statement in Groovy */new ArrayList<ExpressionStatement>(...)/** Represents a while (condition) { ... } loop in Groovy */import static AnnotatedNodeUtils.hasAnnotationnew ArrayList<CatchStatement>(...)Internal.classString GET_PREFIX;String SET_PREFIX;String IS_PREFIX;ClassNode INTERNAL_TYPE;/** Get all properties including JavaBean pseudo properties matching getter conventions. ... */getAllProperties(...)/** Get all properties including JavaBean pseudo properties matching JavaBean getter or setter conventions. ... */String IS_RESOURCE;Statement tryStatement;List<ExpressionStatement> resourceStatements;List<CatchStatement> catchStatements;Statement finallyStatement;this.tryStatementthis.finallyStatementExpression resourceExpressionBoolean rList<PropertyNode> result/** Handy methods when working with Closure AST data structures. */String sourceconvertASTToSource(...)new Exception(...)/** Does the Closure have a single char-like (char or Character) argument. ... */addExplicitProperties(...)addPseudoProperties(...)List<MethodNode> methodsgetAllDeclaredMethods(...)MethodNode mNodeint paramCountStatement getterStatement setteraddIfMissing(...)// TODO add generics support so this can be used for @EAHC// Optimization: skip invalid propertyNames// skip private super methods// Simple getter// boolean getter// Simple setter/** Does the Closure have a single String argument. ... *//** Returns the constant name associated with the given resolve strategy. ... */import Consumerimport static PrimitiveHelper.getDefaultValueForPrimitiveimport static GenericsUtils.parameterizeType/** Handy methods when working with the Groovy AST */import IncorrectTypeHintExceptionimport DecompiledClassNodeimport ResolveVisitorTypes.COMPARE_EQUALimport static SystemUtil.getSystemPropertySafeimport static DefaultGroovyMethods.plusimport static StaticTypeCheckingSupport.isUnboundedWildcardTypes.COMPARE_NOT_EQUALTypes.COMPARE_NOT_IDENTICALTypes.COMPARE_LESS_THANTypes.LOGICAL_ANDTypes.LOGICAL_ORTypes.COMPARE_TO/** Utility methods to deal with generic types. */Types.KEYWORD_INSTANCEOFnew ConcurrentSoftCache<ParameterizedTypeCacheKey,ClassNode>(...)Types.PLUSToken ASSIGN;Token EQ;Token NE;Token NOT_IDENTICAL;Token LT;Token AND;Token OR;Token CMP;Token INSTANCEOF;Token PLUS;Token INDEX;expressions.length...[] EMPTY_GENERICS_ARRAY;String JAVA_LANG_OBJECT;/** Given a parameterized type and a generic type information, aligns actual type parameters. For example, if a ... */GenericsType[] genericsalignmentTarget.lengthparameterizedTypes.lengthint scgtLengthGenericsType currentTargetGenericsType matchredirectGenericTypes.lengthGenericsType redirectGenericTypeGenericsType ogtClassNode[] currentUppercurrentUpper.lengthupper.length/** Generates a wildcard generic type in order to be used for checks against ... *//** Returns the type parameter/argument relationships of the specified type. ... */GenericsType.GenericsTypeNameMap<GenericsTypeName,GenericsType> placeholdersnew HashMap<GenericsTypeName,GenericsType>(...)new Function<String,VariableExpression>(...) { ... }/** Populates the supplied map with the type parameter/argument relationships ... */new IntFunction<Expression[]>(...) { ... }GenericsType[] redirectGenericsTypesList<GenericsType> typeArgumentsnew BytecodeExpression(...) { ... }GeneralUtils$1BytecodeExpression expressionbytecodeX(...)callSuperX(...)MethodCallExpression.NO_ARGUMENTS/** Builds a lambda expression ... *//** Builds a lambda expression with no parameters ... */lambdaX(...)/** Builds a binary expression that compares two values. ... */isRedirectNode(...)redirectGenericsTypes.lengthctorSuperX(...)ctorThisX(...)GenericsType rgtGenericsType typeArgumentnew Function<GenericsTypeName,GenericsType>(...) { ... }declX(...)/** Returns a constant expression with the default value for the given type ... */getDefaultValueForPrimitive(...)boolX(...)new FieldExpression(...)/** Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()} ... */Map<String,ClassNode> gtClassNode boundhasUnresolvedGenerics(...)int dimsClassNode tempClassNode plainNodeReferencegenericTypes.lengthint nTypesGenericsType[] gTypesmakeClassSafe0(...)Parameter[] oldParametersoldParameters.lengthParameter[] newParametersMethodNode newMethodaddMethodGenerics(...)Parameter oldParameterClassNode[] newTypesGenericsType[] oldgTypesGenericsType[] newgTypesList<FieldNode> resultClassNode placeholderoldgTypes.lengthnewgTypes.lengthGenericsType oldgTypeClassNode[] oldUpperClassNode oldLowerGenericsType fixedList<FieldNode> fListgetInstanceNonPropertyFields(...)oldUpper.lengthList<String> resultcorrectToGenericsSpec(...)ClassNode ocMap<String,ClassNode> newSpecnew HashMap<String,ClassNode>(...)List<PropertyNode> pListGenericsType[] gtGenericsType[] rgtaddAllInterfaces(...)gt.lengthGenericsType[] gtsClassNode redirect// TODO: this is very similar to StaticTypesCheckingSupport#extractGenericsConnections, using ClassNode instead of GenericsTypeGenericsType[] tpGenericsType[] taboolean noTypeArgumentsta.lengthtp.lengthgetSuperNonPropertyFields(...)isUnboundedWildcard(...)getSuperPropertyFields(...)declaration.lengthGenericsType dtasGenericsType(...)usage.lengthGenericsType uiGenericsType diClassNode cuClassNode uiClassNode diModuleNode moduleNodeDeclarationExpression dummyDeclaration/** This method is similar to {@link #propX(Expression, Expression)} but will make sure that if the property ... */ClassNode dummyNodeGenericsType[] dummyNodeGenericsTypesgetterThisX(...)getterX(...)ClassNode[] signaturedummyNodeGenericsTypes.lengthresolveClassNode(...)sameX(...)ClassNode dummyClassClassNode cNodeMethodNode dummyMNResolveVisitor visitornew ResolveVisitor(...) { ... }GenericsUtils$1startResolving(...)/** Transforms generics types from an old context to a new context using the ... */GenericsType[] newTypesoldPlaceHolders.length/** Alias for {@link #equalsNullX(Expression)} */GenericsType oldClassNode fromSpecClassNode[] newUpperListExpression resultClassNode newLowerClassNode[] upperCorrectedVariableExpression resultClassNode newPlaceHoldersetPlaceholder(...)boolean PARAMETERIZED_TYPE_CACHE_ENABLED;/** Convenience method for {@link #findParameterizedTypeFromCache(ClassNode, ClassNode, boolean)} ... */findParameterizedTypeFromCache(...)/** Try to get the parameterized type from the cache. ... */SoftReference<ClassNode> srnew ParameterizedTypeCacheKey(...)new ValueProvider<ParameterizedTypeCacheKey,SoftReference<ClassNode>>(...) { ... }findParameterizedType(...)getGenericsClass(...)getActualType(...)/** Convenience method for {@link #findParameterizedType(ClassNode,ClassNode,boolean)} when {@code tryToFindExactType} is {@code false}. */Parameter param/** Gets the parameterized type by searching the whole class hierarchy according to generics class and actual receiver. ... */LinkedList<ClassNode> todoPropertyExpression pexpTryCatchStatement resultCatchStatement catchStatementnew Function<Parameter,Parameter>(...) { ... }new IntFunction<Parameter[]>(...) { ... }/** Copies all <tt>candidateAnnotations</tt> with retention policy {@link java.lang.annotation.RetentionPolicy#RUNTIME} ... */copyAnnotatedNodeAnnotations(...)List<AnnotationNode> annotationListAbstractASTTransformation.RETENTION_CLASSNODEAnnotationNode retentionPolicyAnnotationExpression valueExpressionboolean processAnnotationhasClosureMember(...)boolean parameterizedAnnotationNode newAnnotationEntry<String,Expression> memberEvictableCache<ParameterizedTypeCacheKey,SoftReference<ClassNode>> PARAMETERIZED_TYPE_CACHE;/** Clears the parameterized type cache. ... *//** map declaring generics type to actual generics type, e.g. GROOVY-7204: ... */doMakeDeclaringAndActualGenericsTypeMap(...)/** The method is similar with {@link GenericsUtils#makeDeclaringAndActualGenericsTypeMap(ClassNode, ClassNode)}, ... */Map<GenericsType,GenericsType> mapGenericsType[] targetGenericsTypesGenericsType[] sourceGenericsTypesnew LinkedHashMap<GenericsType,GenericsType>(...)/** Generally preferred to use {@link PropertyNode#getGetterNameOrDefault()} directly. *//** WARNING: Avoid this method unless just the name and type are available. ... */getGetterName(...)/** WARNING: Avoid this method unless just the name is available. ... *//** Converts an expression into the String source. Only some specific expressions like closure expression ... */int xint yStatement preCodeint msourceGenericsTypes.lengthtargetGenericsTypes.length/** Checks if the type has any non-placeholder (aka resolved) generics. ... */checkPlaceHolders(...)new Predicate<GenericsType>(...) { ... }/** Checks if the type has any placeholder (aka unresolved) generics. ... *//** Checks for any placeholder (aka unresolved) generics. */ExpressionStatement esExpression preExp/** Gets the parameter and return types of the abstract method of SAM. ... */Map<String,Expression> membersClassExpression classExpressionMethodNode abstractMethodClass<?> typeClassMap<GenericsType,GenericsType> genericsmakeDeclaringAndActualGenericsTypeMapOfExactType(...)Function<ClassNode,ClassNode> resolvernew Function<ClassNode,ClassNode>(...) { ... }findActualTypeByGenericsPlaceholderName(...)Parameter[] paramsPackageNode firstPackagePackageNode secondPackagePackage firstPackage/** Gets the actual type according to the placeholder name. ... */Function<GenericsType,ClassNode> resolverPackage secondPackagenew Function<GenericsType,ClassNode>(...) { ... }int lastmaybeFallsThrough(...)TryCatchStatement tryCatchCatchStatement cs// internal field//restoring line breaks is important b/c of lack of semicolons// adjust the first statement if it's a super call// TODO ignore bridge methods?// TODOimport StaticTypeCheckingSupportimport BiPredicatenew Predicate<Entry<GenericsType,GenericsType>>(...) { ... }/** Checks compatibility of parameter arrays. Each parameter should match the ... */parametersMatch(...)new BiPredicate<ClassNode,ClassNode>(...) { ... }isAssignableTo(...)new Function<Entry<GenericsType,GenericsType>,GenericsType>(...) { ... }ClassNode genericsClass;ClassNode actualType;ClassNode aTypeClassNode bTypethis.genericsClassthis.actualTypeParameterizedTypeCacheKey cacheKeycacheKey.genericsClasscacheKey.actualType// check if there's a potential better match// if alignment target is a wildcard type// then we must make best effort to return a parameterized// wildcard// GROOVY-8609, GROOVY-10067, etc.// type parameter// examine non-placeholder type args// relationship may be reversed for cases like "Iterable<String> x = []"// walk target type hierarchy towards hint// GROOVY-10461: check without resolving supers// GROOVY-7722// correct "? extends T" or "? extends T & I"// correct "? super T"// correct "T"// correct "List<T>", etc.// GROOVY-9891// Example:// abstract class A<X,Y,Z> { ... }// class C<T extends Number> extends A<T,Object,String> { }// the type "A<T,Object,String> -> A<X,Y,Z>" will produce [X:Number,Y:Object,Z:String]// GROOVY-10646: outer class type parameters// "T extends U" or "T super U"// "T" or "T extends Thing" or "T super Thing"// Object is the superclass of an array, but no generics are involved// GROOVY-10651/** Fields within the AST that have no explicit visibility are deemed to be properties ... */// if we reach here, we have an unhandled caseModifier.TRANSIENT// if declaration does not provide generics, there is no connection to makeModifier.VOLATILE// if usage is a raw type, remove type parameters from spec// both have generics// the returned node is DummyNode<Param1, Param2, Param3, ...)// GROOVY-3726: clear volatile, transient modifiers so that they don't get applied to methods// GROOVY-10166// declaringClass may be "List<T> -> List<E>" and parameterizedType may be "List<String> -> List<E>" or "List<> -> List<E>"import static IntStream.rangeimport static ClassHelper.Number_TYPEimport static ClassHelper.VOID_TYPEimport static ClassHelper.byte_TYPEimport static ClassHelper.double_TYPEimport static ClassHelper.float_TYPEimport static ClassHelper.getNextSuperClassimport static ClassHelper.getWrapperimport static ClassHelper.int_TYPEimport static ClassHelper.isBigDecimalTypeimport static ClassHelper.isBigIntegerTypeimport static ClassHelper.long_TYPEimport static ClassHelper.short_TYPE/** This class provides helper methods to determine the type from a widening ... */import ErrorCollectorimport static ExpressionUtils.transformInlineConstantsMap<ClassNode,Integer> NUMBER_TYPES_PRECEDENCE;/** Used to check if a type is an int or Integer. ... *//** An Annotation visitor responsible for: ... */SourceUnit source;ErrorCollector errorCollector;AnnotationNode annotation;/** Used to check if a type is an double or Double. ... */ClassNode reportClass;/** Used to check if a type is a float or Float. ... *//** It is of an int category, if the provided type is a ... */this.errorCollectorthis.reportClass/** It is of a long category, if the provided type is a ... */this.annotationsetReportClass(...)isValidAnnotationClass(...)checkIfMandatoryAnnotationValuesPassed(...)checkIfValidEnumConstsAreUsed(...)isIntCategory(...)/** It is of a BigInteger category, if the provided type is a ... */isBigIntegerType(...)isLongCategory(...)/** It is of a BigDecimal category, if the provided type is a ... */isBigDecimalType(...)isBigIntCategory(...)ClassNode attrTypegetAttributeType(...)Expression attrExprvisitExpression(...)configureAnnotation(...)Map<String,Expression> attributesvalidateEnumConstant(...)ClassExpression ceboolean okFieldNode enumFieldListExpression le/** It is of a double category, if the provided type is a ... */isBigDecCategory(...)/** It is of a floating category, if the provided type is a ... *//** Given a list of class nodes, returns the first common supertype. ... */lowestUpperBound(...)/** Given two class nodes, returns the first common supertype, or the class itself ... */ClassNode lubparameterizeLowestUpperBound(...)ClassNode icnnew LowestUpperBoundClassNode(...)(...).name/** Given a lowest upper bound computed without generic type information but which requires to be parameterized ... */ClassNode holderForAfindGenericsTypeHolderForClass(...)ClassNode holderForBGenericsType[] agtGenericsType[] bgtagt.lengthGenericsType[] lubGTsbgt.lengthClassNode t1upperBound(...)ClassNode t2ClassNode basicTypeareEqualWithGenerics(...)ListExpression listExpgetConstantExpression(...)isClassType(...)visitEnumExpression(...)visitAnnotationExpression(...)checkReturnType(...)Expression resultConstantExpression retAnnotationVisitor visitornew AnnotationVisitor(...)AnnotationConstantExpression aceReturnStatement codecheckCircularReference(...)// check if values have been passed for all annotation attributes that don't have defaults// if enum constants have been used, check if they are all valid// if the annotation attribute has a default, getCode() returns a ReturnStatement with the default value// if size is >1, then the method was overwritten or something, we ignore that// if it is an error, we have to test it at another place. But size==0 is// an error, because it means that no such attribute exists.// check needed as @Test(attr = {"elem"}) passes through the parser// treat like a singleton list as per Java// TODO: Track @Deprecated usage and give a warning?buildWildcardType(...)ClassNode[] ubboolean isPrimitiveAboolean isPrimitiveBboolean isInterfaceAboolean isInterfaceBClassNode saClassNode sbGenericsType[] gtaGenericsType[] gtbgta.lengthgtb.lengthInteger paInteger pbClassNode[] interfacesFromAClassNode[] interfacesFromBSet<ClassNode> commonSet<ClassNode> fromBbuildTypeWithInterfaces(...)List<ClassNode> matchingInterfacesextractMostSpecificImplementedInterfaces(...)keepLowestCommonInterfaces(...)getInterfacesAndSuperInterfaces(...)/** Given the interfaces implemented by two types, returns a list of the most ... */addMostSpecificInterface(...)ClassNode interfaceNode/** Given two class nodes supposedly at the upper common level, returns a class node which is able to represent ... */removeIf(...)/** This {@link ClassNode} specialization is used when the lowest upper bound of two types ... */ClassNode upper;ClassNode compileTimeClassNode;StringJoiner sjboolean usesGenericsList<GenericsType[]> genericsTypesListnew ArrayList<GenericsType[]>(...)import InterfaceHelperClassNodeimport BytecodeVariableimport MethodCallerimport MethodCallerMultiAdapterimport MopWriterimport OperandStackimport OptimizingStatementWriterimport WriterControllerimport WriterControllerFactoryimport RuntimeParserExceptionimport Labelimport TypeReferenceimport TraceMethodVisitorimport static ClassNodeUtils.getFieldimport static ExpressionUtils.isNullConstantimport static ExpressionUtils.isSuperExpressionimport static ClassHelper.isClassTypeimport static ClassHelper.isStringTypeimport static GeneralUtils.attrXimport static GeneralUtils.maybeFallsThroughimport static GeneralUtils.thisPropXimport static ParameterUtils.isVargsimport static SealedASTTransformation.sealedNativeimport static SealedASTTransformation.sealedSkipAnnotationimport static StaticCompilationMetadataKeys.PROPERTY_OWNERimport static Opcodes.AASTOREimport static Opcodes.ACC_SUPERimport static Opcodes.ACC_VARARGSimport static Opcodes.ACONST_NULLimport static Opcodes.ALOADimport static Opcodes.ANEWARRAYimport static Opcodes.ARETURNimport static Opcodes.ASTOREimport static Opcodes.ATHROWimport static Opcodes.BASTOREimport static Opcodes.CASTOREimport static Opcodes.CHECKCASTimport static Opcodes.DASTOREimport static Opcodes.DUPimport static Opcodes.DUP2import static Opcodes.FASTOREimport static Opcodes.GETFIELDimport static Opcodes.GETSTATICimport static Opcodes.GOTOimport static Opcodes.IASTOREimport static Opcodes.ICONST_0import static Opcodes.ICONST_1import static Opcodes.IFNONNULLimport static Opcodes.ILOADimport static Opcodes.INVOKESPECIALimport static Opcodes.INVOKESTATICimport static Opcodes.INVOKEVIRTUALimport static Opcodes.LASTOREimport static Opcodes.NEWimport static Opcodes.NEWARRAYimport static Opcodes.POPimport static Opcodes.PUTFIELDimport static Opcodes.PUTSTATICimport static Opcodes.RETURNimport static Opcodes.SASTOREimport static Opcodes.SWAPimport static Opcodes.T_BOOLEANimport static Opcodes.T_BYTEimport static Opcodes.T_CHARimport static Opcodes.T_DOUBLEimport static Opcodes.T_FLOATimport static Opcodes.T_INTimport static Opcodes.T_LONGimport static Opcodes.T_SHORTimport static Opcodes.V_PREVIEWimport static TypeReference.CLASS_TYPE_PARAMETERimport static TypeReference.CLASS_TYPE_PARAMETER_BOUNDimport static TypeReference.FIELDimport static TypeReference.METHOD_RETURNimport static TypeReference.METHOD_TYPE_PARAMETERimport static TypeReference.METHOD_TYPE_PARAMETER_BOUNDimport static TypeReference.newExceptionReferenceimport static TypeReference.newFormalParameterReferenceimport static TypeReference.newSuperTypeReferenceimport static TypeReference.newTypeParameterBoundReferenceimport static TypeReference.newTypeParameterReferenceimport static TypeReference.newTypeReferencethis.uppernew Comparator<ClassNode>(...) { ... }/** Generates Java class versions of Groovy classes using ASM. */String n1String n2ClassNode iList<GenericsType> flatListnewStatic(...)ScriptBytecodeAdapter.classClassNode[] ubsClassNode[] faces/** Compares two class nodes, but including their generics types. ... */MethodCallerMultiAdapter setField;// fieldsMethodCallerMultiAdapter getField;MethodCallerMultiAdapter setFieldOnSuper;MethodCallerMultiAdapter getFieldOnSuper;MethodCallerMultiAdapter setGroovyObjectField;MethodCallerMultiAdapter getGroovyObjectField;MethodCallerMultiAdapter setProperty;// propertiesMethodCallerMultiAdapter getProperty;MethodCallerMultiAdapter setPropertyOnSuper;MethodCallerMultiAdapter getPropertyOnSuper;MethodCallerMultiAdapter setGroovyObjectProperty;MethodCallerMultiAdapter getGroovyObjectProperty;MethodCaller spreadMap;// spread expressionsMethodCaller despreadList;GenericsType gta_iMethodCaller createMapMethod;// type conversionsMethodCaller createListMethod;MethodCaller createRangeMethod;// parameter count here// The 3-parameter version of createRange is kept in for backwards compatibility, so we need to specify theMethodCaller createPojoWrapperMethod;GenericsType gtb_iMethodCaller createGroovyObjectWrapperMethod;Map<String,ClassNode> referencedClasses;boolean passingParams;ClassNode[] upperAboolean CREATE_DEBUG_INFO;boolean CREATE_LINE_NUMBER_INFO;boolean ASM_DEBUG;ClassNode[] upperBString MINIMUM_BYTECODE_VERSION;// add marker in the bytecode to show source-bytecode relationshipWriterController controller;ASTNode currentASTNode;GeneratorContext context;ClassVisitor classVisitor;String sourceFile;this.classVisitorthis.sourceFileupperB.lengthupperA.lengthrange(...)// GroovyClassVisitor interfaceWriterControllerFactory factoryWriterControllerFactory.class/** Determines if the source class implements an interface or subclasses the target type. ... */LowestUpperBoundClassNode lubimplementsInterfaceOrSubclassOf(...)new WriterController(...)makeController(...)shouldOptimizeForInt(...)setNodeMeta(...)getTypeChooser(...)getClassVisitor(...)int bytecodeVersiongetBytecodeVersion(...)Object minint minVersionadjustedClassModifiersForClassWriting(...)getInternalClassName(...)getGenericsSignature(...)getInternalBaseClassName(...)getClassInternalNames(...)visitSource(...)MethodNode enclosingMethodgetEnclosingMethod(...)makeInnerClassEntry(...)visitOuterClass(...)getClassInternalName(...)newSuperTypeReference(...)// GROOVY-10330// types may be parameterized; if so, ensure that generic type arguments// are made compatible// no parent super class representing both types could be found// or both class nodes implement common interfaces which may have// been parameterized differently.// We must create a classnode for which the "superclass" is potentially parameterized// plus the interfaces// a common super type exists, all we have to do is to parameterize// it according to the types provided by the two class nodes// let's compare their generics type// "String implements Comparable<String>" and "StringBuffer implements Comparable<StringBuffer>"// do not loopString outerClassName// first test special cases// this is a corner case, you should not// compare two class nodes if one of them is nullgetNextInnerClassIdx(...)// one of the objects is at the top of the hierarchy// one class is void, the other is not// now handle primitive typessetInterfaceClassLoadingClass(...)// handle interfaces// each interface may have one or more "extends", so we must find those// which are common// we have two interfaces, but none inherits from the other// so the only possible return type is Objectnew InterfaceHelperClassNode(...)// a is an interface, b is not// a ClassNode superclass for an interface is not// another interface but always Object. This implies thatgetCallSites(...)// "extends" for an interface is understood as "implements"// for a ClassNode. Therefore, even if b doesn't implement// interface a, a could "implement" other interfaces that b// implements too, so we must create a list of matching interfaces// no interface in common// a single match, which should be returned// both classes do not represent interfaces// test if one class inherits from the other// check if no superclass is defined, meaning that we reached the top of the object hierarchy// if one superclass is derived (or equals) another then it is the common super type// superclasses are on distinct hierarchy branches, so we recurse on them// a more specific interface exists in the list, keep it// the interface being added is more specific than the one in the list, replace it// if we reach this point, this means the interface is new// none if the direct interfaces match, but we must check "upper" in the hierarchy// Object is implicitgetCallSiteWriter(...)createInterfaceSyntheticStaticFields(...)MopWriter.FactoryFactory mopWriterFactoryMopWriter.Factory.classMopWriter mopWriterMopWriter.FACTORYcreateMopMethods(...)generateCallSiteArray(...)createSyntheticStaticFields(...)/** Represents some custom bytecode generation by the compiler. */sealedNative(...)ClassNode subBytecodeExpression$1visitPermittedSubclass(...)isRecord(...)visitRecordComponents(...)visitEnd(...)BytecodeExpression NOP;String m// TODO: convert to @FunctionalInterface/** Helper class used by the class generator. Usually ... *//** This class represents a sequence of {@link BytecodeInstruction}s ... */this.instructionsList<?> instructions;/** Returns the singular BytecodeInstruction. ... */GroovyRuntimeException greRecordComponentVisitor visitorvisitRecordComponent(...)getTypeDescription(...)getTypeGenericsSignature(...)TypeReference typeRefnew TypeReference(...)visitTypeAnnotations(...)String innerClassInternalNameString outerClassInternalNameadjustedClassModifiersForInnerClassTable(...)maybeInnerClassEntry(...)visitInnerClass(...)/* See http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.6-300-D.2-5 ... */fixInterfaceModifiers(...)Object instruction/** Delegates to the visit method used for this class. ... */visitBytecodeSequence(...)/* Classes but not interfaces should have ACC_SUPER set ... */boolean needsSuperfixInnerClassModifiers(...)MethodVisitor mvgetGenericsMethodSignature(...)buildExceptions(...)isVargs(...)setMethodVisitor(...)resetLineNumber(...)newTypeReference(...)new Supplier<CompileUnit>(...) { ... }visitParameter(...)visitParameterAnnotations(...)newFormalParameterReference(...)getExceptions(...).lengthnewExceptionReference(...)visitAnnotationDefault(...)BytecodeInstruction instructionvisitCode(...)getBytecodeInstruction(...)visitStdMethod(...)visitMaxs(...)PrintWriter p(...).pgetMethodVisitor(...)getCompileStack(...)makeSiteEntry(...)boolean hasCallToSupernew Function<Statement,Expression>(...) { ... }new Predicate<Expression>(...) { ... }visitLineNumber(...)visitVarInsn(...)visitMethodInsn(...)visitInsn(...)OperandStack operandStackgetOperandStack(...)visitLdcInsn(...)doGroovyCast(...)doReturn(...)ClassNode closureClassgetOrAddClosureClass(...)getClosureWriter(...)Type tAnnotationVisitor avlvisitArray(...)ClassNode componentTypeExpression lExpvisitAnnotationDefaultExpression(...)ConstantExpression constExpPropertyExpression pExpClassExpression cExpString descvisitEnum(...)AnnotationConstantExpression avExpAnnotationNode valueAnnotationVisitor avcvisitAnnotationAttributes(...)Expression expAnnotationVisitor avsetConstructorNode(...)setMethodNode(...)String signaturegetGenericsBounds(...)Expression initialValueExpressionConstantExpression cexpisStaticConstantInitializerType(...)FieldVisitor fvonLineNumber(...)transformToPrimitiveConstantIfPossible(...)// Statements// GroovyCodeVisitor interfacewriteBlockStatement(...)getStatementWriter(...)writeForStatement(...)writeWhileLoop(...)writeDoWhileLoop(...)writeIfElse(...)writeAssert(...)writeTryCatchFinally(...)getExceptionType(...)writeSwitch(...)writeBreak(...)writeContinue(...)writeSynchronized(...)writeThrow(...)writeReturn(...)writeExpressionStatement(...)// ExpressionsevaluateTernary(...)getBinaryExpressionHelper(...)doPostVisit(...)evaluateEqual(...)eval(...)record(...)getAssertionWriter(...)evaluatePostfixMethod(...)evaluatePrefixMethod(...)writeClosure(...)writeLambda(...)getLambdaWriter(...)/** Loads either this object or if we're inside a closure then load the top level owner */loadThis(...)/** Generates byte code for constants. ... */String constantNamegetConstantName(...)pushConstant(...)visitFieldInsn(...)Collections.classwriteMethodPointerExpression(...)getMethodPointerExpressionWriter(...)writeMethodReferenceExpression(...)getMethodReferenceExpressionWriter(...)writeUnaryMinus(...)getUnaryExpressionHelper(...)writeUnaryPlus(...)writeBitwiseNegate(...)Expression subExpressiondoAsType(...)isNullConstant(...)ClassNode subExprTypedoCast(...)writeNotExpression(...)int markgetStackLength(...)castToBool(...)writeInvokeMethod(...)getInvocationWriter(...)writeInvokeStaticMethod(...)import static Modifier.isFinalimport static Modifier.isNativeimport static Modifier.isPrivateimport static Modifier.isStaticimport static Modifier.isStrictimport static Modifier.isSynchronizedimport static Modifier.isTransientimport static Modifier.isVolatileimport static Opcodes.ACC_NATIVEimport static Opcodes.ACC_STRICTimport static Opcodes.ACC_SYNCHRONIZEDimport static Opcodes.ACC_TRANSIENTwriteSpecialConstructorCall(...)writeInvokeConstructor(...)String internalNameStringBuilder prefixmakeFieldClassName(...)/** Determines if the given class can directly access the given field (via ... *//** Checks that a class satisfies various conditions including: ... */isMemberDirectlyAccessible(...)...[] INVALID_NAME_CHARS;boolean strictNames;// the groovy.compiler.strictNames system property is experimental and may change default value or be removed in a future version of Groovyboolean inConstructor, ...;ClassNode currentClass;ClassNode previousClasscheckImplementsAndExtends(...)hasErrors(...)checkClassForIncorrectModifiers(...)isFieldDirectlyAccessible(...)checkInterfaceMethodVisibility(...)checkAbstractMethodVisibility(...)checkClassForExtendingFinalOrSealed(...)checkMethodsForIncorrectModifiers(...)checkMethodsForIncorrectName(...)checkMethodsForWeakerAccess(...)checkMethodsForOverridingFinal(...)checkNoAbstractMethodsNonAbstractClass(...)checkClassExtendsAllSelfTypes(...)checkNoStaticMethodWithSameSignatureAsNonStatic(...)checkGenericsUsage(...)Expression objectExpressionClassNode iterTypeisInSpecialConstructorCall(...)ConstructorNode ctorgetConstructorNode(...)Expression receiverisStaticClass(...)String ownerNameFieldNode thisFieldnew HashMap<String,MethodNode>(...)isGeneratedFunction(...)visitTypeInsn(...)ClassNode thisFieldTypemakeGetPropertySite(...)makeGroovyObjectGetPropertySite(...)fallbackAttributeOrPropertySite(...)getOuterClasses(...)Expression outerClassExpression outerFieldattrX(...)Expression upperClassExpression upperFieldClassNode objectExpressionTypeisThisOrSuper(...)isDerivedFromGroovyObject(...)isStaticContext(...)boolean visitedisInGeneratedFunction(...)ClassHelper.REFERENCE_TYPEcheckStaticOuterField(...)boolean useMetaObjectProtocolisGroovyObject(...)MethodCallerMultiAdapter adapterisLHS(...)visitAttributeOrProperty(...)getDeclaredFieldOfCurrentClassOrAccessibleFieldOfSuper(...)storeStaticField(...)loadStaticField(...)storeThisInstanceField(...)loadInstanceField(...)isInGeneratedFunctionConstructor(...)getFieldOwnerName(...)/** RHS instance field. should move most of the code in the BytecodeHelper */isUseReferenceDirectly(...)swap(...)box(...)ASTNode errorNodeBytecodeVariable variableString shortNameisStaticMethod(...)getThisType(...)loadOrStoreVariable(...)isInScriptBody(...)loadThisOrOwner(...)thisPropX(...)MethodNode sameArgsMethodString whatASTNode whereClassNode iclgetInterfaceClassLoadingClass(...)InnerClassNode inneraddInnerClass(...)Entry<String,ClassNode> entryMap<>.Entry<String,ClassNode>String staticFieldNameLinkedHashSet<ClassNode> selfTypesClassHelper.CLASS_TypeLabel l0new Label(...)Label l1Label l2boolean typeboolean modifierscollectSelfTypes(...)throwException(...)checkClassForAbstractAndFinal(...)checkClassForOtherModifiers(...)visitJumpInsn(...)getClassLoadingTypeDescription(...)visitLabel(...)checkClassForModifier(...)visitTryCatchBlock(...)getStaticFieldName(...)String internalClassNameisClassLiteralPossible(...)isSameCompilationUnit(...)InterfaceHelperClassNode interfaceClassLoadingClassvisitClassLiteral(...)boolean sealedpushBool(...)boolean explicitNonSealednonSealed(...)ClassNode superCNboolean sealedSuperboolean sealedInterfaceList<MapEntryExpression> entriesMapEntryExpression entrycontainsSpreadExpression(...)despreadList(...)boolean nonSealedSuperboolean nonSealedInterfaceExpression argumentloadWrapper(...)int dimensionsint storeInsExpression elementint primTypecheckSealedParent(...)ClassNode candidatevisitIntInsn(...)visitMultiANewArrayInsn(...)ClassNode permittedExpression elementExpressionConstantExpression.NULLList<Object> instructionsnew LinkedList<Object>(...)isConstructor(...)String chcheckMethodForWeakerAccessPrivileges(...)MethodNode superMethodParameter[] superParamsaddInvalidUseOfFinalError(...)appendParamsDescription(...)boolean needsCommacheckAbstractDeclaration(...)checkRepetitiveMethod(...)checkOverloadingPrivateAndPublic(...)checkMethodModifiers(...)this.currentClasscheckMethodForModifier(...)addWeakerAccessError(...)boolean hasPublicLabel dfltLabel tableEndParameter[] p1Parameter[] p2p1.lengthp2.lengthaddErrorIfParamsAndReturnTypeEqual(...)Label[] labelsnew Label[]ConstantExpression textboolean isEqualThrowStatement tsBlockStatement bsParameter closureIndexClosureExpression ceint listArrayVardefineTemporaryVariable(...)pushVariableScope(...)DeclarationExpression denew BytecodeInstruction(...) { ... }AsmClassGenerator$1checkInterfaceFieldModifiers(...)checkInvalidFieldModifiers(...)visitTableSwitchInsn(...)Label labelAsmClassGenerator$2checkDuplicateProperties(...)PropertyNode otherNodeString otherNameString msgAsmClassGenerator$3AsmClassGenerator$4AsmClassGenerator$5new BytecodeSequence(...)isAssignment(...)checkFinalFieldAccess(...)checkSuperOrThisOnLHS(...)Variable vremoveVar(...)PropertyExpression propExpVariableExpression varExpList<?> sequencegetInstructions(...)boolean errorboolean containsSpreadExpressionboolean containsOnlyConstantscontainsOnlyConstants(...)Expression aexpTupleExpression argumentsint maxInitcheckForInvalidDeclaration(...)checkInvalidDeclarationModifier(...)List<String> methodscheckStringExceedingMaximumLength(...)getRefDescriptor(...)FieldNode fPropertyNode p// start with methods from the parent if any// add in unimplemented abstract methods from the interfaces// in case of a precompiled class, the outerclass is unknown// try to get a better error message location based on the property// we only do check abstract classes (including enums), no interfaces or non-abstract classes// don't check synchronized here as it overlaps with ACC_SUPER// Groovy allows more characters than Character.isValidJavaIdentifier() would allow// if we find a good way to encode special chars we could remove (some of) these checks// don't check volatile here as it overlaps with ACC_BRIDGE// additional modifiers not allowed for interfaces// transient overlaps with varargs but we don't add varargs until AsmClassGenerator// but we might have varargs set from e.g. @Delegate of a varargs method so skip generated/* if it is static final but not accessed inside a static constructor, or, ... */MethodVisitor oldMvgetNextHelperMethodIndex(...)int methodBlockSizeint methodBlockEnd/** Abstract base class for generator of Java class versions of Groovy AST classes */List<ConstantExpression> stringsLinkedList<ClassNode> innerClasses;// inner classes created while generating bytecode/** An exception thrown by the class generator */import CompileUnit/** To generate a class that has all the fields and methods, except that fields are not initialized ... */ClassVisitor cv;MethodVisitor mv;// current class detailsString internalClassName;String internalBaseClassName;this.cvthis.internalClassNamethis.internalBaseClassNameClassNode innerClassString methodTypevisitParameters(...)CompileUnit answer// default for inner classes// local inner classes do not specify the outer class name//fieldValue,  //br  all the sudden that one cannot init the field here. init is done in static initializer and instance initializer./** Enums have a parent constructor with two arguments from java.lang.Enum. ... */completeEnum(...)nonSyntheticConstructors(...)getAnnotationVisitor(...)sealedSkipAnnotation(...)addImplicitConstructors(...)transformConstructor(...)/** Add map and no-arg constructor or mirror those of the superclass (i.e. base enum). */isAnonymousInnerClass(...)List<ConstructorNode> superCtorsaddSpecialMapConstructors(...)/** If constructor does not define a call to super, then transform constructor ... */boolean chainedThisConstructorCallParameter[] oldPParameter[] newPTypePath typePatholdP.lengthint typeRefIntString stringParameterNamegetUniqueVariableName(...)String annotationDescriptorString intParameterNameAnnotationNode.TYPE_USE_TARGETVariableExpression stringVariablefromString(...)VariableExpression intVariableIllegalArgumentException exvisitTypeAnnotation(...)List<Expression> argsExprsvisitGenericsTypeAnnotations(...)visitGenericsTypeParameterAnnotations(...)int paramIdxnewTypeParameterReference(...)newTypeParameterBoundReference(...)int boundIdxList<Expression> argsvisitParameterAnnotation(...)/** Generates the annotation attributes. ... */Statement oldCodeMap<String,Object> constantAttrsmakeBridgeConstructor(...)Object[] foundCodeVisitorSupport cvEnumCompletionVisitor$1/** Ensures the enum type {@code e} has an accessible constructor for its AIC ... */p.lengthStatement thisCtorCallMap<String,PropertyExpression> enumAttrsnew HashMap<String,PropertyExpression>(...)Map<String,Object> atAttrsMap<String,ListExpression> arrayAttrsnew HashMap<String,ListExpression>(...)new Predicate<ConstructorNode>(...) { ... }// must be call to this(...)// we need to add parameters// add a super call// GROOVY-6747: bridge enum's private constructorEntry<String,PropertyExpression> entryMap<>.Entry<String,PropertyExpression>AnnotationNode atNodeAnnotationVisitor av2visitArrayAttributes(...)Entry<String,ListExpression> entryMap<>.Entry<String,ListExpression>int arrayElementTypedetermineCommonArrayType(...)Expression exprChildvisitAnnotationArrayElement(...)AnnotationNode atAttrPropertyExpression propExprnew Function<ClassNode,String>(...) { ... }new IntFunction<String[]>(...) { ... }List<Expression> spreadIndexesList<Expression> spreadExpressionsList<Expression> normalArgumentsConsumer<WriterController> callbackClassNode expectedTypegetOutermostClass(...)ClassNode goalClassnew RuntimeParserException(...)// GROOVY-4649, et al.// pull them out of package node but treat them like they were on class node// GROOVY-4649, GROOVY-6750, GROOVY-6808// the int encoded value of the type reference is ALWAYS `318767104`// TODO Get the magic number `318767104` via `TypeReference.newXXX()`// GROOVY-9842// local inner classes don't specify the outer class name// (JLS 9.1.1.1). Such a class file must not have its ACC_FINAL, ACC_SUPER or ACC_ENUM flags set.// on the inner class node itself, private/protected are not allowed// GROOVY-6357: The JVM does not allow private modifier on inner classes: should be package private// GROOVY-6357: Following Java's behavior for protected modifier on inner classes: should be public// eliminate static// ideally following statement would be in visitMethod but mv not visible there// add parameter names to the MethodVisitor (JDK8+)// fast path for getters, setters, etc.// GROOVY-4471: if the class is an inner class node, there are chances that// the call to super is already added so we must ensure not to add it twice// GROOVY-9373// add call to "super()"// GROOVY-7647, GROOVY-9373// GROOVY-5150// byte, char and short require an extra cast// the verifier created the field and the setter/getter methods, so here is// not really something to do// GROOVY-7473// GROOVY-5746// GROOVY-3421: SpreadMapExpression is key expression and contains value// dummy SpreadMap//append nothing -> delete ';'// a public member is accessible from anywhere// any member is accessible from the declaring class// a private member isn't accessible beyond the declaring class// a protected member is accessible from any subclass of the declaring class// a protected or package-private member is accessible from the declaring package// we have something like A.B.this, and need to make it// into this.this$0.this$0, where this.this$0 returns// A.B and this.this$0.this$0 return A.// Outer.this in a special constructor call// closure within inner class// GROOVY-8881: cater for closures within closures - getThisObject is already outer class of all closures// TODO: spread safe should be handled inside// checks supers//GROOVY-8693// GROOVY-10695: "Type.name" within body of Type should get explicit-this treatment// Type, this or super// params are stored as fields// GROOVY-8448: "this.name" from anon. inner class// GROOVY-10695: "this.name" or "Type.name" where "name" is non-static// GROOVY-9501, GROOVY-9569, GROOVY-9650, GROOVY-9655, GROOVY-9665, GROOVY-9683, GROOVY-9695// GROOVY-4497: do not visit super class field if it is private// rhs is ready to use reference, just put it in the field// rhs is normal value, set the value in the Reference// rhs is normal value, set normal value// "this" in static context is Class instance// "super" in static context is Class instance// generate a field node// br using l2 as the 2nd param seems create the right table entry// convert to an int// init declarations// to keep stack height put a null on stack// init table// visit cases// expressions will leave a value on stack, so need to pop the alibi null// default case// return// we need later an array to store the curried// closures, so we create it here and ave it// in a temporary variable// add curried versions// stack: closure// we need to create a curried closure version// so we store the type on stack// stack: closure, type// for a constructor call we need the type two times// and the closure after them// stack: closure,type,type,closure// so we can create the curried closure// stack: closure,curriedClosure// we need to save the result// we don't need the closure any longer, so remove it// we load the array and create a list from it// remove the temporary variable to keep the// stack clean// ignore it; annotation generation needs the current visitor// GROOVY-8863// load normal arguments as array// load spread expressions as array// load insertion indexFieldNode minValueFieldNode maxValueFieldNode valuesboolean isAICClassNode enumPlainaddMethods(...)checkForAbstractMethods(...)addInit(...)boolean hasNextboolean hasPreviousClassNode enumRefMethodNode mMethodNode valuesMethodMethodCallExpression cloneCallToken assignToken geTypes.COMPARE_GREATER_THAN_EQUALMethodNode nextMethodBlockStatement ifStatementToken ltMethodNode prevMethodParameter stringParameterMethodNode valueOfMethodArgumentListExpression callArgumentsParameter[] parameterMethodNode initMethodList<Expression> arrayInitList<Statement> blockFieldNode tempMinFieldNode tempMaxClassNode enumBaseListExpression oldArgsList<MapEntryExpression> savedMapEntriesClassExpression clazzExpList<MethodNode> baseMethodsMethodNode enumConstMethodimport AnnotationConstantsVisitorimport static AnnotationNode.ANNOTATION_TARGETimport static AnnotationNode.CONSTRUCTOR_TARGETimport static AnnotationNode.FIELD_TARGETimport static AnnotationNode.LOCAL_VARIABLE_TARGETimport static AnnotationNode.METHOD_TARGETimport static AnnotationNode.PACKAGE_TARGETimport static AnnotationNode.PARAMETER_TARGETimport static AnnotationNode.RECORD_COMPONENT_TARGETimport static AnnotationNode.TYPE_PARAMETER_TARGETimport static AnnotationNode.TYPE_TARGETimport static AnnotationNode.TYPE_USE_TARGETimport static GeneralUtils.getInterfacesAndSuperInterfacesimport static GenericsUtils.correctToGenericsSpecimport static ParameterUtils.parametersEqualimport static StaticTypeCheckingSupport.evaluateExpression/** A specialized Groovy AST visitor meant to perform additional verifications upon the ... */new HashMap<String,Boolean>(...)// create MIN_VALUE, MAX_VALUE and $VALUES fields// make the class abstract also; see Effective Java p.152// create values() method// create next() method, code://     Day next() {//        int ordinal = ordinal().next()//        if (ordinal >= values().size()) ordinal = 0//        return values()[ordinal]//     }// create previous() method, code://    Day previous() {//        int ordinal = ordinal().previous()//        if (ordinal < 0) ordinal = values().size() - 1// create valueOf// constructor helper// This method is used instead of calling the constructor as// calling the constructor may require a table with MetaClass// selecting the constructor for each enum value. So instead we// use this method to have a central point for constructor selection// and only one table. The whole construction is needed because// Reflection forbids access to the enum constructor.// code:// def $INIT(Object[] para) {//  return this(*para)// static init/* GROOVY-3985: Remove the final modifier from $INIT method in this case ... */new LinkedList<Map<Variable,VariableState>>(...)String JVM_ERROR_MESSAGE;String EXTENDED_VERIFIER_SEEN;Map<String,Boolean> repeatableCache;AnnotationConstantsVisitor acvnew AnnotationConstantsVisitor(...)RecordComponentNode recordComponentNodeextractTypeUseAnnotations(...)VariableExpression varxClassNode ubList<AnnotationNode> typeUseAnnosVariableNotFinalCallback callback;Set<Variable> declaredFinalVariables;boolean inAssignmentRHS;boolean inArgumentList;new VariableState(...)VariableState is_uninitialized;VariableState is_final;VariableState is_var;VariableState is_ambiguous;boolean isFinal;// any further use of that variable can trigger uninitialized or not final errorsthis.isFinalDeque<Map<Variable,VariableState>> assignmentTracker;this.callbacknew StateMap(...)Map<Variable,VariableState> stateVariable tgetTarget(...)removeLast(...)getLast(...)VariableState statesetAnnotated(...)Set<Variable> oldnew HashSet<Variable>(...)ErrorCollector errorCollectornew ErrorCollector(...)addCollectorContents(...)Map<String,List<AnnotationNode>> nonSourceAnnotationsnew LinkedHashMap<String,List<AnnotationNode>>(...)boolean oldboolean assignmentboolean isDeclarationExpression rightExpressionrecordFinalVars(...)recordAssignments(...)boolean uninitializedrecordAssignment(...)TupleExpression teExpression nextVariableExpression varMap<Variable,VariableState> origStateboolean skippableIterator<AnnotationNode> iteratorcleanLocalVars(...)AnnotationNode unvisitedIterator<Entry<Variable,VariableState>> iterAnnotationNode visitedboolean isTargetAnnotationshouldSkip(...)List<AnnotationNode> seenisTypeUseScenario(...)targetToName(...)visitDeprecation(...)visitOverride(...)processDuplicateAnnotationContainers(...)Map<>.Entry<Variable,VariableState>ClassNode annoClassNodeboolean resultEntry<Variable,VariableState> nextVariable keyEntry<String,List<AnnotationNode>> nextMap<>.Entry<String,List<AnnotationNode>>ClassNode repeatableAnnotationNode repeateeAnnotationNode collectorsetRuntimeRetention(...)Class<?> repeatableTypeRetention retentioncheckPrePostfixOperation(...)Variable accessedfixVar(...)VariableState variableStateVariableState.is_uninitializedVariableState.is_ambiguousvariableNotAlwaysInitialized(...)Map<Variable,VariableState> ifStatepushState(...)Map<Variable,VariableState> elseStateMap<Variable,VariableState> curStateRetention.classSet<Variable> allVarsboolean ifReturningreturningBlock(...)boolean elseReturningpopState(...)Variable varObject retentionevaluateExpression(...)VariableState beforeValueVariableState ifValueVariableState elseValueVariableState.is_varList<Statement> branchesnew Function<AnnotationNode,AnnotationConstantExpression>(...) { ... }List<Map<Variable,VariableState>> afterStatesnew ArrayList<Map<Variable,VariableState>>(...)Opcodes.ACC_DEPRECATED// TODO GROOVY-5011 handle case of @Override on a propertyint lastIndexClassNode annotationTypeMap<Variable,VariableState> beforeStateVerifier.DEFAULT_PARAMETER_GENERATEDboolean overrideMethodNode origMethodList<MethodNode> variantsisOverrideMethod(...)boolean returningMap<String,ClassNode> nextSpecStatement branchStatement blockgetDeclaredMethodCorrected(...)CaseStatement caseSMap<String,ClassNode> faceSpecfallsThrough(...)MethodNode declaredMap<Variable,VariableState> mapMethodNode correctedVariableState merged// record's instance fields are created by compiler and reuse type instance of record components.// return here to avoid processing type instance repeatedly.// by this stage annotations will be resolved so we can determine TYPE_USE ones// Check if the annotation target is correct, unless it's the target annotating an annotation definition// defining on which target elements the annotation applies// allow type use everywhere except package/** A context shared across generations of a class and its inner classes. */char[] charsnew char[]int innerClassIdx;int closureClassIdx;int syntheticMethodIdx;this.compileUnitthis.innerClassIdxgetNextInnerName(...)...[] CHARACTERS_TO_ENCODE;int MIN_ENCODING, ...;int lastEscapeStringBuilder bint encodeIndexCHARACTERS_TO_ENCODE.lengthnew Predicate<Map<Variable,VariableState>>(...) { ... }VariableState differentMap<Variable,VariableState> beforeTryStatenew HashMap<Variable,VariableState>(...)Statement tryStatementMap<Variable,VariableState> afterTryStateStatement finallyStatementMap<Variable,VariableState> correctedvisitCatchFinally(...)Map<Variable,VariableState> nextStateEntry<Variable,VariableState> entryVariableState currentCorrectedStateVariableState candidateCorrectedStateStatement lastboolean completesAbruptlyVariableState.is_finalimport static ConstructorNodeUtils.getFirstIfSpecialConstructorCallimport static ClassHelper.CLOSURE_TYPEvariableNotFinal(...)// This fixes xform declaration expressions but not other synthetic fields which aren't set up correctly// TODO consider removing fixVar once Spock 1.2 is released - replace with informational exception?// getTarget(var) can be null in buggy xform code, e.g. Spock <= 1.1import static ClassHelper.STRING_TYPEimport static GeneralUtils.ctorSuperXimport static GeneralUtils.ctorThisX/** Callback called whenever an assignment transforms an effectively final variable into a non final variable ... *//** Callback used whenever a variable is declared as final, but can remain in an uninitialized state ... */FieldNode thisField;String CLOSURE_INTERNAL_NAME, ...;// visit RHS first for expressions like a = b = 0// clean local vars added during visit of closure// remove local variable// merge if/else branches// collect after states// default branch// merge branches// the try finally case// now the finally only case but only if no catches// We don't try to analyse which statement within the try block might have thrown an exception.// We make a crude assumption that anywhere from none to all of the statements might have been executed.// Run visitor for both scenarios so the eager checks will be performed for either of these cases.// after states can only be empty if try and catch statements all return in which case nothing to do// now adjust the state variables - any early returns won't have gotten here// but we need to check that the same status was observed by all paths// and mark as ambiguous if neededboolean innerPojo// from ReturnAdder// currently only possibility// getTarget(var) can be null in buggy xform code, e.g. Spock// we maybe can't fix a synthetic fieldFieldNode currentField;MethodNode currentMethod;boolean inClosure, ...;isAnnotatedWithTrait(...)setUnresolvedSuperClass(...)boolean inClosureOldaddDispatcherMethods(...)addMopMethods(...)addThisReference(...)int additionalParamCountgetReferencedLocalVariablesCount(...)List<Parameter> parametersnew ArrayList<Parameter>(...)ConstructorNode superCtorConstructorCallExpression superCtorCallint objectDistancegetObjectDistance(...)setMethodDispatcherCode(...)setPropertySetterDispatcher(...)setPropertyGetterDispatcher(...)int outerClassDistanceString classInternalNamegetInternalName(...)String outerClassDescriptornew BiConsumer<BlockStatement,Parameter[]>(...) { ... }InnerClassCompletionVisitor$1getThis(...)InnerClassCompletionVisitor$2List<Expression> superCallArgumentsInnerClassCompletionVisitor$3int pCountpassThisReference(...)insertThis0ToSuperCall(...)BlockStatement methodBodyParameter[] newParamsgetUniqueName(...)Parameter thisParaBlockStatement newCodeshouldHandleImplicitThisForInnerClass(...)addFieldInit(...)ClassNode enclosingTypeParameter thisParameterIterator<Variable> itgetReferencedLocalVariablesIterator(...)ClassNode referenceTypeVariableExpression initialFieldNode pFieldsetClosureSharedVariable(...)setUseReferenceDirectly(...)shouldImplicitlyPassThisPara(...)boolean[] precedesSuperOrThisCallGroovyCodeVisitor visitorInnerClassVisitor$1boolean passInnerClassNode superInnerCNString namePrefix// add empty default constructor// use Iterator.hasNext() to check for available inner classes// an anonymous inner class may use a private constructor (via a bridge) if its super class is also an outer class// GROOVY-5728// since we added an anonymous inner class we should also// add the dispatcher methods// add method dispatcher// add property setter// add property getter// if there is a user-defined method, add compiler error and continue// add "this$0" field init//add this parameter to node// add thisPara to this(...)// we have a call to super here, so we need to add// our code after that// if the super class is another non-static inner class in the same outer class hierarchy, implicit this// needs to be passedimport static GeneralUtils.indexXClassNode OBJECT_ARRAY;indexX(...)int explicitOrImplicitStaticnew Consumer<Parameter>(...) { ... }// if (!(args instanceof Object[])) return target.(name)(args)// if (((Object[])args).length == 1) return target.(name)(args[0])// return target.(name)(*args)// TODO: Set class type parameter?import static GeneralUtils.defaultValueXnew Predicate<AnnotationNode>(...) { ... }/** Utility class to add return statements. ... */new ReturnStatementListener(...) { ... }/** Implement this method in order to be notified whenever a return statement is generated. */ReturnStatementListener DEFAULT_LISTENER;ReturnStatementListener listener;// passed as the first argument implicitly.// this is the counterpart of addThisReference(). To non-static inner classes, outer this should beboolean doAdd;/** If set to 'true', then returns are effectively added. This is useful whenever you just want ... */this.doAddboolean isInStaticContextClassNode enclosingnew ReturnAdder(...)/** Adds return statements to given method whenever an implicit return is detected. */addReturnsIfNeeded(...)Expression this0// GROOVY-5681: initial expressions should be visited too!// expressions = constructor call arguments// block = init code for the constructor we produce// parameters = parameters of the constructor// superCallArguments = arguments for the super call == the constructor call arguments// first we add a super() call for all expressions given in the constructor call expression// add one parameter for each expression in the constructor call// add the corresponding argument to the super constructor call// add the super call// need to pass "this" to access unknown methods/properties// "this" reference is saved in a field named "this$0"// for each shared variable, add a Reference field// GROOVY-8433: Category transform implies static method// GROOVY-10289// TODO: if enclosing is a local type, also test field or method// constructor call is in static context and the inner class is non-static - 1st arg is supposed to be// passed as enclosing "this" instance// calculate outer class which we need for this$0// if constructor call is not in outer class, don't pass 'this' implicitly. Return.// bypass closure// GROOVY-8104: an anonymous inner class may still have closure nestingimport DynamicVariableimport static MethodNodeUtils.getPropertyNameimport static GeneralUtils.getAllProperties/** Initializes the variable scopes for an AST. */new LinkedList<StateStackElement>(...)defaultValueX(...)returnStatementAdded(...)SynchronizedStatement syncStatementIfStatement ifElseStatementsetIfBlock(...)setElseBlock(...)Statement defaultStatementList<CaseStatement> caseStatementsIterator<CaseStatement> itadjustSwitchCaseCode(...)setDefaultStatement(...)TryCatchStatement tryCatchFinallyboolean[] missesReturnboolean hasFinallysetTryStatement(...)int breakIndexStatement breakStatement// happens with @interface methods// GROOVY-9896: return if no default and last case lacks break// if there is no missing return in the finally block and the block exists// there is nothing to do// add returns to try and catch blocks// GROOVY-9880: some code structures will fall throughimport GroovyClassVisitorimport ClassNodeSkipimport static Modifier.isPublicimport static Collectors.joiningimport static MethodNodeUtils.methodDescriptorWithoutReturnTypeimport static GeneralUtils.bytecodeXimport static GenericsUtils.addMethodGenericsimport static PropertyNodeUtils.adjustPropertyModifiersForMethodVariableScope currentScope;boolean recurseInnerClasses;Deque<StateStackElement> stateStack;/** Verifies the AST node and adds any default AST code before bytecode generation occurs. ... */ClassNode clazz;Transient.classClassHelper.METACLASS_TYPEthis.inClosurethis.inConstructorString SWAP_INIT;String STATIC_METACLASS_BOOL;String INITIAL_EXPRESSION;String DEFAULT_PARAMETER_GENERATED;ClassNode GENERATED_ANNOTATION;ClassNode INTERNAL_ANNOTATION;ClassNode TRANSIENT_ANNOTATION;String __TIMESTAMP;// NOTE: timeStamp constants shouldn't belong to Verifier but kept here for binary compatibilityString __TIMESTAMP__;this.currentScopeClass<Sealed> SEALED_TYPE;Class<NonSealed> NON_SEALED_TYPE;...[] SET_METACLASS_PARAMS;this.recurseInnerClassesMethodNode methodNode;FieldNode metaClassFieldClassNode current//----------------------------------// helper methodsClassNode mcFieldTypenew StateStackElement(...)StateStackElement statestate.clazzstate.scopestate.inClosurestate.inConstructordeclare(...)String scopeTypeString variableTypenew Consumer<MethodVisitor>(...) { ... }FieldNode.classboolean skipGroovifyPropertyNode.classdetectInvalidRecordComponentNames(...)checkForDuplicateInterfaces(...)addInitialization(...)getDeclaredVariable(...)ClassNodeSkip.classaddDefaultParameterMethods(...)addDefaultParameterConstructors(...)addStaticMetaClassField(...)addFastPathHelperFieldsAndHelperMethod(...)ClassHelper.GROOVY_OBJECT_SUPPORT_TYPEaddGroovyObjectInterfaceAndMethods(...)addGetLookupMethod(...)addDefaultConstructor(...)checkReturnInObjectInitializer(...)getClassScope(...)boolean abstractTypegetPropertyName(...)checkForDuplicateMethods(...)addCovariantMethods(...)detectNonSealedClasses(...)checkFinalVariables(...)...[] INVALID_COMPONENTS;GroovyClassVisitor visitornew FinalVariableAnalyzer(...)getFinalVariablesCallback(...)FinalVariableAnalyzer.VariableNotFinalCallbacknew FinalVariableAnalyzer.VariableNotFinalCallback(...) { ... }Verifier$1Variable variableboolean crossingStaticContextboolean isClassVariableisClassScope(...)isReferencedLocalVariable(...)isReferencedClassVariable(...)VariableScope endList<Set<ClassNode>> allInterfacesnew ArrayList<Set<ClassNode>>(...)getReferencedLocalVariable(...)getReferencedClassVariable(...)Variable memberfindClassMember(...)boolean requireStaticisScript(...)new DynamicVariable(...)putReferencedClassVariable(...)putReferencedLocalVariable(...)// variable checksBiConsumer<VariableExpression,ASTNode> checkForFinalnew BiConsumer<VariableExpression,ASTNode>(...) { ... }Expression tupleExpressionList<String> interfaceNames/** A property on "this", like this.x is transformed to a direct field access, ... */Expression objectcheckVariableContextAccess(...)/** Sets the current class node context. */setClassScope(...)Iterator<InnerClassNode> innerClassesParameter varmarkClosureSharedVariables(...)boolean oldInSpecialCtorFlagExpression initExpressionTupleExpression listExpression listExpressionfindVariableDeclaration(...)ConstantExpression methodNameConstantSet<ClassNode> setVariableExpression objectConstantExpression methodString oneString twocheckPropertyOnExplicitThis(...)Set<String> descriptorsString mySigmethodDescriptorWithoutReturnType(...)// if we are in a class and no variable is declared until// now, then we can break the loop, because we are allowed// to declare a variable of the same name as a class memberscriptBodySignatureWithoutReturnType(...)// variable already declared// declare the variable even if there was an error to allow more checkssourceOf(...)// check for super property before returning a pseudo-property// try to find a declaration of a variable// prevent a static context (e.g. a static method) from accessing a non-static member (e.g. a non-static field)// GROOVY-5961// TODO: handle local variables// currently not looking for PropertyExpression: dealt with at runtime using ReadOnlyPropertyException// declare a static variable to be able to continue the check// AIC are already done, doing them here again will lead to wrong scopes// add parameters to scope and visit init expressions after annotations// to prevent the use of parameters in annotation attributes// GROOVY-7033// disable implicit "it"// GROOVY-6834: accessing a parameter which is not yet seen in scope// visit right side first to prevent the use of a variable before its declaration//TODO: change that to get the correct scope// important for GROOVY-4344FieldNode retFieldNode stMCBcheckFieldDoesNotExist(...)/** Performs various checks on code inside methods and constructors ... */assertValidIdentifier(...)MethodHandles.Lookup.classVerifier$2ClassNode callTypeString _staticClassInfoFieldNamechar firstChString staticMetaClassFieldNameFieldNode staticMetaClassFieldClassInfo.classVerifier$3char chgetMetaClassField(...)Statement getMetaClassCodeVerifier$4import JanitorLabel nullLabelimport SourceTextimport SourceTextNotAvailableExceptionimport static Opcodes.IFEQMethodCaller assertFailedMethod;// assertint recorderIndex;SourceText sourceText;AssertionTracker assertionTracker;AssertionTracker disabledTracker;this.controllerboolean rewriteAssertisNull(...)setMetaClassFieldIfNotExists(...)AssertionTracker oldTrackerJanitor janitornew Janitor(...)Label tryStartLabel exceptionThrowerjump(...)Statement setMetaClassCodeLabel afterAssertAssertionTracker savedTrackernew AssertionTracker(...)Verifier$5assertionTracker.sourceTextnew SourceText(...)/** Helper method to add a new method to a ClassNode.  Depending on the shouldBeSynthetic flag the ... */assertionTracker.recorderIndexSourceTextNotAvailableException egetAcg(...)// for binary compatibility only, don't use or override thisgetNormalizedText(...)writeSourcelessAssertText(...)Verifier$6Label tryEndLabel catchAnysavedTracker.recorderIndexaddExceptionBlock(...)new VerifierCodeVisitor(...)Verifier$7cleanup(...)boolean oldInClosureboolean oldIsSpecialConstructorCallString expressionTextList<String> listisThisObjectExpression(...)MethodNode methodTargetgetMethodTarget(...)newVariableError(...)isNonStaticMemberAccess(...)RuntimeParserException rpeisMopMethod(...)adjustTypesIfStaticMainMethod(...)this.methodNodeaddReturnIfNeeded(...)ReturnAdder adderint accessorModifiersStatement getterBlockint getterModifiersaddVariableNames(...)int tempIndexMethodNode gettermethodNeedsReplacement(...)createGetterBlock(...)createSetterBlock(...)visitGetter(...)String altGetterNameMethodNode altGettergetNormalizedColumn(...)Parameter[] setterParameterTypesaddPropertyMethod(...)dup(...)copyAnnotations(...)BooleanExpression boolExpBinaryExpression binExpClassNode methodReturnType// don't rewrite assertions with message// because source position seems to be more reliable for statements// than for expressions, we get the source text for the whole statement//TODO: maybe use more specialized type hereClassNode nodeReturnType// set assertionTracker to null to deactivate AssertionWriter#record calls// don't rewrite assertions w/o source text// do nothing, but clear the value recorder//clean up assertion recorder// now the optional exception expression// assertFailed called static with 2 arguments// finally block to clean assertion recorderClassNode abstractMethodParameterType// add catch any block to exception table// close possibly open file handles from getting a sample for// power asserts// push expression string onto stackClassNode methodParameterType// let's create a new expression//TODO: maybe use more special type StringBuffer here//helper.swapWithObject(ClassHelper.OBJECT_TYPE);/** Creates a new method for each combination of default parameter expressions. */import BytecodeInterface8/** Binary write operations specialised for Booleans */BytecodeInterface8.classMethodCaller boolArrayGet, ...;/* DIV */addDefaultParameters(...)new DefaultArgsAction(...) { ... }MethodNode oldMethodVerifier$8boolean inClosure;boolean previmport static Opcodes.DADDimport static Opcodes.DCMPGimport static Opcodes.DCONST_1import static Opcodes.DDIVimport static Opcodes.DMULimport static Opcodes.DREMimport static Opcodes.DSUBMethodCaller doubleArrayGet, ...;...[] stdOperations;VariableScope blockScopeVariableExpression localVariable//  PLUS        200//  MINUS       201//  MULTIPLY    202//  DIV         203//  INTDIV      204//  MOD         203MethodCallExpression callimport AsmClassGeneratorimport static Types.ASSIGNimport static Types.BITWISE_AND_EQUALimport static Types.BITWISE_OR_EQUALimport static Types.BITWISE_XOR_EQUALimport static Types.COMPARE_EQUALimport static Types.COMPARE_GREATER_THANimport static Types.COMPARE_GREATER_THAN_EQUALimport static Types.COMPARE_IDENTICALimport static Types.COMPARE_LESS_THANimport static Types.COMPARE_LESS_THAN_EQUALimport static Types.COMPARE_NOT_EQUALimport static Types.COMPARE_NOT_IDENTICALimport static Types.COMPARE_NOT_INimport static Types.COMPARE_NOT_INSTANCEOFimport static Types.COMPARE_TOimport static Types.DIVIDE_EQUALimport static Types.ELVIS_EQUALimport static Types.EQUALimport static Types.FIND_REGEXimport static Types.INTDIVimport static Types.INTDIV_EQUALimport static Types.KEYWORD_INimport static Types.KEYWORD_INSTANCEOFimport static Types.LEFT_SHIFT_EQUALimport static Types.LEFT_SQUARE_BRACKETimport static Types.LOGICAL_ANDimport static Types.LOGICAL_ORimport static Types.MATCH_REGEXimport static Types.MINUS_EQUALimport static Types.MINUS_MINUSimport static Types.MODimport static Types.MOD_EQUALimport static Types.MULTIPLY_EQUALimport static Types.PLUS_EQUALimport static Types.PLUS_PLUSimport static Types.POWER_EQUALimport static Types.RIGHT_SHIFT_EQUALimport static Types.RIGHT_SHIFT_UNSIGNED_EQUALimport static Opcodes.IFNEimport static Opcodes.INSTANCEOFVerifier$9/** Creates a new constructor for each combination of default parameter expressions. */MethodCaller compareIdenticalMethod;// compareMethodCaller compareNotIdenticalMethod;MethodCaller compareEqualMethod;MethodCaller compareNotEqualMethod;MethodCaller compareToMethod;MethodCaller compareLessThanMethod;MethodCaller compareLessThanEqualMethod;MethodCaller compareGreaterThanMethod;MethodCaller compareGreaterThanEqualMethod;MethodCaller findRegexMethod;// regexpMethodCaller matchRegexMethod;MethodCaller isCaseMethod;// isCase/isNotCaseMethodCaller isNotCaseMethod;UnaryExpressionHelper unaryExpressionHelper;this.unaryExpressionHelpernew UnaryExpressionHelper(...)List<Parameter> paramListVerifier$10String errorevaluateCompareExpression(...)evaluateCompareTo(...)evaluateLogicalAndExpression(...)evaluateLogicalOrExpression(...)evaluateBinaryExpression(...)evaluateBinaryExpressionWithAssignment(...)evaluateElvisEqual(...)evaluateInstanceof(...)evaluateNotInstanceof(...)assignToArray(...)ArgumentListExpression aemakeCall(...)InvocationWriter.invokeMethodToken operationBinaryExpression elvisAssignmentExpressionAsmClassGenerator acgCompileStack compileStackboolean directAssignmentClassNode lhsTypeClassNode rhsTypegetTopOperand(...)int rhsValueIdBytecodeExpression rhsValueLoadernew VariableSlotLoader(...)BytecodeVariable vardefineVariable(...)ArrayExpression arrayloadInitValue(...)BinaryExpression leftBinExprpushLHS(...)popLHS(...)Expression leftExpExpression rightExpClassNode leftTypeClassNode rightTypeBinaryExpressionMultiTypeDispatcher helpernew BinaryExpressionMultiTypeDispatcher(...)doPrimitiveCompare(...)ClassNode resTypeClassHelper.Integer_TYPELabel falseCaseLabel trueCaseConstantExpression.PRIM_TRUEConstantExpression.PRIM_FALSEConstructorNode newConstructorLabel endVerifier$11/** Creates a new helper method for each combination of default parameter expressions. */makeSingleArgumentCall(...)long nExpressionAsVariableSlot subscriptnew ExpressionAsVariableSlot(...)ExpressionAsVariableSlot receiverMethodCallExpression getAtMethodCallExpression operationExpressionAsVariableSlot retMethodCallExpression putAtOperandStack osArgumentListExpression argumentsBinaryExpression bexpevaluateArrayAssignmentWithOperator(...)Verifier.INITIAL_EXPRESSIONGeneralUtils.INSTANCEOFboolean addSwapInitmoveOptimizedConstantsInitialization(...)VariableSlotLoader usesSubscriptloadWithSubscript(...)BytecodeSequence seqClassNode expressionTypeVerifier$12int tempIdxexecMethodAndStoreForSubscriptOperator(...)List<Statement> swapCallint opExpression subscriptClassNode subscriptTypeint idVariableSlotLoader subscriptExpressionBinaryExpression rewritehasPlaceHolders(...)ConstructorCallExpression specialCtorCallList<Statement> staticStatementsList<Statement> initStmtsAfterEnumValuesInitwritePostOrPrefixMethod(...)BlockStatement newBlockClassNode methodResultTypeint resultIdxBytecodeExpression methodResultLoaderSet<String> explicitStaticPropsInEnumgetExplicitStaticProperties(...)addFieldInitialization(...)ClassNode exprTypeextractVariableReferenceInitializers(...)Expression callSiteReceiverSwapBinaryExpressionHelper$1Statement initThis$0getImplicitThis$0Stmt(...)makeCallSite(...)positionStmtsAfterEnumInitStmts(...)Set<String> staticPropertiesTypeChooser typeChooserExpression boolPartExpression falsePartClassNode truePartTypeClassNode falsePartType/** When InnerClassVisitor adds <code>this.this$0 = $p$n</code>, it adds it ... */ClassNode commonList<Statement> stmtsint retValueIdStatement bstmtextractImplicitThis$0StmtFromExpression(...)Expression lExprList<Statement> localVariableReferencesExpression truePartListIterator<Statement> itBinaryExpression exprevaluateElvisOperatorExpression(...)evaluateNormalTernary(...)// TODO: add generics to collections// = (aka assignment)// ==//SPG don't use divide since BigInteger implements directly//and we want to dispatch through DefaultGroovyMethods to get a BigDecimal result// let's replace this assignment to a subscript operator with a// method call// e.g. x[5] = 10// -> (x, [], 5), =, 10// -> methodCall(x, "putAt", [5, 10])// return value of assignment// evaluate the RHS and store the result// TODO: LHS has not been visited, it could be a variable in a closure and type chooser is not aware.// TODO: lhsType?// GROOVY-5570: if a closure shared variable is a primitive type, it must be boxedFieldExpression fe// ensure we try to unbox null to cause a runtime NPE in case we assign// null to a primitive typed variable, even if it is used only in boxed// form as it is closure shared// these two are never reached in bytecode and only there// to avoid verify errors and compiler infrastructure hazzle// normal type transformation// TODO: if RHS is VariableSlotLoader already, then skip creating a new one// assignment for subscript// multiple declaration// single declaration// normal assignment// if the right hand side is a boolean expression, we need to autobox// have to remove 1 because of the GOTO// ensure VariableArguments are read, not stored// e.g. x[a] += b// to avoid loading x and a twice we transform the expression to use// ExpressionAsVariableSlot// -> subscript=a, receiver=x, receiver[subscript]+b, =, receiver[subscript]// -> subscript=a, receiver=x, receiver#getAt(subscript)#plus(b), =, receiver#putAt(subscript)// -> subscript=a, receiver=x, receiver#putAt(subscript, receiver#getAt(subscript)#plus(b))// the result of x[a] += b is x[a]+b, thus:// -> subscript=a, receiver=x, receiver#putAt(subscript, ret=receiver#getAt(subscript)#plus(b)), ret// br to leave a copy of rvalue on the stack; see also isPopRequired()// load Expressions// save copy for later// execute method// remove the result of the method call// reload saved value// load expressions// new value is already on stack, so nothing to do here// if we have a BinaryExpression, check if it is with subscription// right expression is the subscript expression// we store the result of the subscription on the stack// normal loading of expression// we need special code for arrays to store the result (like for a[1]++)// execute the assignment, this will leave the right side (here the method call result) on the stack// here we handle a++ and a.b++// other cases don't need storing, so nothing to be done for them// at this point the receiver will be already on the stack// in a[1]++ the method will be "++" aka "next" and the receiver a[1]// CallSite is normally not showing up on the// operandStack, so we place a dummy here with same// slot length.// change (receiver,callsite) to (callsite,receiver)// no need to keep any of those on the operand stack// after this expression is processed, the operand stack// will contain callSiteReceiverSwap.getType()// this will load the callsite and the receiver normally in the wrong// order since the receiver is already present, but before the callsite// Therefore we use callSiteReceiverSwap to correct the order.// After this call the JVM operand stack will contain the result of// the method call... usually simply Object in operandStack// now rhs is completely done and we need only to store. In a[1]++ this// would be a.getAt(1).next() for the rhs, "lhs" code is a.putAt(1, rhs)// x?:y is equal to x?x:y, which evals to//      var t=x; boolean(t)?t:y// first we load x, dup it, convert the dupped to boolean, then// jump depending on the value. For true we are done, for false we// have to load y, thus we first remove x and then load y.// But since x and y may have different stack lengths, this cannot work// Thus we have to have to do the following:// Be X the type of x, Y the type of y and S the common supertype of// X and Y, then we have to see x?:y as//      var t=x;boolean(t)?S(t):S(y)// so we load x, dup it, store the value in a local variable (t), then// do boolean conversion. In the true part load t and cast it to S,// in the false part load y and cast y to S// load x, dup it, store one in $t and cast the remaining one to boolean// true part: load $t and cast to S// false part: load false expression and cast to S// finish and cleanup// we compile b?x:y as//      boolean(b)?S(x):S(y), S = common super type of x,y// so we load b, do boolean conversion.// In the true part load x and cast it to S,// load b and convert to boolean// true part: load x and cast to S// false part: load y and cast to S/** Capitalizes the start of the given bean property name. */Verifier$13import static ClassHelper.boolean_TYPEimport static ClassHelper.char_TYPEimport static WideningCategories.isBigDecCategoryimport static WideningCategories.isDoubleCategoryimport static WideningCategories.isIntCategoryimport static WideningCategories.isLongCategoryimport static WideningCategories.isNumberCategoryimport static TokenUtil.removeAssignment/** This class is for internal use only! ... */initializeDelegateHelpers(...)Verifier$14NumberFormatException eGroovyClassLoader.InnerLoaderMethodCaller charArrayGet, ...;MethodCaller byteArrayGet, ...;MethodCaller shortArrayGet, ...;...[] binExpWriter;new BinaryExpressionWriter[]new BinaryObjectExpressionHelper(...)new BinaryIntExpressionHelper(...)new BinaryLongExpressionHelper(...)new BinaryDoubleExpressionHelper(...)new BinaryCharExpressionHelper(...)new BinaryByteExpressionHelper(...)new BinaryShortExpressionHelper(...)new BinaryFloatExpressionHelper(...)new BinaryBooleanExpressionHelper(...)Map<ClassNode,Integer> typeMap;...[] typeMapKeyNames;isDoubleCategory(...)InnerLoader innerLoaderMap<String,MethodNode> methodsToAddint operationint operationTypegetOperandConversionType(...)BinaryExpressionWriter bewgetNormalOpResultType(...)removeAssignment(...)ClassNode leftTypeOriggetOperandType(...)arrayGet(...)isIntCastableType(...)getArrayGetResultType(...)writeDivision(...)getDevisionOpResultType(...)isShiftOperation(...)isNumberCategory(...)boolean simulationSuccessBinaryExpression arrayWithSubscriptint subscriptValueIdint resultValueIdisAssignmentToArray(...)arraySet(...)doAssignmentToArray(...)doAssignmentToLocalVariable(...)Map<String,MethodNode> abstractMethodsgetDeclaredMethodsFromInterfaces(...)Map<String,MethodNode> allInterfaceMethodsMap<String,MethodNode> declaredMethodsMapaddDeclaredMethodsFromAllInterfaces(...)Iterator<MethodNode> methodsIteratorClassNode arrayComponentTypeMethodNode intfMethod/* 0: dummy *//* 1: int *//* 2: long */List<MethodNode> classMethods/* 3: double *//* 4: char *//* 5: byte *//* 6: short *//* 7: float *//* 8: bool */// we need to handle only assignment to arrays combined with an operation// special here. e.g x[a] += b// for x[a] += b we have the structure://   x = left(left(binExp))), b = right(binExp), a = right(left(binExp)))// for array set we need these values on stack: array, index, right// for array get we need these values on stack: array, index// to eval the expression we need x[a] = x[a]+b// -> arraySet(x,a, x[a]+b)// -> arraySet(x,a, arrayGet(x,a,b))// --> x,a, x,a, b as operands// --> load x, load a, DUP2, call arrayGet, load b, call operation,call arraySet// since we cannot DUP2 here easily we will save the subscript and DUP x// --> sub=a, load x, DUP, load sub, call arrayGet, load b, call operation, load sub, call arraySet// load array index: sub=a [load x, DUP, load sub, call arrayGet, load b, call operation, load sub, call arraySet]storeMissingCovariantMethods(...)// load array: load x and DUP [load sub, call arrayGet, load b, call operation, load sub, call arraySet]// array get: load sub, call arrayGet [load b, call operation, load sub, call arraySet]// complete rhs: load b, call operation [load sub, call arraySet]// in primopts we convert to the left type for supported binary operations// let us save that value for the return// array set: load sub, call arraySet []// 3 operands, the array, the index and the value!// load return value// cleanup/* field and declaration we don't return false */// load the array// load index// load rhs// store value in array// load return value && correct operand stack stackList<MethodNode> interfacesMethodsboolean equalParametersequalParametersNormal(...)ClassNode nmrClassNode omrboolean equalReturnTypeClassNode omrCorrectedequalParametersWithGenerics(...)isAssignable(...)import static Opcodes.ICONST_M1import static Opcodes.IFGEimport static Opcodes.IFGTimport static Opcodes.IFLEimport static Opcodes.IFLT/** Base class for writing primitive typed operations */MethodCaller arraySet, ...;this.arraySetthis.arrayGet/** return writer controller ... */...[] stdCompareCodes;boolean oldM/** writes some int standard operations for compares ... */boolean newMint bytecodegetCompareCode(...)cleanType(...)cleanParameters(...)Verifier$15Parameter[] paraParameter[] goalint doubleSlotOffsetpara.lengthLabel l3doubleTwoOperands(...)removeTwoOperands(...)isArrayAssignable(...)getStandardOperationBytecode(...)supportsDivision(...)/** writes some the bitwise operations. type is one of BITWISE_OR, ... */getBitwiseOperationBytecode(...)/** Write shifting operations. ... */MethodNode toOverridegetShiftOperationBytecode(...)MethodNode bridgeMethodgetCovariantImplementation(...)writeShiftOp(...)writeBitwiseOp(...)writeStdOperators(...)writeStdCompare(...)writeSpaceship(...)ClassNode parameterTypegetArrayGetCaller(...)getArraySetCaller(...)writePlusPlus(...)writeMinusMinus(...)ClassNode genericsType// COMPARE_NOT_EQUAL            120// COMPARE_IDENTICAL            121// COMPARE_NOT_IDENTICAL        122int mods// COMPARE_EQUAL                123// COMPARE_LESS_THAN            124// COMPARE_LESS_THAN_EQUAL      125BlockStatement methodCode// COMPARE_GREATER_THAN         126new SwapInitStatement(...)// COMPARE_GREATER_THAN_EQUAL   127// look if really compare// operands are on the stack already/* we will actually do ... */boolean swapInitRequired// duplicate arguments// no jump, so -1, need to pop off surplus LLConstantExpression init/** When constant expressions are created, the value is always wrapped to a non primitive type. ... */getUnwrapper(...)new SwapInitInstruction(...)(...).statementimport static Opcodes.FADDimport static Opcodes.FCMPGimport static Opcodes.FCONST_1import static Opcodes.FDIVimport static Opcodes.FMULimport static Opcodes.FREMimport static Opcodes.FSUBimport static Opcodes.POP2MethodCaller floatArrayGet, ...;getController(...)SwapInitStatement statement;makeCallSiteArrayInitializer(...)statement.controller// interfaces have no constructors but this expects one,// so create a dummy but do not add it to the class node// GROOVY-5106: check for same interface with different type argument(s)// no peer interface(s) to verify// find match and check generics// static method cannot be declared in non-static inner class until Java 16/* the code is: ... */ClassHelper.BigDecimal_TYPE/* the code is (meta class is stored in 1): ... *///  DIV, (203) but we don't want that one// return is OK in closures in object initializers// check for uninitialized-this references// before this/super ctor call completes, only params and static or outer members are accessible// TODO: context for default argument// GROOVY-3712: if it's an MOP method, it's an error as they aren't supposed to exist before ACG is invoked// no method found, we need to replace// method is in current class, nothing to be done// do not overwrite final// atypical: allow setter with non-void return type// don't make static accessors final// GROOVY-4415 / GROOVY-4645: check that there's no abstract method which corresponds to this one// matching method, remove abstract status and use the same body// GROOVY-5632, GROOVY-9151: check for references to parameters that have been removed// create a variable declaration so that the name can be found in the new method// if variable was created to capture an initial value expression, reference it in arguments as well// delegate to original method using arguments derived from defaults// GROOVY-5681: set anon. inner enclosing method reference// GROOVY-9151: check for references to parameters that have been removed// replace argument "(Type) param" with "(Type) <param's default>" for simple default value// delegate to original constructor using arguments derived from defaults// TODO: Copy annotations, etc.?// set anon. inner enclosing method reference// remove default expression and store it as node metadata// add a new invoke// if some transformation decided to generate constructor then it probably knows best// in case of this(...) let the other constructor initialize// GROOVY-7686: place local variable references above super ctor call// GROOVY-4471: place this$0 init above other field init and super ctor call;// there can be field initializers that depend on method/property dispatching// GROOVY-3161: initialization statements for explicitly declared static// fields inside an enum should come after enum values are initialized// remove from here and let the caller reposition it// the first statement is the super constructor call  ^/* also could check if the right expression is a variable expression that references ctor parameter */// GROOVY-3311: pre-defined constants added by compiler for numbers/characters should be// initialized first so that code dependent on them does not see their values as empty// GROOVY-5150: primitive type constants will be initialized directly// to avoid double initialization in case of several constructors/* If it is a statement for an explicitly declared static field inside an enum, store its ... */// unimplemented abstract methods from interfaces// remove all static, private and package private methods// we skip bridge methods implemented in current class already// original class causing bridge methods for methods in super class// super class causing bridge methods for abstract methods in original class// parameters// return type// TODO: ClassNode nmrCorrected = correctToGenericsSpec(..., nmr)?/* oldM */// if we reach this point there is least one parameter or return type// that is different in its specified form, so create a bridge method// TODO: Should this be directly handled by getPlainNodeReference?import static Opcodes.IADDimport static Opcodes.IANDimport static Opcodes.IDIVimport static Opcodes.IF_ICMPEQimport static Opcodes.IF_ICMPGEimport static Opcodes.IF_ICMPGTimport static Opcodes.IF_ICMPLEimport static Opcodes.IF_ICMPLTimport static Opcodes.IF_ICMPNEimport static Opcodes.IMULimport static Opcodes.IORimport static Opcodes.IREMimport static Opcodes.ISHLimport static Opcodes.ISHRimport static Opcodes.ISUBimport static Opcodes.IUSHRimport static Opcodes.IXORMethodCaller intArrayGet;MethodCaller intArraySet;...[] bitOp;...[] shiftOp;/* unhandled types from from org.codehaus.groovy.syntax.Types ... *//* public static final int LEFT_SHIFT_EQUAL            = 285;   // <<= ... *//** writes a std compare. This involves the tokens IF_ICMPEQ, IF_ICMPNE, ... */import static Opcodes.DUP2_X1import static Opcodes.LADDimport static Opcodes.LANDimport static Opcodes.LCMPimport static Opcodes.LCONST_1import static Opcodes.LDIVimport static Opcodes.LMULimport static Opcodes.LORimport static Opcodes.LREMimport static Opcodes.LSHLimport static Opcodes.LSHRimport static Opcodes.LSUBimport static Opcodes.LUSHRimport static Opcodes.LXOR/** writes the spaceship operator, type should be COMPARE_TO ... */MethodCaller longArrayGet, ...;/* since there is no DUP4 we have to do this: ... *///  BITWISE_OR / PIPE   340//  BITWISE_AND         341//  BIWISE_XOR          342// LEFT_SHIFT               280// COMPARE_IDENTICAL            121 // RIGHT_SHIFT              281// RIGHT_SHIFT_UNSIGNED     282// duplicate int arguments// no jump, so -1, need to pop off surplus IIMethodCaller arrayGet;MethodCaller arraySet;// dummy methodsimport TraceClassVisitor/** An utility class which can be used in test cases to dump generated bytecode. ... */new BytecodeDumper(...)BytecodeDumper STANDARD_ERR;PrintWriter pwTraceClassVisitor visitornew TraceClassVisitor(...)ClassReader readerimport static Opcodes.BIPUSHimport static Opcodes.DCMPLimport static Opcodes.DCONST_0import static Opcodes.DLOADimport static Opcodes.DRETURNimport static Opcodes.DSTORE/** Represents compile time variable metadata while compiling a method. */import static Opcodes.FCMPLimport static Opcodes.FCONST_0import static Opcodes.FLOADimport static Opcodes.FRETURNimport static Opcodes.FSTOREimport static Opcodes.ICONST_2import static Opcodes.ICONST_3import static Opcodes.ICONST_4import static Opcodes.ICONST_5new BytecodeVariable(...)import static Opcodes.IRETURNimport static Opcodes.ISTOREBytecodeVariable THIS_VARIABLE;import static Opcodes.LCONST_0import static Opcodes.LLOADimport static Opcodes.LRETURNBytecodeVariable SUPER_VARIABLE;import static Opcodes.LSTOREimport static Opcodes.SIPUSHint prevCurrent;Label startLabel;// these fields should probably go to jvm Operand class// br for setting on the LocalVariableTable in the class fileLabel endLabel;this.prevCurrent/** A helper class for bytecode generation with AsmClassGenerator. */DefaultTypeTransformation.classString DTT_CLASSNAME;this.startLabelgetDescriptionByType(...)this.endLabel/** Returns a method descriptor for the given {@link org.codehaus.groovy.ast.MethodNode}. ... */Class<> paramType/** array types are special: ... */ClassNode dimport static Opcodes.AALOADimport static Opcodes.IFNULLimport static Opcodes.INVOKEINTERFACEimport static Opcodes.NOPString[] answer/** This class represents non public API used by AsmClassGenerator. Don't ... */Byte.MIN_VALUEByte.MAX_VALUEShort.MIN_VALUEShort.MAX_VALUE/** Negate a boolean on stack. */Label endLabelLabel falseLabel/** returns a name that Class.forName() can take. Notably for arrays: ... */getDescriptionByName(...)param.lengthhasGenerics(...)Parameter[] paramGenericsType[] paramTypesgetGenericsTypeSpec(...)ClassNode pTypeaddSubTypes(...)ClassNode sclassusesGenericsInTypeSignature(...)GenericsType extendsPartusesGenericsInClassSignature(...)writeGenericsBounds(...)GenericsType interfacePartint SIG_ARRAY_LENGTH;...[] sig;ClassNode[] boundswriteGenericsBoundType(...)int MOD_PRIVSS, ...;ClassNode CALLSITE_ARRAY_TYPE;String GET_CALLSITE_METHOD, ...;List<String> callSites;int callSiteArrayVarIndex;InterfaceHelperClassNode ihcnisNotClinit(...)generateCreateCallSiteArray(...)generateGetCallSiteArray(...)unbox(...)/** Given a wrapped number type (Byte, Integer, Short, ...), generates bytecode ... *//** Given a primitive number type (byte, integer, short, ...), generates bytecode ... */List<String> callSiteInitMethods/** Generates the bytecode to autobox the current value on the stack. */getCachedClass(...).isPrimitivevoid.class/** Generates the bytecode to unbox the current value on the stack. *//** Visits a class literal. If the type of the classnode is a primitive type, ... *//** Tells if a class node is candidate for class literal bytecode optimization. If so, ... *//** Returns true if the two classes share the same compilation unit. ... */CompileUnit cu1CompileUnit cu2/** Computes a hash code for a string. The purpose of this hashcode is to be constant independently of ... */int hchar aChar/** Converts a primitive type to boolean. ... */Label trueLabelconvertDoubleToBoolean(...)convertFloatToBoolean(...)Label falseLabelWithPopint methodIndexint maxArrayInitnew ReturnVarHandler(...)new LoadVarHandler(...)new StoreVarHandler(...)this.mvint methodLimitint idx;this.idxhandleDoubleType(...)handleFloatType(...)handleLongType(...)handleIntType(...)handleVoidType(...)handleRefType(...)/** boolean, char, byte, int, short types are handle in the same way */String method// lets avoid class loading// remove "L" and ";"// code to negate the primitive boolean// todo need process multiallocateIndex(...)// the current implementation only checks for public modifier, because Groovy used to allow// handles on classes even if they are package protected and not in the same package.// There are situations where we could make more fine grained checks, but be careful of// potential breakage of existing code.// Special handling is done for floating point types in order to// handle checking for 0 or NaN values.// Convert long to int for IFEQ comparison using LCMP// This handles byte, short, char and int// will need the extra for isNaN call if requiredprepareSiteAndReceiver(...)prepareCallSite(...)pushImplicitThis(...)popImplicitThis(...)int m1int m2visitBoxedArgument(...)import static StaticTypesMarker.INFERRED_RETURN_TYPEnew HashMap<Expression,ClassNode>(...)invokeSafe(...)CompileStack csint numberOfArgumentsargumentSize(...)int operandsToReplaceMethodCallerMultiAdapter.MAX_ARGSArgumentListExpression listmakeArgumentList(...)String OUTER_INSTANCE;String THIS_OBJECT;Map<Expression,ClassNode> closureClasses;getCreateArraySignature(...)String closureClassinternalName// GROOVY-9076: need this for debugger to support step into// create array initialization methods// check if the next block is over the max allowed// create base createCallSiteArray method//site// receiver// we are not in a tuple, so boxing might be missing for// this single argument call//slow Path// spread expression case produces Object[]// messageNameParameter[] localVariableParamslocalVariableParams.lengthloadReference(...)ClosureWriter.UseExistingReference.classClosureWriter.UseExistingReferenceimport static Opcodes.DUP_X1containsVariable(...)getScope(...)BytecodeVariable vclassNodeUsesReferences(...)createClosureClass(...)ClassHelper.GENERATED_CLOSURE_Typenew WriterControllerFactory(...) { ... }boolean retgenClosureClassName(...)getClosureSharedVariables(...)/** Manages different aspects of the code of a code block like handling labels, ... */InnerClassNode answernew HashMap<String,BytecodeVariable>(...)VariableScope varScopecreateBlockStatementForConstructor(...)Parameter itVariable refremoveInitialValues(...)getMethodNode(...)setStaticClass(...)MethodNode calladdFieldsAndGettersForLocalVariables(...)correctAccessedVariable(...)String paramNameVariableExpression initialValueClassNode realTypeFieldNode paramFieldExpression fieldExpmakeReference(...)VariableExpression outerVariableExpression thisObjectTupleExpression conArgsgetNextClosureInnerName(...)InnerClassNode icn;this.icnnew CorrectAccessedVariableVisitor(...)/* this method is called for local variables shared between scopes. ... */ClassNode callNodeString descriptornew LinkedList<BytecodeVariable>(...)Parameter[] retIterator<Variable> iterVariable element// generate closure as public class to make sure it can be properly invoked by classes of the// Groovy runtime without circumventing JVM access checks (see CachedMethod for example).// now let's load the various parameters we're passing// we start at index 2 because the first variable we pass// is the owner instance and at this point it is already// on the stack// we may need to pass in some other constructors//cv.visitMethodInsn(INVOKESPECIAL, innerClassinternalName, "<init>", prototype + ")V");// compileStack.containsVariable(name) means to ask if the variable is already declared// compileStack.getScope().isReferencedClassVariable(name) means to ask if the variable is a field// If it is no field and is not yet declared, then it is either a closure shared variable or// an already declared variable.// variable is not on stack because we are// inside a nested Closure and this variable// was not used before// then load it from the Closure field// let's create a default 'it' parameter// GROOVY-9971: closure return type is mapped to Groovy cast by classgen// not STC or unknown path// let's add a typesafe call method// let's make the constructor// let's assign all the parameter fields from the outer context// let's add a getter & setter// this block does not get a source position, because we don't// want this synthetic constructor to show up in corbertura reports// only overwrite if we find something more specific//TODO: replace with normal String, p not needed/** This class will delegate all calls to a WriterController given in the constructor. */WriterController delegationController;this.delegationControllerisFastPath(...)getCv(...)switchToFastPath(...)switchToSlowPath(...)/** Helper class that takes an Expression and if visited will load it normally, ... */Expression exp;this.expnew HashMap<String,Label>(...)/** returns the index of the bytecode variable */// first visit// visit expression// make copy & set type// store copy in temporary variable// since the calling code will push the type again, we better remove it hereimport ShortTypeHandlingimport TreeMapimport static ExpressionUtils.isThisExpressionimport static ClassHelper.isFunctionalInterfaceimport static StaticTypeCheckingSupport.isClassClassNodeWrappingConcreteTypeShortTypeHandling.classMethodCallerMultiAdapter invokeMethodOnCurrent;// method invocationMethodCallerMultiAdapter invokeMethodOnSuper;MethodCallerMultiAdapter invokeMethod;MethodCallerMultiAdapter invokeStaticMethod;MethodCaller invokeClosureMethod;MethodCaller castToVargsArray;MethodNode CLASS_FOR_NAME_STRING;MethodCaller asTypeMethod;MethodCaller castToTypeMethod;MethodCaller castToClassMethod;MethodCaller castToStringMethod;MethodCaller castToEnumMethod;MethodCaller selectConstructorAndTransformArguments;// constructor calls with this() and super()new LinkedList<BlockRecorder>(...)ClassNode sendermakeDirectCall(...)makeCachedCall(...)makeUncachedCall(...)ClassNode enclosingClassClassNode receiverTypeint startDepthint opcodeClassNode ownerClassisClassClassNodeWrappingConcreteType(...)isThis(...)loadArguments(...)/** Supplements {@link org.apache.groovy.ast.tools.ExpressionUtils#isThisExpression isThisExpression} ... */boolean[] isThisnew GroovyCodeVisitorAdapter(...) { ... }InvocationWriter$1int nthParameterClassNode lastTypeint stackLenboolean vargList<Expression> lastArgsmakeClassForNameCall(...)controller.optimizeForIntOptimizingStatementWriter.StatementMetaStatementMeta metaOptimizingStatementWriter.StatementMeta.classmeta.targetnew LinkedList<Boolean>(...)writeDirectMethodCall(...)int operandsToRemoveAsmClassGenerator.setPropertygetSuperMethodNames(...)/** if Class.forName(x) is recognized, make a direct method call */CastExpression msgExpression methodExprisClosureCall(...)invokeClosure(...)Expression messageNameisFunctionInterfaceCall(...)transformToRealMethodCall(...)new LinkedList<ExceptionTableEntry>(...)isStaticInvocation(...)isFunctionalInterface(...)new ExpressionTransformer(...) { ... }hasPossibleMethod(...)InvocationWriter.invokeStaticMethodString ownerDescriptorprepareConstructorCall(...)finnishConstructorCall(...)String ownerCallSiteWriter.CONSTRUCTORwriteDirectConstructorCall(...)writeAICCall(...)writeNormalConstructorCall(...)loadVariableWithReference(...)boolean clear;/** state flag */// TODO: remove optimization of this.foo -> this.@foopushInSpecialConstructorCall(...)/** current scope */Label continueLabel;addGeneratedClosureConstructorCall(...)/** current label for continue */Label breakLabel;/** current label for break */Map<String,BytecodeVariable> stackVariables;/** available variables on stack */int currentVariableIndex;/** index of the last variable on stack */int nextVariableIndex;sortConstructors(...)/** index for the next variable on stack */Deque<BytecodeVariable> temporaryVariables;/** currently temporary variables in use */Deque<BytecodeVariable> usedVariables;/** overall used variables for a method/constructor */Map<String,Label> superBlockNamedLabels;makeDirectConstructorCall(...)makeMOPBasedConstructorCall(...)/** map containing named labels of parenting blocks */Map<String,Label> currentBlockNamedLabels;/** map containing named labels of current block */LinkedList<BlockRecorder> finallyBlocks;/** list containing finally blocks ... */List<BlockRecorder> visitedBlocks;/** helper to handle different stack based variables */Deque<Boolean> implicitThisStack;/** handle different states for the implicit "this" */Deque<Boolean> lhsStack;/** handle different states for being on the left hand side */int localVariableOffset;/** first variable index usable after all parameters of a method */Label thisStartLabel, ...;Map<String,Label> namedLoopBreakLabel;/** goals for a "break foo" call in a loop where foo is a label. */Map<String,Label> namedLoopContinueLabel;/** goals for a "continue foo" call in a loop where foo is a label. */Deque<ExceptionTableEntry> typedExceptions;Deque<ExceptionTableEntry> untypedExceptions;boolean lhs;/** stores if on left-hand-side during compilation *//** stores if implicit or explicit this is used. */boolean inSpecialConstructorCall;Label start;Label end;new Comparator<ConstructorNode>(...) { ... }new LinkedList<LabelRange>(...)List<Expression> argumentListgetMatchingConstructor(...)TreeMap<Integer,ConstructorNode> sortedConstructorsnew TreeMap<Integer,ConstructorNode>(...)boolean isEmpty;Runnable excludedStatement;LinkedList<LabelRange> ranges;this.excludedStatementLabelRange rangenew LabelRange(...)range.startgetLast(...).endLabel start, ...;String sig;CompileStack.this.scopeCompileStack.thisCompileStack.this.continueLabelCompileStack.this.breakLabelCompileStack.this.stackVariablesCompileStack.this.currentBlockNamedLabelsCompileStack.this.finallyBlocksCompileStack.this.inSpecialConstructorCallStateStackElement elementelement.scopeelement.breakLabelelement.continueLabelelement.stackVariableselement.finallyBlockselement.inSpecialConstructorCallBytecodeVariable headLabel[] targetsint[] indicesIterator<Integer> hashItsetEndLabel(...)setEndLabels(...)/** creates a temporary variable. ... *//** Returns a normal variable. ... */BytecodeVariable.THIS_VARIABLEBytecodeVariable.SUPER_VARIABLEBytecodeVariable answerdefineVar(...)storeVar(...)Iterator<ConstructorNode> constructorIt/** Clears the state of the class. This method should be called ... */Label defaultLabelLabel afterSwitchString typeDescriptorConstructorNode sameHashNodetargets.lengthvisitLookupSwitchInsn(...)Label targetAsmClassGenerator.CREATE_DEBUG_INFOvisitLocalVariable(...)int lengthWithoutVargsgetStartLabel(...)getEndLabel(...)ExceptionTableEntry epep.startep.endep.goalep.sigloadAndCastElement(...)resetVariableIndex(...)new ExceptionTableEntry(...)/** initializes this class for a MethodNode. This method will ... */defineMethodVariables(...)// we match only on the number of arguments, not anything else/** Causes the state-stack to add an element and sets ... */ConstructorNode lastMatch/** Should be called when descending into a loop that defines ... *//** Converts sourceType to a non primitive by using Groovy casting. ... */ClassNode boxedTypeinitLoopLabels(...)String labelName/** Should be called when descending into a loop that does ... */// GROOVY-6045, GROOVY-8693, et al.// direct invocation path// call site or indy path// ScriptBytecodeAdapter path// handle receiver// outer class method invocation// GROOVY-8693, GROOVY-9909// avoid using a narrowed type if the method is defined on Object, because it can interfere// with delegate type inference in static compilation mode and trigger a ClassCastException// use actual for typical call// GROOVY-6962, GROOVY-9955, GROOVY-10380: method declared by inaccessible class or interface// replace the method call's receiver and argument types with the return type// null is an array argument for variadic parameter// last arguments wrapped in an array// adjust stack length// optimization path// prepare call site// sender only for call sites// for MOP method// message// arguments// are we a local variable?/** Used for <code>break foo</code> inside a loop to end the ... */// it should not be an explicitly "this" qualified method call// and the current class should have a possible method// if a this appears as parameter here, then it should be// not static, unless we are in a static method. But since// ACG#visitVariableExpression does the opposite for this case, we// push here an explicit this. This should not have any negative effectgetBreakLabel(...)// sine visiting a method call or property with implicit this will push// a new value for this again.// sort in a new list to prevent side effects// keep Object[] on stack// to select the constructor we need also the number of// available constructors and the class we want to make// the call on// removes one Object[] leaves the int containing the// call flags and the constructor number//load "this"// create switch targets// to keep the stack height, we need to leave// one Object[] on the stack as last element. At the// same time, we need the Object[] on top of the stack// to extract the parameters.// in this case we need one "this", so a SWAP will exchange// "this" and Object[], a DUP_X1 will then copy the Object[]/// to the last place in the stack://     Object[],this -SWAP-> this,Object[]//     this,Object[] -DUP_X1-> Object[],this,Object[]// in this case we need two "this" in between and the Object[]// at the bottom of the stack as well as on top for our invokeSpecial// So we do DUP_X1, DUP2_X1, POP/** Used for <code>continue foo</code> inside a loop to continue ... *///     Object[],this -DUP_X1-> this,Object[],this//     this,Object[],this -DUP2_X1-> Object[],this,this,Object[],this//     Object[],this,this,Object[],this -POP->  Object[],this,this,Object[]// unwrap the Object[] and make transformations if needed// that means, to duplicate the Object[], make a cast with possible// unboxing and then swap it with the Object[] for each parameter// vargs need special attention and transformation though// at the end we remove the Object[]// the vargs case simply the last swap so no pop is needed// make the constructor call// this part should never be reached!// For a special constructor call inside a constructor we don't need// any result object on the stack, for outside the constructor we do.// to keep the stack height for the able we kept one object as dummygetLabel(...)// result on the stack, which we can remove now if inside a constructor.// in case we are not in a constructor we have an additional// object on the stack, the result of our constructor call// which we want to keep, so we swap with the dummy object and// do normal removal of it. In the end, the call result will be// on the stack then// for call result// if number of parameters does not match we have no match// we already had a match so we don't make a direct call at all/** Creates a new break label and a element for the state stack ... *//** because a boolean Expression may not be evaluated completely ... */int prevCurrentmakeNextVariableID(...)Label startLabelmakeLocalVariablesOffset(...)boolean useExistingReferencesetStartLabel(...)Label newStartimport ClassGeneratorException/** A helper class to invoke methods more easily in ASM */createReference(...)int opcode;String internalName;String methodDescriptor;int parameterCount;int ANY_PARAMETER_COUNT;new MethodCaller(...)this.internalNamethis.parameterCount/** Defines a new Variable using an AST variable. ... */BytecodeVariable beforepushInitValue(...)/** Calculates the index of the next free register stores it ... *//** Returns the label for the given name */Label lcreateLocalLabel(...)/** creates a new named label */new ClassGeneratorException(...)StateStackElement resultCollection<BlockRecorder> blockRecordersIterator<StateStackElement> iterelement.currentBlockNamedLabelsresult.finallyBlocksapplyBlockRecorder(...)Label startBlockRecorder recordercloseRange(...)recorder.excludedStatementstartRange(...)...[] methods;boolean skipSpreadSafeAndSafe;int MAX_ARGS;MethodCallerMultiAdapter mcmanew MethodCallerMultiAdapter(...)mcma.skipSpreadSafeAndSafeint numberOfBaseMethodsnumberOfBaseMethods(...)mcma.methodsnew MethodCaller[]block.isEmptyblock.rangesrange.endthis.lhs/** Generates bytecode for method pointer expressions. ... */MethodCaller getMethodPointer;pushDynamicName(...)// delegate to ScriptBytecodeAdapter#getMethodPointer/** Generates bytecode for method reference expressions. ... */import static Collectors.toSetimport static Opcodes.ACC_BRIDGEnew Factory(...) { ... }new MopWriter(...)Factory FACTORY;...[] params;this.paramsMopKey otherother.nameother.paramsvisitMopMethodList(...)getSuperMethods(...)new Function<MethodNode,MopKey>(...) { ... }new MopKey(...)/** Filters a list of method for MOP methods. For all methods that are not ... */LinkedList<MethodNode> listnew LinkedList<MethodNode>(...)Map<MopKey,MethodNode> mapnew HashMap<MopKey,MethodNode>(...)// TRICK: we add at the beginning so when we find for remove or get we always have the last one// exception table writing// this code is in an extra method to avoid// lazy initialization issues// GROOVY-4237: the original variable should always appear// in the variable index, otherwise some programs get into// trouble; so define a dummy variable for the packaging// phase and let it end right away before the normal// reference will be used//GROOVY-10303// first find the state defining the label. That is the state// directly after the state not knowing this label. If no state// in the list knows that label, then the defining state is the// current state.// we exclude the finally block from the exception table// here to avoid double visiting of finally statementsgetMopMethodName(...)generateMopCalls(...)/** Generates a Meta Object Protocol method that is used to call a non-public ... */String mopNameint stackIndexClassNode declaringTypeimport static Opcodes.D2Fimport static Opcodes.D2Iimport static Opcodes.D2Limport static Opcodes.DUP2_X2import static Opcodes.DUP_X2import static Opcodes.F2Dimport static Opcodes.F2Iimport static Opcodes.F2Limport static Opcodes.FCONST_2import static Opcodes.I2Bimport static Opcodes.I2Cimport static Opcodes.I2Dimport static Opcodes.I2Fimport static Opcodes.I2Limport static Opcodes.I2Simport static Opcodes.L2Dimport static Opcodes.L2Fimport static Opcodes.L2I/** Creates a MOP method name from a method. ... *//** Determines if a method is a MOP method. This is done by the method name. ... *//* GROOVY-8693, et al. */// mop methods are helper for this and super calls and do direct calls// to the target methods; such a method cannot be abstract or a bridge// no this$ methods for non-private isThis=true// super$ method for non-private isThis=false// --> results in XOR// load "this" and the parameters// long and double use two slots// make call to this or super method with operands// GROOVY-8693, GROOVY-9909, et al.: method from interface not implemented by super class// declared!// only direct default methods!// GROOVY-8693: fixed distance for interface methodsimport static ClassHelper.BigDecimal_TYPEimport static ClassHelper.GROOVY_INTERCEPTABLE_TYPEimport static WideningCategories.isFloatingCategoryimport static BinaryExpressionMultiTypeDispatcher.typeMapimport static BinaryExpressionMultiTypeDispatcher.typeMapKeyNamesMethodCaller disabledStandardMetaClass;...[] guards;// values correspond to BinaryExpressionMultiTypeDispatcher.typeMapKeyNamesboolean fastPathBlocked;List<ClassNode> stack;ClassNode elementpopWithMessage(...)isTwoSlotType(...)FastPathData fastPathDatanew FastPathData(...)Label slowPathIndexOutOfBoundsException emeta.optimizeguards.lengthmeta.involvedTypes/** returns true for long and double */Verifier.STATIC_METACLASS_BOOL/** ensure last marked parameter on the stack is a primitive boolean ... */fastPathData.pathStartmeta.afterPathmeta.pathStartClassNode lastconvertPrimitiveToBoolean(...)castNonPrimitiveToBool(...)StatementMeta.classwriteGuards(...)boolean oldFastPathBlock/** remove operand stack top element using bytecode pop */popDownTo(...)writeFastPathPrelude(...)writeFastPathEpilogue(...)/** duplicate top element */writeIteratorHasNext(...)writeIteratorNext(...)ClassNode wrapperwriteForInLoop(...)doCastToWrappedType(...)/** Remove amount elements from the operand stack, without using pop. ... */writeForLoopWithClosureList(...)/** push operand on stack *//** swap two top level operands */ClassNode bClassNode a/** replace top level element with new element of given type */ensureStackNotEmpty(...)new ArrayIndexOutOfBoundsException(...)ArrayIndexOutOfBoundsException ai/** replace n top level elements with new element of given type */isNewPathFork(...)writeDeclarationExtraction(...)/** do Groovy cast for top level element */meta.declaredVariableExpressiondoConvertAndCast(...)ClassNode topboolean primTargetboolean primTopthrowExceptionForNoStackElement(...)coerce(...)convertPrimitive(...)castToNonPrimitiveIfNecessary(...)doCastToPrimitive(...)int convertCodeconvertFromInt(...)convertFromFloat(...)convertFromDouble(...)convertFromLong(...)/** load the constant on the operand stack. */boolean boxingboolean primitivebooleanValue(...)pushPrimitiveConstant(...)boolean isIntboolean isShortboolean isByteboolean isCharint valboolean bstore(...)//GROOVY-10458// no element, so use emptyDefault// nothing to do in that case// remove the boolean from the operand stack tracker// else nothing to box//        dup_x1:     ---//        dup_x2:     aab  -> baab//        dup2_x1:    abb  -> bbabb//        dup2_x2:    aabb -> bbaabb//        b = top element, a = element under b//        top element at right// aa// aabb// aabb -> bbaa// bbaabb// bbaa// aab -> baa// baab// baa// a//abbDeclarationExpression declaration// abb -> bba// bbabb// bba// ab -> ba/* for better performance */// here we box and unbox to get the goal typeBinaryExpression assignment// top is not primitive so unbox// leave that BH#doCast later// top might be primitive, target is not// so let invocation writer box if needed and do groovy cast otherwise// load static value// GROOVY-9797: Use Float.equals to differentiate between positive and negative zero// GROOVY-9797: Use Double.equals to differentiate between positive and negative zero// value is on stack// remove RHS value from operand stackReturnStatement rsnew OptVisitor(...)new Function<Object,StatementMeta>(...) { ... }new StatementMeta(...)addMeta(...)chainInvolvedTypes(...)Label pathStart;Label afterPath;typeMapKeyNames.lengthboolean optimize;VariableExpression declaredVariableExpression;...[] involvedTypes;opt.current.involvedTypesopt.currentthis.involvedTypesnew OptimizeFlagsEntry(...)new LinkedList<OptimizeFlagsEntry>(...)boolean canOptimize;boolean shouldOptimize;OptimizeFlagsEntry current;Deque<OptimizeFlagsEntry> previous;OptimizeFlagsEntry oldchainCanOptimize(...)old.canOptimizechainShouldOptimize(...)old.shouldOptimizecurrent.involvedTypesold.involvedTypescurrent.shouldOptimizecurrent.canOptimize/** set "should" to true, if not already */shouldOptimize(...)/** set "can" to true, if not already */Integer resnew OptimizeFlagsCollector(...)VariableScope nonStaticScope;OptimizeFlagsCollector opt;boolean optimizeMethodCall;TypeChooser typeChooser;ClassNode node;this.typeChooserthis.optimizeMethodCallboolean optAllcanOptimize(...)ClassNode resultType/** A {@link TypeChooser} which is aware of statement metadata. */Types.COMPARE_LESS_THAN_EQUALTypes.COMPARE_GREATER_THANClassNode classTypeTypes.LOGICAL_AND_EQUALTypes.LOGICAL_OR_EQUALmeta.typeVariableExpression vexpTypes.DIVIDETypes.DIVIDE_EQUALTypes.POWERTypes.POWER_EQUALoptimizeDivWithIntOrLongTarget(...)addMeta(...).typechainInvolvedType(...)import BlockRecorderimport static GeneralUtils.*import static Opcodes.*newInterface(...)MethodCaller iteratorHasNextMethod;MethodCaller iteratorNextMethod;addTypeInformation(...)/** Optimizes "Z = X/Y" with Z being int or long style. ... */ClassNode originalResultTypeClassNode targetisFloatingCategory(...)Parameter[] paraTypesMethodNode targetvalidTypeForCall(...)selectConstructor(...)List<ConstructorNode> ctors// meta class check with boolean holder// standard metaclass check// other guards here// normal mode with different paths// important is to not to have a fastpathblock here,// otherwise the per expression statement improvement// is impossible// fast/slow path generation// declaration was replaced by assignment so we need to define the variable// we have to have handle DelcarationExpressions special, since their// entry should be outside the optimization path, we have to do that of// course only if we are actually going to do two different paths,// otherwise it is not needed// there are several cases to be considered now.// (1) no fast path possible, so just do super// (2) fast path possible, and at path split point (meaning not in//     fast path and not in slow path). Here we have to extract the//     Declaration and replace by an assignment// (3) fast path possible and in slow or fastPath. Nothing to do here.// the only case we need to handle is then (2).// stash declared variable in case we do subsequent visits after we// change to assignment only// change statement to do assignment only// replace statement code// meta.optimize -> can do fast path// fastPathBlocked -> slow path// controller.isFastPath() -> fastPath// no optimization for BigDecimal yet//resultType = BigDecimal_TYPE;// TODO: implement// TODO: implement int operations for this// we cannot set a target for the constructor call, since we cannot easily check the meta class of the other class//setMethodTarget(call, "<init>", call.getArguments(), false);// if right is a constant, then we optimize only if it makes a block complete, so we set a maybe// find method call target// do call only for final classes and primitive typesnew Function<String,Label>(...) { ... }new Consumer<Label>(...) { ... }/** Interface for modules which are capable of resolving the type of an expression. ... *//** Resolve the type of an expression. Depending on the implementations, the ... */writeStatementLabel(...)Expression iteratorpushLoop(...)ClassHelper.Iterator_TYPEwriteForInLoopControlAndBlock(...)int iteratorLabel breakLabelLabel continueLabelgetContinueLabel(...)/** A helper class used to generate bytecode for unary expressions. AST transformations willing to use ... */MethodCaller unaryPlus;// unary plus, unary minus, bitwise negationMethodCaller unaryMinus;MethodCaller bitwiseNegate;ClosureListExpression clExprnegateBoolean(...)int condIndexLabel condvisitExpressionOfLoopStatement(...)Expression condExprConsumer<Expression> visitOperandStack operandStack;this.operandStackboolean boolHandledConstantExpression constantvisitConditionOfLoopingStatement(...)import IndyBinHelperimport IndyCallSiteWriterimport InvokeDynamicWriterimport LoggableClassVisitorimport static ClassHelper.isGeneratedFunctionBlockRecorder tryBlockmakeBlockRecorder(...)Label finallyStartboolean fallthroughFinallyBlockRecorder catchesLabel catchAllLabel afterCatchAllint anyThrowableLabel catchBlockAsmClassGenerator acg;MethodVisitor methodVisitor;CompileStack compileStack;CallSiteWriter callSiteWriter;ClosureWriter closureWriter;LambdaWriter lambdaWriter;InvocationWriter invocationWriter;BinaryExpressionHelper binaryExpHelper, ...;UnaryExpressionHelper unaryExpressionHelper, ...;AssertionWriter assertionWriter;ClassNode outermostClass;ConstructorNode constructorNode;InterfaceHelperClassNode interfaceClassLoadingClass;boolean optimizeForInt;StatementWriter statementWriter;boolean fastPath;int bytecodeVersion;int helperMethodIndex;List<String> superMethodNames;MethodPointerExpressionWriter methodPointerExpressionWriter;MethodReferenceExpressionWriter methodReferenceExpressionWriter;Map<String,Boolean> optOptionsboolean invokedynamicthis.optimizeForIntisIndyEnabled(...)this.outermostClassthis.bytecodeVersionthis.invocationWriternew InvokeDynamicWriter(...)this.callSiteWriternew IndyCallSiteWriter(...)this.binaryExpHelpernew IndyBinHelper(...)new CallSiteWriter(...)new InvocationWriter(...)new BinaryExpressionHelper(...)this.fastPathBinaryExpHelperthis.fastPathUnaryExpressionHelpernew OperandStack(...)this.assertionWriternew AssertionWriter(...)this.closureWriternew ClosureWriter(...)this.lambdaWriternew LambdaWriter(...)this.methodPointerExpressionWriternew MethodPointerExpressionWriter(...)this.methodReferenceExpressionWriternew MethodReferenceExpressionWriter(...)this.acgthis.compileStacknew CompileStack(...)createClassVisitor(...)this.statementWriternew OptimizingStatementWriter(...)new StatementWriter(...)new StatementMetaTypeChooser(...)isLogClassgen(...)new LoggableClassVisitor(...)this.methodVisitorthis.constructorNodeClassNode thisTypeList<ClassNode> outerswriteExceptionTable(...)new BlockRecorder(...)new Runnable(...) { ... }// set other optimizations options to false herepushBlockRecorderVisit(...)// TODO: replace with a real fast path unary expression helper when availablepopBlockRecorderVisit(...)pushBlockRecorder(...)pushSwitch(...)int switchVariableIndexint caseCountIterator<CaseStatement> iterwriteCaseStatement(...)getIsCaseMethod(...)/** A non static factory to get alternative writer controller to be stored in the meta data */getNamedBreakLabel(...)applyFinallyBlocks(...)getNamedContinueLabel(...)Label synchronizedStartLabel synchronizedEndRunnable finallyPartBlockRecorder fbwriteAssertStatement(...)ClassNode rTypeisReturningNullOrVoid(...)hasBlockRecorder(...)int returnVal// then get the iterator and generate the loop control// declare the loop counter// get the iterator and generate the loop control// jump if zero (aka false)// generate the loop body// middle element is condition, lower half is init, higher half is increment// visit init// visit condition leave boolean on stack// jump if we don't want to continue// note: ifeq tests for ==0, a boolean is 0 if it is false// Generate the loop body// visit increment// fix for being on the wrong line when debugging for loop// jump to test the condition again// loop end// skip past catch block(s)// pop for BlockRecorder// create variable for the exception// TODO: Is it okay that "catch (e)" makes variable type Object?// handle catch body// placeholder to avoid problems with empty catch block// pop for the variable// end of catch// used to handle exceptions in catches and regularly visited finals// add "catch all" block to exception table for try part; we do this// after the exception blocks so they are not superseded by this one// same for the catch parts// skip over the catch-finally-rethrow// load the throwable and rethrow it// switch does not have a continue label. use its parent's for continue// now if we don't finish with a break we need to jump past the next comparison// place holder for "empty" synchronized blocks, for example// if there is only a break/continue.//pop fb// we should infer the type of the exception from the expression// TODO: move to Verifier// GROOVY-10617import BinaryExpressionHelperimport InvocationWriterimport CompileStackimport IndyInterfaceimport Handleimport static ClassHelper.isWrapperBooleanimport static BytecodeHelper.doCastimport static BytecodeHelper.getTypeDescriptionimport static IndyInterface.GROOVY_OBJECTimport static IndyInterface.IMPLICIT_THISimport static IndyInterface.SAFE_NAVIGATIONimport static IndyInterface.SPREAD_CALLimport static IndyInterface.THIS_CALLimport static CallType.CASTimport static CallType.GETimport static CallType.INITimport static CallType.METHODimport static Opcodes.H_INVOKESTATIC/** This Writer is used to generate the call invocation byte codes ... */toMethodDescriptorString(...)CallSite.classLookup.classMethodType.classnew Handle(...)IndyInterface.classString BSM_DESCRIPTOR;Handle BSM;...[] CAST_ARGS;makeIndyCall(...)visitInvokeDynamicInsn(...)StringBuilder sigprepareIndyCall(...)String callSiteNamegetCallSiteName(...)int flagsgetMethodCallFlags(...)Wrapper.classfinishIndyCall(...)import CallSiteWriter/** Dummy class used by the indy implementation. ... */getPropertyFlags(...)isWrapperBoolean(...)writeIndyCast(...)InvokeDynamicWriter idwwriteGetProperty(...)// fixed number of arguments && name is a real String and no GString// load normal receiver as first argument// load arguments// cast converts top operand from source to target typeimport BinaryExpressionWriterimport StaticTypesBinaryExpressionMultiTypeDispatcher/** Multi type dispatcher for binary expression backend combining indy and static compilation ... */String INDY_INTERFACE_NAME;String BSM_METHOD_TYPE_DESCRIPTOR;String name, ...;BinaryExpressionWriter[] bewArraysetArraySetAndGet(...)new GenericArrayAccess(...)import static ClassHelper.getUnwrapperimport static StaticTypesMarker.INFERRED_FUNCTIONAL_INTERFACE_TYPEimport static StaticTypesMarker.PARAMETER_TYPE/** Represents functional interface writer which contains some common methods to complete generating bytecode ... */String ORIGINAL_PARAMETERS_WITH_EXACT_TYPE;import StaticTypesMarker/** A MOP Writer that skips the generation of MOP methods. This writer is used ... */new StaticCompilationMopWriter(...)MopWriter.Factory FACTORY;StaticTypesWriterController controller;LinkedList<MethodNode> requiredMopMethodsStaticTypesMarker.SUPER_MOP_METHOD_REQUIREDimport ExpressionAsVariableSlotimport TypeChooserimport VariableSlotLoaderimport StaticCompilationMetadataKeysimport StaticCompilationVisitorimport TemporaryVariableExpressionimport ExtensionMethodNodeimport StaticTypeCheckingVisitorimport static ClassNodeUtils.samePackageNameimport static ExpressionUtils.isThisOrSuperimport static ClassHelper.isGStringTypeimport static Traits.isTraitClassNode INVOKERHELPER_CLASSNODE;MethodNode INVOKERHELPER_INVOKEMETHOD;MethodNode INVOKERHELPER_INVOKESTATICMETHOD;AtomicInteger labelCounter;MethodCallExpression currentCall;MethodCallExpression oldStaticTypesMarker.DIRECT_METHOD_CALL_TARGETint beforeMethodNode bridgeStaticTypesMarker.PV_METHODS_ACCESSMap<MethodNode,MethodNode> bridgeMethodsStaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODSnew Function<Parameter,Class<>>(...) { ... }new IntFunction<Class<>[]>(...) { ... }Opcodes.H_INVOKESTATICArgumentListExpression newArgsboolean isParameterTypePrimitiveboolean isInferredTypePrimitive/** Attempts to make a direct method call on a bridge method, if it exists. */tryBridgeMethod(...)ClassNode lookupClassNodeMap<MethodNode,MethodNode> bridgesExpression fixedReceiverboolean fixedImplicitThisExtensionMethodNode emn// H_INVOKESTATIC or H_INVOKEVIRTUAL or H_INVOKEINTERFACE (GROOVY-9853)// (1)// (2)getExtensionMethodNode(...)// GROOVY-9790: bootstrap method initialization exception raised when lambda parameter type is wrong// (1) java.lang.invoke.LambdaConversionException: Type mismatch for instantiated parameter 0: class java.lang.Integer is not a subtype of int// (2) java.lang.BootstrapMethodError: bootstrap method initialization exception// The non-primitive type and primitive type are not allowed to mix since Java 9+// java.lang.invoke.LambdaConversionException: Type mismatch for instantiated parameter 0: int is not a subtype of class java.lang.Object// java.lang.invoke.LambdaConversionException: Type mismatch for instantiated parameter 0: class java.lang.Integer is not a subtype of intimport ListOfExpressionsExpression/** Facilitates the generation of statically-compiled bytecode for property access. ... */TemporaryVariableExpression tmpnew TemporaryVariableExpression(...)PoppingMethodCallExpression callnew PoppingMethodCallExpression(...)PoppingListOfExpressionsExpression listnew PoppingListOfExpressionsExpression(...)TemporaryVariableExpression tmp;PoppingMethodCallExpression call;this.tmpthis.callcall.tmp// ignore the return of the callisStaticExtension(...)StaticTypeCheckingVisitor.CLOSURE_CALL_VARGSExpression arrimport BinaryExpressionMultiTypeDispatcherimport TokenUtilimport static GeneralUtils.declXimport static StaticCompilationMetadataKeys.PRIVATE_FIELDS_MUTATORSimport static StaticCompilationVisitor.ARRAYLIST_ADD_METHODimport static StaticCompilationVisitor.ARRAYLIST_CLASSNODEimport static StaticCompilationVisitor.ARRAYLIST_CONSTRUCTORimport static StaticTypeCheckingSupport.isAssignmentimport static StaticTypesMarker.DIRECT_METHOD_CALL_TARGETimport static StaticTypesMarker.INFERRED_TYPEtryPrivateMethod(...)/** A specialized version of the multi type binary expression dispatcher which is aware of static compilation. ... */MethodNode CLOSURE_GETTHISOBJECT_METHOD;samePackageName(...)visitInsnByType(...)new CheckcastReceiverExpression(...)BinaryExpression expressionWithoutAssignmentisPrivateBridgeMethodsCallAllowed(...)checkAndAddCannotCallPrivateMethodError(...)makeSetProperty(...)int nPrmstransformSpreadOnLHS(...)PropertyExpression spreadExpressionint counterClassNode lastArgTypeClassNode lastPrmTypeisGStringType(...)boolean spreadvisitArgument(...)Expression[] argumentsExpression aisCompatibleArgumentType(...)getCurrentCall(...)ConstructorCallExpression newArrayListExpression declLabel ifnullLabel nonullParameter iteratorVariableExpression iteratorAsVarMethodCallExpression addForStatement stmtboolean isThisExpressionString setterMethodNode setterMethodExpression calltransformToSetterCall(...)makeSetPrivateFieldWithBridgeMethod(...)Expression pexpMap<String,MethodNode> mutatorsnew Function<Parameter,String>(...) { ... }Expression initialExpressionStaticTypesMarker.INITIAL_EXPRESSIONStaticTypesMarker.PARAMETER_TYPEStaticTypesMarker.DYNAMIC_RESOLUTIONStaticTypesWriterController staticControllerInvocationWriter dynamicInvocationWritergetRegularInvocationWriter(...)tryImplicitReceiver(...)Expression tmpReceiverStaticCompilationVisitor.ARRAYLIST_CLASSNODETemporaryVariableExpression resultMethodCallExpression origMCEint heightMethodCallExpression newMCEnew StaticCompilationVisitor(...)StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR// GROOVY-5620: spread-safe operator on LHS is not supported// rewrite it so that it can be statically compiled// create an empty arraylist// if (receiver != null)// receiver consumed by if()// for (e in receiver) { result.add(e?.method(arguments) }// else { empty list }// end of if/else// return result list// check that direct access is allowed// this.x = ... shouldn't use a setter if in the same class// to be replaced with a proper test whether a return value should be used or not/* This code path is needed because ACG creates array access expressions */// GROOVY-6061// GROOVY-9771// replace assignment to a subscript operator with a method call// e.g. x[5] = 10 -> methodCall(x, "putAt", [5, 10])StaticCompilationVisitor.ARRAYLIST_ADD_METHODExpressionAsVariableSlot slotLabel endofimport static ClassHelper.CLASS_Typeimport static ClassHelper.GROOVY_OBJECT_TYPEimport static ClassHelper.Iterator_TYPEimport static ClassHelper.LIST_TYPEimport static ClassHelper.MAP_TYPEimport static ClassHelper.isWrapperIntegerimport static ClassHelper.isWrapperLongimport static StaticTypeCheckingSupport.chooseBestMethodimport static StaticTypeCheckingSupport.findDGMMethodsByNameAndArgumentsimport static Opcodes.ARRAYLENGTHAsmClassGenerator.getFieldAsmClassGenerator.getGroovyObjectFieldCallSiteWriter callSiteWritermakeGetField(...)/** A call site writer which replaces call site caching with static calls. This means that the generated code ... */Object implicitReceiverStaticTypesMarker.IMPLICIT_RECEIVERString[] pathpath.lengthStaticTypesMarker.INFERRED_TYPEPropertyExpression rewrittenExpression receiver;ClassNode INVOKERHELPER_TYPE;this.receiverMethodNode COLLECTION_SIZE_METHOD;MethodNode MAP_GET_METHOD;MethodNode GROOVYOBJECT_GETPROPERTY_METHOD;MethodNode INVOKERHELPER_GETPROPERTY_METHOD;MethodNode INVOKERHELPER_GETPROPERTYSAFE_METHOD;CallSiteWriter regularCallSiteWriterClassNode topOperandgetRegularCallSiteWriter(...)hasCallSiteUse(...)Object dynamicStaticCompilationMetadataKeys.RECEIVER_OF_DYNAMIC_PROPERTYboolean[] isClassReceivergetPropertyOwnerType(...)boolean isStaticPropertyString isserNameInnerClassNode.classfindDGMMethodsByNameAndArguments(...)DecompiledClassNode.classmakeDynamicGetProperty(...)ClassNode arrayGetReturnType// load "this"// on a special call, there's no object on stack// adjust for multiple levels of nesting if neededMethodCallExpression expr// wrap arguments into an array// replace call with an invoker helper call// GROOVY-7242// account for multiple levels of inner types// in order to avoid calls to castToType, which is the dynamic behaviour, we make sure that we call CHECKCAST instead then replace the top operand type// target is variadic and args are too many or one short or just enough with array compatibility// first arguments/parameters as usual// wrap remaining arguments in an array for last parameter// GROOVY-10597// adjust operand stack// call with default argumentsmakeGetPropertyWithGetter(...)// default argument// if call is spread safe, replace it with a for in loop// receiver expressions with side effects should not be visited twice, avoid by using a temporary variable// use a temporary variable for the arraylist in which the results of the spread call will be stored// cleanup temporary variables// wrap call in an IFNULL check// else { null }// GROOVY-6021// perform regular type conversion// ex: LUB type// checkcast not necessary because Object never evolves// and it prevents a potential ClassCastException if the// delegate of a closure is changed in a SC closure// can happen for compiler rewritten code, where type information is missingwriteMapDotProperty(...)makeGetPrivateFieldWithBridgeMethod(...)import ClosureWriter/** Writer responsible for generating closure classes in statically compiled mode. */List<MethodNode> doCallMethodNode doCallMethodMethodTargetCompletionVisitor visitornew MethodTargetCompletionVisitor(...)createDirectCallMethod(...)List<MethodNode> methodNodeschooseBestMethod(...)StaticCompilationMetadataKeys.STATIC_COMPILE_NODEParameter doCallParamParameter argsaddGeneratedCallMethod(...)defaultArgument(...)writeListDotProperty(...)addPropertyAccessError(...)MethodCallExpression callDoCallLabel skipMethodNode doCallMethod;this.doCallMethod// in case there is no "call" method on the closure, create a "fast invocation" pathStaticCompilationMetadataKeys.COMPONENT_TYPE// to avoid going through ClosureMetaClass by call(Object...) method// we can't have a specialized version of call(Object...) because the dispatch logic// in ClosureMetaClass is too complex!// call(Object)// call()Label exitVariable tmpListArrayList<>.classint varVariable iteratorint itVariable nextVarint nextLabel l4Label l5import AstStringCompilerimport BytecodeInstructionimport BytecodeSequenceimport LambdaWriterimport static ClassHelper.GENERATED_LAMBDA_TYPEimport static ClassHelper.SERIALIZABLE_TYPELabel doGetimport static ClassHelper.SERIALIZEDLAMBDA_TYPEimport static ClassHelper.findSAMimport static ClosureUtils.getParametersSafeimport static Opcodes.H_INVOKEVIRTUAL/** Writer responsible for generating lambda classes in statically compiled mode. */Map<String,MethodNode> accessorsStaticCompilationMetadataKeys.PRIVATE_FIELDS_ACCESSORSboolean isScriptVariableExpression currentCallString implicitReceiverString[] pathElementsBytecodeExpression thisLoaderString IS_GENERATED_CONSTRUCTOR;String LAMBDA_SHARED_VARIABLES;StaticTypesClosureWriter staticTypesClosureWriter;Map<Expression,ClassNode> lambdaClassNodes;this.staticTypesClosureWriternew StaticTypesClosureWriter(...)ClassNode functionalInterfacepathElements.lengthgetFunctionalInterfaceType(...)ClassNode lambdaClassgetOrAddLambdaClass(...)MethodNode lambdaMethodMethodNode getterNodeboolean canDeserializecreateDeserializeLambdaMethodName(...)createDeserializeLambdaMethodParams(...)isSerializable(...)setSerializable(...)addDeserializeLambdaMethodForEachLambdaExpression(...)addDeserializeLambdaMethod(...)newGroovyLambdaWrapperAndLoad(...)isAccessingInstanceMembersOfEnclosingClass(...)createAbstractMethodDesc(...)createBootstrapMethod(...)createBootstrapMethodArguments(...)createMethodDescriptor(...)boolean[] resultStaticTypesLambdaWriter$1StaticCompilationMetadataKeys.PROPERTY_OWNERtrySubscript(...)String lambdaClassInternalNameOptional<ConstructorNode> generatedConstructorwriteNumberNumberCall(...)writePowerCall(...)writeOperatorCall(...)writeStringPlusCall(...)writeArrayGet(...)MethodNode getAtNodeClassNode[] argsboolean acceptAnyMethodList<MethodNode> nodesgetCompatibleMethod(...)Parameter[] lambdaClassConstructorParametersloadSharedVariables(...)lambdaClassConstructorParameters.lengthParameter[] lambdaSharedVariableParametersUseExistingReference.classList<Parameter> lambdaSharedVariablesAsmClassGenerator.setFieldAsmClassGenerator.setGroovyObjectFieldStaticCompilationMetadataKeys.PRIVATE_FIELDS_MUTATORSVariableSlotLoader rhsValueint rhsprependParameter(...)Object inferredTypenew Function<Expression,ClassNode>(...) { ... }isClassReceiver.lengthcreateLambdaClass(...)// this is just a simple set field handling static and non-static, but not Closure and inner classesOperandStack stackClassNode outermostClassboolean staticMethodOrInStaticClassInnerClassNode lambdaClassnextLambdaClassName(...)MethodNode syntheticLambdaMethodNodeaddSyntheticLambdaMethodNode(...)Parameter[] localVariableParameters/* private boolean getField(final PropertyExpression expression, final Expression receiver, ClassNode receiverType, final String name) { ... */String receiverNameaddSerialVersionUIDField(...)// for maps, replace "map.foo" with "map.get('foo')" -- if no public field "foo" is declared (GROOVY-5001)// we are probably looking for a property of the class// GROOVY-5580: it is still possible that we're calling a superinterface property// GROOVY-5585// GROOVY-5568: we would be facing a DGM call, but instead of foo.getText(), have foo.text// push receiver on stack// check if receiver null// for lists, replace list.foo with://   def result = new ArrayList(list.size())//   for (item in list) result.add(item.foo)getNextLambdaInnerName(...)//   result// try again with "(Outer) getThisObject()" or "Outer.this" as receiver// GROOVY-9967, et al.// inner class still needs dynamic property sequence// check for an accessor method// GROOVY-5561: if two files are compiled in the same source unit and// one references the other, the getters for properties have not been// generated by the compiler yet by Verifier// GROOVY-10548// GROOVY-6277// GROOVY-7149: check direct interfaces// go upper levelParameter[] parametersWithExactType// GROOVY-7039: include interface constantscreateParametersWithExactType(...)// now try with flow type instead of declaration type// TODO: can STCV be made smarter to avoid this check?// todo: more casesgetLambdaSharedVariables(...)// check if a getAt method can be found on the receiver// make sure Map#getAt() and List#getAt handled with the bracket syntax are properly compiled// retry with raw types// fallback to Map#get// TODO this really should find "best" match or find all matches and complain about ambiguity if more than one// TODO handle getAt with more than one parameter// TODO handle default getAt methods on Java 8 interfaces// visit receiver// visit arguments as array index// array access// slow path// TODO: performance would be better if we created a StringBuilder// GROOVY-9892: assuming that the mutator method has a return value, make sure the operand// stack is not polluted with the result of the method call// store value in temporary variable// no return value// in case a "flow type" is found, it is preferred to use it instead of the declaration type// GROOVY-6590: wrap primitive typesParameter[] targetParametersgetParametersSafe(...)Parameter targetParameterClassNode inferredTypeconvertParameterType(...)import MethodReferenceExpressionWriterimport static ParameterUtils.parametersCompatibleimport static StaticTypeCheckingSupport.filterMethodsByVisibilityimport static StaticTypeCheckingSupport.findDGMMethodsForClassNodeimport static StaticTypeCheckingSupport.isAssignableTo/** Generates bytecode for method reference expressions in statically-compiled code. ... */ClassNode functionalInterfaceTypeString abstractMethodDescExpression typeOrTargetRefboolean isClassExpressionboolean targetIsArgumentClassNode typeOrTargetRefTypeClassNode[] methodReferenceParamTypesStaticTypesMarker.CLOSURE_ARGUMENTSString methodRefNameboolean isConstructorReferenceisConstructorReference(...)new AstStringCompiler(...)MethodNode methodRefMethodint referenceKindString methodDescStaticTypesLambdaWriter$2getNextConstructorReferenceSyntheticMethodName(...)addSyntheticMethodForConstructorReference(...)findMethodRefMethod(...)isExtensionMethod(...)ExtensionMethodNode extensionMethodNodeaddSyntheticMethodForDGSM(...)makeClassTarget(...)int mParameters//lambdaClass.setUsingGenerics(outermostClass.isUsingGenerics());isTypeReferringInstanceMethod(...)addSyntheticMethodForVariadicReference(...)Opcodes.H_INVOKEINTERFACEOpcodes.H_INVOKEVIRTUALHandle bootstrapMethodObject[] bootstrapArgsimport StatementWriterimport static Opcodes.BALOADimport static Opcodes.CALOADimport static Opcodes.DALOADimport static Opcodes.FALOADimport static Opcodes.IALOADimport static Opcodes.LALOADimport static Opcodes.SALOAD/** A class to write out the optimized statements. */Enumeration<>.classClassNode ENUMERATION_CLASSNODE;MethodCaller ENUMERATION_NEXT_METHOD;MethodCaller ENUMERATION_HASMORE_METHOD;Expression collectionExpressionClassNode collectionTypeParameter loopVariablewriteOptimizedForEachLoop(...)writeEnumerationBasedForEachLoop(...)writeIteratorBasedForEachLoop(...)int arrayint arrayLenint loopIdxloadFromArray(...)visitIincInsn(...)ClassNode varTypeint enumerationMethodNode iteratorparametersWithExactType.lengthClassNode firstParameterTyperemoveFirstParameter(...)MethodCallExpression methodCallMethodNode delegateMethodArgumentListExpression ctorArgsExpression returnValuenew Function<ClassNode,MethodNode>(...) { ... }ClassNode inferredParamType// identify type of collection// load array on stack// $len = array.length// $idx = 0// $idx<$len?// get array element// $idx += 1findVisibleMethods(...)// loop body// GROOVY-8487: iterator supplied// GROOVY-10476: BaseStream provides an iterator() but does not implement Iterable//GROOVY-8643ClassNode firstParamTypeParameter[] plusOneparametersCompatible(...)samParameters.lengthimport StatementMetaTypeChooser/** A {@link org.codehaus.groovy.classgen.asm.TypeChooser TypeChooser} which reads ... */ASTNode targetStaticTypesMarker.DECLARATION_INFERRED_TYPE/** The inferred type, in case of a variable expression, can be set on the ... */Object varchooseMethodRefMethodCandidate(...)// see GROOVY-9344, GROOVY-9607// AsmClassGenerator may create "this" expressions that the type checker knows nothing aboutfindDGMMethodsForClassNode(...)filterMethodsByVisibility(...)import UnaryExpressionHelperimport static Opcodes.DNEGimport static Opcodes.FNEGimport static Opcodes.INEGimport static Opcodes.LNEG/** An expression helper which generates optimized bytecode depending on the ... */BitwiseNegationExpression EMPTY_BITWISE_NEGATE;UnaryMinusExpression EMPTY_UNARY_MINUS;UnaryPlusExpression EMPTY_UNARY_PLUS;/** Chooses the best method node for method reference. */Label neLabel out// only visit the sub-expressionimport DelegatingControllerimport IndyStaticTypesMultiTypeDispatcher/** An alternative {@link org.codehaus.groovy.classgen.asm.WriterController} which handles static types and method ... */boolean isInStaticallyCheckedMethod;StaticTypesCallSiteWriter callSiteWriter;StaticTypesStatementWriter statementWriter;StaticTypesTypeChooser typeChooser;StaticInvocationWriter invocationWriter;BinaryExpressionMultiTypeDispatcher binaryExprHelper;new Function<MethodNode,Tuple2<MethodNode,Integer>>(...) { ... }new StaticTypesCallSiteWriter(...)new StaticTypesStatementWriter(...)new StaticTypesTypeChooser(...)new StaticInvocationWriter(...)new StaticTypesLambdaWriter(...)new StaticTypesMethodReferenceExpressionWriter(...)new StaticTypesUnaryExpressionHelper(...)matchingScore(...)this.binaryExprHelpernew IndyStaticTypesMultiTypeDispatcher(...)new StaticTypesBinaryExpressionMultiTypeDispatcher(...)new Comparator<Tuple2<MethodNode,Integer>>(...) { ... }updateStaticCompileFlag(...)AnnotatedNode nodeboolean implementsGeneratedClosureOrGeneratedLambdaInterfaceboolean isStaticCompileNodeisStaticallyCompiled(...)new StaticTypesWriterController(...)/** A ClassVisitor proxy, which can log bytecode generation ... */CompilerConfiguration.ASM_API_VERSIONnew LoggableTextifier(...)new Function<Tuple2<MethodNode,Integer>,MethodNode>(...) { ... }int score...*=...// generate the default bytecode; most likely a method closure// implied argument for expr::staticMethod?// TODO: move the findMethodRefMethod and checking to StaticTypeCheckingVisitor// create adapter method to pass extra argument// replace expression with declaring type// GROOVY-10653// ex: "string"::size// GROOVY-9813: reference to variadic method which needs adapter method to match runtime arguments to its parameters// GROOVY-10653: create static adapter in source class with target as first parameter// TODO: move this check to the parser// "string"::valueOf refers to static method, so instance is superflous// GROOVY-9853// targets the array// TODO: if StaticTypesMarker.DIRECT_METHOD_CALL_TARGET or// OptimizingStatementWriter.StatementMeta.class metadatas// can bet set for the ctorX above, then this can be TRUE:// MUST clone the parameters to avoid impacting the original parameter type of SAM// there is an implicit parameter for "String::length"// check direct match// check vararg match// 0 case// 1+ case// no match; remove method// class::instanceMethod// TODO: pass this type inimport Attributeimport Printerimport Textifier/** Logging bytecode generation, which can make debugging easy ... */CompilerConfiguration compilerConfiguration;PrintWriter out;int lineCount;this.compilerConfigurationgetOutput(...)new Supplier<PrintWriter>(...) { ... }int textSize/** A utility for getting information of types ... */Type.BOOLEAN_TYPEType.BYTE_TYPEType.CHAR_TYPEType.DOUBLE_TYPEType.FLOAT_TYPEType.INT_TYPEType.LONG_TYPEType.SHORT_TYPEList<Object> bcListClass<> resObject bcInteger insngetInvocationPositionInfo(...)int maxDepthgetLogClassgenStackTraceMaxDepth(...)StringBuilder arrayDescriptionTuple2<ClassNode,Integer> arrayInfoextractArrayInfo(...)getStackTrace(...)new Throwable(...)new Predicate<StackTraceElement>(...) { ... }new Function<StackTraceElement,String>(...) { ... }Printer pvisitModule(...)Textifier tvisitClassAnnotation(...)Printer tvisitClassTypeAnnotation(...)visitClassAttribute(...)visitClassEnd(...)visitRequire(...)visitExport(...)visitUse(...)visitProvide(...)makeRefDescription(...)visitModuleEnd(...)int dimensionvisitAnnotationEnd(...)new Tuple2<ClassNode,Integer>(...)visitFieldAnnotation(...)String REF_DESCRIPTION;Map<ClassNode,String> PRIMITIVE_TYPE_TO_DESCRIPTION_MAP;Map<String,ClassNode> NAME_TO_PRIMITIVE_TYPE_MAP;Map<Type,Integer> PRIMITIVE_TYPE_TO_LOAD_INSN_MAP;Map<Type,Integer> PRIMITIVE_TYPE_TO_RETURN_INSN_MAP;Map<Type,String> PRIMITIVE_TYPE_TO_WRAPPED_CLASS_DESCRIPTOR_MAP;visitFieldTypeAnnotation(...)Map<Class<>,Class<>> PRIMITIVE_TYPE_TO_WRAPPED_CLASS_MAP;visitFieldAttribute(...)visitFieldEnd(...)// reference typevisitMethodAnnotation(...)visitMethodTypeAnnotation(...)visitMethodAttribute(...)visitFrame(...)/** Stores state information about global AST transformations applied to a compilation unit. */visitInsnAnnotation(...)visitTryCatchAnnotation(...)visitLocalVariableAnnotation(...)visitMethodEnd(...)visitNestHost(...)GroovyClassLoader transformLoader;visitNestMember(...)// Classloader for global and local transformsSet<String> globalTransformNames;// The compilation unit global AST transformations are applied on// collected AST transformation namesvisitMainClass(...)this.transformLoadervisitOpen(...)visitAnnotableParameterCount(...)visitRecordComponentAnnotation(...)visitRecordComponentTypeAnnotation(...)visitRecordComponentAttribute(...)visitRecordComponentEnd(...)/** Resolves constants in annotation definitions. */boolean annotationDef;this.annotationDefimport AsmDecompilerimport AsmReferenceResolver/** This class is used as a pluggable way to resolve class names. ... *//** Thrown when compilation fails from source errors. */int phase;ProcessingUnit unit;// The phase in which the failures occurred// The *Unit object this exception wrapsthis.phase/** Returns the ProcessingUnit in which the error occurred. *//* public String toString() { ... *//** Formats the error data as a String. */import ClassCodeExpressionTransformerimport ClassCompletionVerifierimport EnumCompletionVisitorimport EnumVisitorimport ExtendedVerifierimport InnerClassCompletionVisitorimport InnerClassVisitorimport CompilationCustomizerimport InputStreamReaderSourceimport ExceptionMessageimport Messageimport GroovyClassimport AnnotationCollectorTransformimport TraitComposerimport FileOutputStreamimport static StaticCompilationMetadataKeys.DYNAMIC_OUTER_NODE_CALLBACKimport static StaticTypesMarker.SWITCH_CONDITION_EXPRESSION_TYPE/** The CompilationUnit collects all compilation data as it is generated by the compiler system. ... */new ClassNode(...) { ... }ClassNodeResolver$1/** Helper class to return either a SourceUnit or ClassNode. */ClassNode cn;/** creates a new LookupResult. You are not supposed to supply ... */this.cn/** returns true if a ClassNode is stored *//** returns true if a SourecUnit is stored *//** returns the SourceUnit *//** returns the ClassNode */Map<String,ClassNode> cachedClasses;// Map to store cached classesClassNode NO_CLASS;/** Internal helper used to indicate a cache hit for a class that does not exist. ... *//** Resolves the name of a class to a SourceUnit or ClassNode. If no ... */getFromClassCache(...)LookupResult resultisClassNode(...)cacheClass(...)/** caches a ClassNode ... *//** returns whatever is stored in the class cache for the given name ... *//** Extension point for custom lookup logic of finding ClassNodes. Per default ... */tryAsLoaderClassOrScript(...)/** This method is used to realize the lookup of a class using the compilation ... */GroovyClassLoader loaderMap<String,Boolean> optionscompilationUnit.configurationfindDecompiled(...)findByClassLoading(...)tryAsScript(...)/** Search for classes using class loading */Class<?> clsnew LinkedList<SourceUnit>(...)/** Search for classes using ASM decompiler */DecompiledClassNode asmClassString fileNameURL resourcenew DecompiledClassNode(...)new AsmReferenceResolver(...)isFromAnotherClassLoader(...)ClassLoader parent/** Tries to find a script using the compilation unit class loader. */LookupResult lrGroovyClassLoader gclSourceUnit sourceUnit/** Gets the time stamp of a class. ... */getCompilationTimeStamp(...)/** Returns true if the source in URL is newer than the class. ... */// We use here the class cache cachedClasses to prevent// calls to ClassLoader#loadClass. Disabling this cache will// cause a major performance hit.// NOTE: it's important to do no lookup against script files// here since the GroovyClassLoader would create a new CompilationUnit//TODO: The case of a NoClassDefFoundError needs a bit more research;// a simple recompilation is not possible it seems. The current class// we are searching for is there, so we should mark that somehow.// Basically the missing class needs to be completely compiled before// we can again search for the current name./* catch (NoClassDefFoundError ncdfe) { ... *///NOTE: we might return false here even if we found a class,//      because  we want to give a possible script a chance to//      recompile. This can only be done if the loader was not//      the instance defining the class.// this may happen under Windows because getResource is case insensitive under that OS!// fall through and attempt other search strategies// try to find a script from classpath// fall through and let the URL be null// if the stream can't be opened, let's keep the old referencenew ArrayList<GroovyClass>(...)/** The phases of the GroovyCompiler. This is an enum facade on top of the ... */new CompilePhase(...)Phases.INITIALIZATIONPhases.PARSINGPhases.CONVERSIONPhases.SEMANTIC_ANALYSISPhases.CANONICALIZATIONPhases.INSTRUCTION_SELECTIONPhases.FINALIZATIONnew CompilePhase[]CompilePhase INITIALIZATION;/** source files are opened and environment configured */CompilePhase PARSING;/** the grammar is used to to produce tree of tokens representing the source code */CompilePhase CONVERSION;/** An abstract syntax tree (AST) is created from token trees */CompilePhase SEMANTIC_ANALYSIS;/** Performs consistency and validity checks that the grammar can't check for, and resolves classes */CompilePhase CANONICALIZATION;/** Complete building the AST */CompilePhase INSTRUCTION_SELECTION;/** instruction set is chosen, for example java5 or pre java5 */CompilePhase CLASS_GENERATION;/** creates the binary output in memory */CompilePhase OUTPUT;/** write the binary output to the file system */CompilePhase FINALIZATION;/** Perform any last cleanup */...[] phases;/** The phases as an array, with a null entry. */int phaseNumber;this.phaseNumber/** Returns the underlieng integer Phase number. *//** Returns the CompilePhase for the given integer phase number. ... */phase.phaseNumberimport NullWriternew ClassNodeResolver(...)new ResolveVisitor(...)new HashSet<JavaFileObject>(...)import StringTokenizerimport static SystemUtil.getBooleanSafeimport static SystemUtil.getIntegerSafeimport static StringGroovyMethods.isAtLeast/** Compilation control flags and coordination stuff. */new LinkedHashSet<String>(...)CompilationUnit$3new Verifier(...)ClassVisitor classVisitorString sourceNameLinkedList<ClassNode> innerClassesnew OptimizerVisitor(...)CompilationUnit.thisgetNode(...)new LabelVerifier(...)new InstanceOfVerifier(...) { ... }CompilationUnit$3$1new LinkedList<CompilationCustomizer>(...)new ClassCompletionVerifier(...)new ExtendedVerifier(...)failIfErrors(...)new AsmClassGenerator(...)new GroovyClass(...)Phases.ALLnew Deque<>[]new LinkedList<PhaseOperation>(...)Opcodes.V1_4Opcodes.V1_5Opcodes.V1_6Opcodes.V1_7Opcodes.V1_8Opcodes.V9Opcodes.V10Opcodes.V11Opcodes.V12Opcodes.V13Opcodes.V14Opcodes.V15Opcodes.V16Opcodes.V17Opcodes.V18Opcodes.V19defaultTargetBytecode(...)CompileUnit ast;/** The overall AST for this CompilationUnit. */Map<String,SourceUnit> sources;/** The source units from which this unit is built. */// TODO: Switch to private and access through getAST().Queue<SourceUnit> queuedSources;List<GroovyClass> generatedClasses;/** The classes generated during classgen. */...[] phaseOperations;...[] newPhaseOperations;/** If set, outputs a little more information during compilation when errors occur. */boolean configured;/** True after the first {@link #configure(CompilerConfiguration)} operation. */ClassgenCallback classgenCallback;/** A callback called during the {@code classgen} phase of compilation */ProgressCallback progressCallback;/** A callback for use during {@link #compile()} */ClassNodeResolver classNodeResolver;ResolveVisitor resolveVisitor;ASTTransformationsContext astTransformationsContext;/** The AST transformations state data. */Set<JavaFileObject> javaCompilationUnitSet;/** Initializes the CompilationUnit with defaults. *//** Initializes the CompilationUnit with defaults except for class loader. *//** Initializes the CompilationUnit with no security considerations. *//** Initializes the CompilationUnit with a CodeSource for controlling ... */this.astTransformationsContextnew ASTTransformationsContext(...)this.astnew CompileUnit(...)addPhaseOperations(...)applyCompilationCustomizers(...)new ISourceUnitOperation(...) { ... }Opcodes.ASM9new CompilerConfiguration(...) { ... }CompilerConfiguration$1convert(...)addModule(...)getCompilationCustomizers(...)getProgressCallback(...)new Consumer<ProgressCallback>(...) { ... }getPhase(...)new EnumVisitor(...)resolveVisitor.phasegetDisabledGlobalASTTransformations(...)new Function<Set<String>,Set<String>>(...) { ... }new StaticImportVisitor(...)new InnerClassVisitor(...)new GenericsVisitor(...)AnnotationCollectorTransform.ClassChangerClassChanger xformernew ClassChanger(...)transformClass(...)doExtendTraits(...)List<ClassNode> classesgetJointCompilationOptions(...)new Function<Map<String,Object>,Map<String,Object>>(...) { ... }CompileUnit cuIterator<String> itgetClassesToCompile(...)String INVOKEDYNAMIC;/** Optimization Option for enabling <code>invokedynamic</code> compilation. */String GROOVYDOC;/** Optimization Option for enabling attaching groovydoc as AST node metadata. */String RUNTIME_GROOVYDOC;/** Optimization Option for enabling attaching {@link groovy.lang.Groovydoc} annotation. */String PARALLEL_PARSE;/** Optimization Option for enabling parallel parsing. */String MEM_STUB;/** Joint Compilation Option for enabling generating stubs in memory. */String JDK4;/** This (<code>"1.4"</code>) is the value for targetBytecode to compile for a JDK 1.4. */String JDK5;/** This (<code>"1.5"</code>) is the value for targetBytecode to compile for a JDK 1.5. */String JDK6;/** This (<code>"1.6"</code>) is the value for targetBytecode to compile for a JDK 1.6. */String JDK7;/** This (<code>"1.7"</code>) is the value for targetBytecode to compile for a JDK 1.7. */String JDK8;/** This (<code>"1.8"</code>) is the value for targetBytecode to compile for a JDK 1.8. */String JDK9;/** This (<code>"9"</code>) is the value for targetBytecode to compile for a JDK 9. */String JDK10;/** This (<code>"10"</code>) is the value for targetBytecode to compile for a JDK 10. */String JDK11;/** This (<code>"11"</code>) is the value for targetBytecode to compile for a JDK 11. */String JDK12;/** This (<code>"12"</code>) is the value for targetBytecode to compile for a JDK 12. */String JDK13;/** This (<code>"13"</code>) is the value for targetBytecode to compile for a JDK 13. */String JDK14;/** This (<code>"14"</code>) is the value for targetBytecode to compile for a JDK 14. */String JDK15;/** This (<code>"15"</code>) is the value for targetBytecode to compile for a JDK 15. */String JDK16;boolean cs/** This (<code>"16"</code>) is the value for targetBytecode to compile for a JDK 16. */String JDK17;/** This (<code>"17"</code>) is the value for targetBytecode to compile for a JDK 17. */String JDK18;/** This (<code>"18"</code>) is the value for targetBytecode to compile for a JDK 18. */String JDK19;boolean trait/** This (<code>"19"</code>) is the value for targetBytecode to compile for a JDK 19. */String POST_JDK5;/** This constant is for comparing targetBytecode to ensure it is set to JDK 1.5 or later. ... */String PRE_JDK5;/** This constant is for comparing targetBytecode to ensure it is set to an earlier value than JDK 1.5. ... */Map<String,Integer> JDK_TO_BYTECODE_VERSION_MAP;/** JDK version to bytecode version mapping. */String DEFAULT_TARGET_BYTECODE;...[] ALLOWED_JDKS;/** The valid targetBytecode values. */int ASM_API_VERSION;/** The ASM API version used when loading/parsing classes and generating proxy adapter classes. */String DEFAULT_SOURCE_ENCODING;/** The default source encoding. */CompilerConfiguration DEFAULT;/** A convenience for getting a default configuration.  Do not modify it! ... */int warningLevel;/** See {@link WarningMessage} for levels. *//** Encoding for source files. */PrintWriter output;/** The <code>PrintWriter</code> does nothing. */File targetDirectory;/** Directory into which to write classes. */List<String> classpath;/** Classpath for use during compilation. */boolean verbose;/** If true, the compiler should produce action information. *//** If true, debugging code should be activated. */boolean parameters;/** If true, generates metadata for reflection on method parameters. */int tolerance;/** The number of non-fatal errors to allow before bailing. *//** Base class name for scripts (must derive from Script). */ParserPluginFactory pluginFactory;String defaultScriptExtension;/** Extension used to find a groovy file. */Set<String> scriptExtensions;/** Extensions used to find a groovy files. */boolean recompileGroovySource;/** If set to true recompilation is enabled. */int minimumRecompilationInterval;/** The minimum of time after a script can be recompiled. */String targetBytecode;/** The bytecode version target. *//** Whether the bytecode version has preview features enabled (JEP 12). */new IGroovyClassOperation(...) { ... }boolean logClassgen;/** Whether logging class generation is enabled */int logClassgenStackTraceMaxDepth;/** sets logging class generation stack trace max depth */Map<String,Object> jointCompilationOptions;/** Options for joint compilation (null by default == no joint compilation). */Map<String,Boolean> optimizationOptions;/** Options for optimizations (empty map by default). */List<CompilationCustomizer> compilationCustomizers;Set<String> disabledGlobalASTTransformations;/** Global AST transformations which should not be loaded even if defined in ... */BytecodeProcessor bytecodePostprocessor;/** Sets the compiler flags/settings to default values. ... */File directorymkdirs(...)FileOutputStream streamnew FileOutputStream(...)boolean memStubEnabledStaticVerifier verifiernew StaticVerifier(...)new InnerClassCompletionVisitor(...)new EnumCompletionVisitor(...)Object callbacknew ClassCodeExpressionTransformer(...) { ... }CompilationUnit$1ClassNode enumTypeCompilationCustomizer customizersetCompilationUnit(...)validatePhase(...)/** Configures its debugging mode and classloader classpath from a given compiler configuration. ... */getDebug(...)this.configured/** Returns the CompileUnit that roots our AST. *//** Get the GroovyClasses generated by compile(). *//** Convenience routine to get the first ClassNode, for ... */setTargetDirectorySafe(...)setTargetBytecodeIfValid(...)/** Convenience routine to get the named ClassNode. */ClassNode[] resultIPrimaryClassNodeOperation handlerdoPhaseOperation(...)this.classNodeResolverthis.javaCompilationUnitSet/** Returns the class loader for loading AST transformations. */getTransformLoader(...)new Supplier<GroovyClassLoader>(...) { ... }/** Adds a set of file paths to the unit. */// SOURCE CREATION//---------------------------------------------------------------------------handleOptimizationOption(...)/** Adds a set of source files to the unit. *//** Adds a source file to the unit. */new SourceUnit(...)/** Adds a InputStream source to the unit. */ReaderSource sourcenew InputStreamReaderSource(...)/** Adds a SourceUnit to the unit. */setClassLoader(...)/** Returns an iterator on the unit's SourceUnits. */new Iterator<SourceUnit>(...) { ... }CompilationUnit$2Iterator<String> nameIterator;/** Adds a ClassNode directly to the unit (ie. without source). ... *//** A callback interface you can use during the {@code classgen} ... */// EXTERNAL CALLBACKS/** Sets a ClassgenCallback.  You can have only one, and setting ... */this.classgenCallback/** A callback interface you can use to get a callback after every ... *//** Sets a ProgressCallback.  You can have only one, and setting ... */this.progressCallback/** Synonym for {@code compile(Phases.ALL)}. */// ACTIONS/** Compiles the compilation unit from sources. */gotoPhase(...)/** Copy constructor. Use this if you have a mostly correct configuration ... */Map<String,Object> jointCompilationOptionssetWarningLevel(...)getWarningLevel(...)setTargetDirectory(...)setClasspathList(...)setVerbose(...)getVerbose(...)setTolerance(...)getTolerance(...)setRecompileGroovySource(...)setMinimumRecompilationInterval(...)setTargetBytecode(...)getTargetBytecode(...)isPreviewFeatures(...)setLogClassgen(...)setLogClassgenStackTraceMaxDepth(...)setDefaultScriptExtension(...)getDefaultScriptExtension(...)setPluginFactory(...)getPluginFactory(...)setDisabledGlobalASTTransformations(...)setScriptExtensions(...)setOptimizationOptions(...)setBytecodePostprocessor(...)setJointCompilationOptions(...)/** Sets the configuration flags/settings according to values from the supplied {@code Properties} instance ... *//** Checks if the specified bytecode version string represents a JDK 1.5+ compatible ... */isAtLeast(...)/** Checks if the specified bytecode version string represents a JDK 1.7+ compatible ... *//** Checks if the specified bytecode version string represents a JDK 1.8+ compatible ... *//** Checks if the specified bytecode version string represents a JDK 9+ compatible ... *//** Checks if the specified bytecode version string represents a JDK 10+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 11+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 12+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 13+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 14+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 15+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 16+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 17+ compatible bytecode version. ... *//** Checks if the specified bytecode version string represents a JDK 18+ compatible bytecode version. ... *//** Method to configure a CompilerConfiguration by using Properties. ... */int numericWarningMessage.NONEWarningMessage.POSSIBLE_ERRORSWarningMessage.PARANOIAnew ConfigurationException(...)parallelStream(...)equalsIgnoreCase(...)int logClassgenStackTraceMaxDepthsetClasspath(...)CompilerConfiguration.PARALLEL_PARSEnew Consumer<SourceUnit>(...) { ... }processPhaseOperations(...)Interrupt xResolveVisitor.Interruptdequeued(...)processNewPhaseOperations(...)completePhase(...)new Consumer<ModuleNode>(...) { ... }sortClasses(...)PhaseOperation opDeque<PhaseOperation> currentPhaseNewOpsrecordPhaseOpsInAllOtherPhases(...)PhaseOperation operationint phString[] classNamesSet<String> disabledTransforms/** Gets the currently configured warning level. See {@link WarningMessage} ... */this.warningLevel/** Sets the warning level. See {@link WarningMessage} for level details. *//** Dequeues any source units added through addSource and resets the compiler ... */SourceUnit unit/** Gets the currently configured source file encoding. */this.sourceEncoding/** Sets the encoding to be used when reading source files. */IPrimaryClassNodeOperation classgen;/** Runs the class generation phase on a single {@code ClassNode}. */new ClassWriter(...) { ... }CompilationUnit$4ClassWriter.COMPUTE_MAXSClassWriter.COMPUTE_FRAMESgetClassNodeResolver(...)/** Gets the currently configured output writer. ... */this.output/** Sets the output writer. ... */getGeneratedInnerClass(...)NullWriter.DEFAULT/** Gets the target directory for writing classes. */this.targetDirectory/** Sets the target directory. */this.classpathgetCommonSuperClassNode(...)/** Sets the classpath. *//** Updates the phase marker on all sources. */// PHASE HANDLINGStringTokenizer tokenizerISourceUnitOperation marknew StringTokenizer(...)File.pathSeparatorsource.phasehasMoreTokens(...)/** sets the classpath using a list of Strings ... */source.phaseComplete// LOOP SIMPLIFICATION FOR SourceUnit OPERATIONS/** Returns true if verbose operation has been requested. */this.verbose/** Turns verbose operation on or off. *//** A loop driver for applying operations to all SourceUnits. ... *//** Returns true if debugging operation has been requested. *//** Turns debugging operation on or off. */SourceUnit sourceunit.sources/** Returns true if parameter metadata generation has been enabled. */unit.phase/** Turns parameter metadata generation on or off. */GroovyBugError gbechangeBugText(...)GroovyBugError e// LOOP SIMPLIFICATION FOR PRIMARY ClassNode OPERATIONS/** A loop driver for applying operations to all primary ClassNodes in ... */getPrimaryClassNodes(...)needSortedInput(...)SourceUnit context/** Returns the requested error tolerance. */this.tolerance/** Sets the error tolerance, which is the number of ... */context.phase/** Gets the name of the base class for scripts.  It must be a subclass ... */this.scriptBaseClass/** Sets the name of the base class for scripts.  It must be a subclass ... */antlr4(...)context.phaseCompletethis.pluginFactorythis.scriptExtensionsnew Supplier<Set<String>>(...) { ... }new GeneratorContext(...)NullPointerException npenew Function<ModuleNode,SourceUnit>(...) { ... }new LinkedHashSet<>(...)getRegisteredExtensions(...)new ExceptionMessage(...)unit.debugunit.phaseCompletegetPhaseDescription(...)GroovyClass groovyClassgetSuperInterfaceCount(...)List<ClassNode> unsortedthis.defaultScriptExtension/** Sets the bytecode compatibility level. The parameter can take one of the values ... */this.targetBytecode/** Retrieves the compiler bytecode compatibility level. Defaults to the minimum ... *//** Returns the ASM bytecode version ... */Integer bytecodeVersionCompilerConfiguration.JDK_TO_BYTECODE_VERSION_MAPOpcodes.V_PREVIEW/** Returns the default target bytecode compatibility level ... */String javaVersiongetJavaVersion(...)/** Whether the bytecode version has preview features enabled (JEP 12) ... *//** Sets whether the bytecode version has preview features enabled (JEP 12). ... */this.previewFeatures/** Returns whether logging class generation is enabled ... *//** Sets whether logging class generation is enabled ... */this.logClassgen/** Returns stack trace max depth of logging class generation ... *//** Sets stack trace max depth of logging class generation ... */this.logClassgenStackTraceMaxDepth/** Gets the joint compilation options for this configuration. ... *//** Sets the joint compilation options for this configuration. ... *//** Gets the optimization options for this configuration. ... *//** Sets the optimization options for this configuration. ... *//** Adds compilation customizers to the compilation process. A compilation customizer is a class node ... *//** Returns the list of compilation customizers. ... *//** Returns the list of disabled global AST transformation class names. ... *//** Disables the specified global AST transformations. In order to avoid class loading side effects, ... */this.disabledGlobalASTTransformationsnew Function<ModuleNode,Stream<? extends ClassNode>>(...) { ... }this.bytecodePostprocessor/** Checks if invoke dynamic is enabled. */Boolean indyEnabledint[] indexClassint[] indexInterfacegetSorted(...)/** Checks if groovydoc is enabled. */Boolean groovydocEnabledgetSuperClassCount(...)/** Checks if runtime groovydoc is enabled. */Boolean runtimeGroovydocEnabledint unsortedSizeint min// TODO GROOVY-9585: add line below once gradle build issues fixed//        compilationCustomizers.addAll(configuration.getCompilationCustomizers());setBugText(...)getBugText(...)addNewPhaseOperation(...)// legacy misspelling// add module to compile unit// resolve head of each class// resolve body of each class// GROOVY-10540: add GroovyObject before STC and classgen// ensure the path is ready for the file/* this happens ... */// create the file and write out the data// post-transform operations:// TODO: Can this be moved into org.codehaus.groovy.transform.sc.transformers.VariableExpressionTransformer?// check for "switch(enumType) { case CONST: ... }"// replace "CONST" variable expression with "EnumType.CONST" property expression// to support incremental compilation, always restart the compiler;// individual passes are responsible for not re-processing old code// bring new sources into phase// Grab processing may have brought in new AST transforms into various phases, process them as well// push this operation to master list and then process it// if this operation has brought in more phase ops for ast transforms, keep recording them// in master list of other phases and keep processing them for this phase// apart from current phase, push new operations for every other phase in the master phase ops list// GROOVY-4272: repositioned from static import visitor// Run the Verifier on the outer class// because the class may be generated even if a error was found// and that class may have an invalid format we fail here if needed// Prep the generator machinery// only show the file name and its extension like javac does in its stacktraces rather than the full path// also takes care of both \ and / depending on the host compiling environment// Run the generation and create the class (if required)// Handle any callback that's been set// Recurse for inner classes// try classes under compilation// try inner classes// adapted from ClassWriter code// check for a nested compilation exceptionimport GroovyExceptionInterface/** Thrown when configuration data is invalid. */Exception cause;/** Initializes the exception from a cause exception. */this.cause/** Initializes the exception with just a message. *//** Returns the causing exception, if available. *//** Its always fatal. *//** Set fatal is just ignored. */import LocatedMessageimport CSTNode/** A base class for collecting messages and errors during processing. ... */LinkedList<Message> errors;/** ErrorMessages collected during processing */LinkedList<WarningMessage> warnings;/** WarningMessages collected during processing */CompilerConfiguration configuration;/** Configuration and other settings that control processing *//** Initialize the ErrorReporter. */this.configurationthat.errorsthis.errors/** Verify correct usage of generics. ... */checkWildcard(...)GenericsType[] rnTypesplural(...)cnTypes.lengthrnTypes.lengthClassNode cnTypeClassNode rnTypeboolean validbounds.length// raw type usage is always allowed// you can't parameterize a non-generified type// parameterize a type by using all of the parameters only// allow Diamond for non-AIC cases from CCE// check nested type parameters// check bounds: unbounded wildcard (aka "?") is universal substitute// check upper bound(s)// first can be class or interface// subsequent bounds if present can be interfacesthat.warningsthis.warnings/** An interface for things that need to be cleaned up after ... */isA(...)Types.INSTANCEOF_OPERATORaddTypeError(...)// TODO: Cannot perform instanceof check against parameterized type Class<Type>. Use the form Class<?> instead since further eneric type information will be erased at runtime/** Adds an error to the message set, but does not cause a failure. The message is not required to have a source ... */new LinkedList<Message>(...)/** Adds a non-fatal error to the message set, which may cause a failure if the error threshold is exceeded. ... *//** Adds an optionally-fatal error to the message set. ... *//** An agent that can be used to defer cleanup operations to ... */new HashSet<>(...)isFatal(...)new LocatedMessage(...)/** Adds an error to the message set and throws CompilationFailedException. *//** Adds a warning to the message set. */isRelevant(...)new LinkedList<WarningMessage>(...)/** Adds a warning to the message set if it is relevant. */new WarningMessage(...)/** Returns the number of errors. *//** Returns the specified error message, or null. */getErrorCount(...)/** Returns the list of errors, or null if there are none. *//** Returns true if there are any errors pending. *//** Returns the number of warnings. */hasWarnings(...)/** Returns the specified warning message, or null. */getWarningCount(...)/** Returns the list of warnings, or null if there are none. *//** Returns true if there are any warnings pending. *//** Returns the last error reported. *//** Returns the specified error's underlying Exception, or null if it isn't one. */Exception exceptionMessage messagegetError(...)Set<> pending;/** Returns the specified error's underlying SyntaxException, or null if it isn't one. */// All objects pending cleanupSyntaxException exceptionHasCleanup object/** Causes the current phase to fail by throwing a CompilationFailedException. */new MultipleCompilationErrorsException(...)// OUTPUT/** Writes error messages to the specified PrintWriter. *//** This class checks the handling of labels in the AST */LinkedList<String> visitedLabels;LinkedList<ContinueStatement> continueLabels;LinkedList<BreakStatement> breakLabels;boolean inLoop;boolean inSwitch;new LinkedList<ContinueStatement>(...)new LinkedList<BreakStatement>(...)/** Represents multiple other exceptions */ErrorCollector collector;Writer dataassertNoLabelsMissed(...)List<String> labelsnew Predicate<BreakStatement>(...) { ... }new Predicate<ContinueStatement>(...) { ... }boolean oldInLoopboolean hasNamedLabelString elementContinueStatement elementBreakStatement elementboolean oldInSwitch//TODO: report multiple missing labels of the same name only once?import ParserException/** A simple extension point to allow us to switch between the classic Groovy parser and the new Antlr based parser(s). */nextPhase(...)import Antlr4PluginFactory/** A factory of parser plugin instances. *//** Creates the ANTLR 4 parser. ... */new Antlr4PluginFactory(...)/** Creates the ANTLR 2 parser. ... */import static ClassHelper.isGroovyObjectType/** Visitor to produce several optimizations: ... *//** Compilation phase identifiers. */new HashMap<Object,FieldNode>(...)int INITIALIZATION;/** Opening of files and such */int PARSING;/** Lexing, parsing, and AST building */int CONVERSION;/** CST to AST conversion */int SEMANTIC_ANALYSIS;/** AST semantic analysis and elucidation */int CANONICALIZATION;/** AST completion */int INSTRUCTION_SELECTION;/** Class generation (pt.1) */int CLASS_GENERATION;/** Class generation (pt.2) */int OUTPUT;/** Output of class to disk */int FINALIZATION;/** Cleanup */int ALL;/** Synonym for full compilation */...[] descriptions;// TODO: If no reference is made to array, convert to switch in getDescription(int)./** Returns a description of the specified phase. *//** A base class for data structures that can collect messages and errors ... *//** The current phase */boolean phaseComplete;/** True if phase is finished */GroovyClassLoader classLoader;/** The ClassLoader to use during processing *//** a helper to share errors and report them *//** Initializes the ProcessingUnit to the empty state. */setConfiguration(...)/** Reconfigures the ProcessingUnit. *//** Gets the CompilerConfiguration for this ProcessingUnit. *//** Sets the CompilerConfiguration for this ProcessingUnit. *//** Returns the class loader in use by this ProcessingUnit. *//** Sets the class loader for use by this ProcessingUnit. */createClassLoader(...)ProcessingUnit.classnew LinkedList<FieldNode>(...)/** Errors found during the compilation should be reported through the ErrorCollector. *//** Returns the current phase. *//** Returns the description for the current phase. *//** Marks the current phase complete and processes any errors. *//** A synonym for <code>gotoPhase(getPhase() + 1)</code>. *//** Wraps up any pending operations for the current phase and switches to the given phase. */// ClassLoaders should only be created inside a doPrivileged block in case// this method is invoked by code that does not have security permissions.// TODO a future Groovy version should create the loader not as a privileged actionimport GenericsTypeNameimport VariableScopeVisitorMap<Object,FieldNode> const2Objects;// TODO make @CS lookup smarter so that we don't need both these mapsMap<Object,FieldNode> const2Prims;List<FieldNode> missingFields;addMissingFields(...)pruneUnneededGroovyObjectInterface(...)boolean isSuperGroovyboolean needsFixList<ClassNode> newInterfaces/** Visitor to resolve types and convert VariableExpression to ... */Object nboolean isPrimitivesetConstantName(...)setConstField(...)// LCONST_0, LCONST_1// TODO consider moving initcode to <clinit> and remaking field final/* GROOVY-3339 - do nothing - so that numbers don't get replaced by cached constants in closure classes */new HashSet<FieldNode>(...)/** Looks for source file extensions in META-INF/services/org.codehaus.groovy.source.Extensions */Set<String> extensionsnew UnlimitedConcurrentCache<String,Set<String>>(...)Enumeration<URL> globalServicesURL serviceBufferedReader svcInIOException exgetDefaultImportClasses(...)...[] DEFAULT_IMPORTS;// `java.util` is used much frequently than other two java packages(`java.io` and `java.net`), so place java.util before the two packages// note: BigInteger and BigDecimal are also imported by defaultString QUESTION_MARK;ImportNode currentImport;Map<GenericsTypeName,GenericsType> genericParameterNames;Set<FieldNode> fieldTypesChecked;boolean checkingVariableTypeInDeclaration;boolean isTopLevelProperty;/* package *//** A ConstructedNestedClass consists of an outer class and a name part, denoting a ... */// sub-divide visitClassNode knownEnclosingType;this.knownEnclosingTypethis.isPrimaryNodehasPackageName(...)import FileReaderSourceimport URLReaderSourceimport Utilities/** we use ConstructedClassWithPackage to limit the resolving the compiler ... *//** Provides an anchor for a single source unit (usually a script file) ... */ParserPlugin parserPlugin;/** The pluggable parser used to generate the AST - we allow ... *//** Where we can get Readers for our source unit *//** A descriptive name of the source unit. This name shouldn't ... */Reduction cst;/** A Concrete Syntax Tree of the source */ModuleNode ast;/** The root of the Abstract Syntax Tree for the source *//** Initializes the SourceUnit from existing machinery. *//** Initializes the SourceUnit from the specified file. */new FileReaderSource(...)/** Initializes the SourceUnit from the specified URL. */new URLReaderSource(...)/** Initializes the SourceUnit for a string of source. *//** we use LowerCaseClass to limit the resolving the compiler ... *//** Returns the name for the SourceUnit. This name shouldn't ... *//** Returns the Concrete Syntax Tree produced during parse()ing. */this.cst/** Returns the Abstract Syntax Tree produced during convert()ing ... *//** Convenience routine, primarily for use by the InteractiveShell, ... *//** A convenience routine to create a standalone SourceUnit on a String ... */// FACTORIES/* protected boolean isEofToken(groovyjarjarantlr.Token token) { ... */CompilerConfiguration configuration/** Parses the source to a CST.  You can retrieve it with getCST(). */// PROCESSINGReader readercreateParserPlugin(...)parseCST(...)/** Generates an AST from the CST.  You can retrieve it with getAST(). */this.phaseCompleteserialize(...)new PrivilegedAction<String>(...) { ... }/** Builds the AST. */VariableScope oldScopesetDescription(...)Map<GenericsTypeName,GenericsType> oldPNamesSyntaxException eParameter[] parasMethodNode oldCurrentMethod/** Returns a sampling of the source at the specified line and column, ... */// SOURCE SAMPLINGString sampleString markerrepeatString(...)resolveGenericsHeader(...)resolveOrFail(...)eol(...)/** This method adds an exception to the error collector. The Exception most likely has no line number attached to it. ... *//** This method adds a SyntaxException to the error collector. The exception should specify the line and column ... *//** Convenience wrapper for {@link ErrorCollector#addFatalError(org.codehaus.groovy.control.messages.Message)}. ... */// Implementation note - there are several ways for the Groovy compiler// to report an unexpected EOF. Perhaps this implementation misses some.// If you find another way, please add it./* Message last = (Message) getErrorCollector().getLastError(); ... */// Create a reader on the source and run the parser.// let's recreate the parser each time as it tends to keep around state// TODO a future Groovy version should get the property not as a privileged action// create an empty ModuleNode to represent a failed parse, in case a later phase attempts to use the AST// can happen with CR only files GROOVY-10676resolveGenericsTypes(...)resolveAliasFromModule(...)resolveToInner(...)String tempreplaceLastPointWithDollar(...)import static ClassNodeUtils.getPropNameForAccessorimport static ClassNodeUtils.hasPossibleStaticMethodimport static ClassNodeUtils.hasPossibleStaticPropertyimport static ClassNodeUtils.hasStaticPropertyGenericsType typeParameterimport static ClassNodeUtils.isInnerClassimport static ClassNodeUtils.isValidAccessorNameimport static GeneralUtils.getGetterNameboolean resolved/** Visitor to resolve constants and method calls from static imports. */boolean inPropertyExpression;Expression foundConstant;Expression foundArgs;boolean inAnnotation;boolean inLeftExpression;/** Call {@link #StaticImportVisitor(ClassNode,SourceUnit)} then {@link #visitClass(ClassNode)}. */this.currentMethodboolean oldInAnnotationresolveToOuter(...)resolveFromCompileUnit(...)resolveFromModule(...)resolveNestedClass(...)resolveFromDefaultImports(...)resolveFromStaticInnerClasses(...)resolveWildcardBounding(...)Set<ClassNode> cycleCheckClass<? extends Expression> clazzVariableExpression.classtransformVariableExpression(...)BinaryExpression.classtransformBinaryExpression(...)PropertyExpression.classtransformPropertyExpression(...)MethodCallExpression.classtransformMethodCallExpression(...)transformClosureExpression(...)ConstructorCallExpression.classtransformConstructorCallExpression(...)ArgumentListExpression.classList<ClassNode> outerClasses//   new Bar(foo:1)// will become://   new Bar(baz:1)// then this constructor (not normal usage of statics)://   import static Bar.foo as baz// if you have a Bar class with a static foo property, and this:Expression keyMap<String,ImportNode> importNodesListIterator<ClassNode> itString newKeyboolean oldInLeftExpressionTypes.EQUALStaticMethodCallExpression smceStaticMethodCallExpression resultfindStaticFieldOrPropertyAccessorImportFromModule(...)Predicate<ClassNode> resolverExpression methodboolean staticWrtCurrentMethodCallExpression resultboolean thisOrSuperMethodtryFindPossibleMethod(...)ClassNode maybeNestednew ConstructedNestedClass(...)isVisibleNestedClass(...)getInterfaces(...).lengthint lastPointIndexConstructedClassWithPackage tmpString savedNametmp.classNameSet<String> packagePrefixSetClassHelper.BigInteger_TYPEMap<String,Set<String>> DEFAULT_IMPORT_CLASS_AND_PACKAGES_CACHE;String packagePrefixnew ConstructedClassWithPackage(...)findStaticMethodImportFromModule(...)boolean foundInstanceMethodPredicate<ClassNode> hasPossibleStaticMemberhasPossibleStaticProperty(...)CompileUnit compileUnitClassNode cuClassisInnerClass(...)String pnameClassNode aliasedNodeNamedArgumentListExpression namedArgsList<MapEntryExpression> entryExpressionsClassNode tmptransformMapEntryExpression(...)boolean oldInPropertyExpressionExpression oldFoundConstantExpression oldFoundArgsboolean newNameUsedList<ClassNode> moduleClassesMap<String,ImportNode> staticImportsfindStaticProperty(...)ClassNode mClassgetAccessorName(...)findStaticPropertyOrField(...)ambiguousClass(...)boolean accessorMap<String,ImportNode> staticStarImportsfindStaticMethod(...)findStaticPropertyAccessorGivenArgs(...)newStaticMethodCallX(...)ClassNode importTypeString importMemberprefix(...)ClassNodeResolver.NO_CLASSExpression argumentListisSourceUnit(...)addClassNodeToCompile(...)Expression accessorExprnew Interrupt(...)findStaticPropertyAccessor(...)String accessorNameExpression accessorfindStaticPropertyAccessorByFullName(...)hasStaticProperty(...)transformDeclarationExpression(...)newStaticPropertyX(...)transformAnnotationConstantExpression(...)boolean doInitialClassTestStringBuilder nameTuple2<StringBuilder,Boolean> classNameInfo// replicate a little bit of AnnotationVisitor here// because we can't wait until later to do this// GROOVY-8819// GROOVY-10396: skip the instance method checks when the context is static with-respect-to current class// GROOVY-9587: don't check for property for non-empty call args// check for reference to outer class method in this(...) or super(...)// check for reference to static method in this(...) or super(...) or when call not resolvedString varName// look for one of these://   import static MyClass.isProp [as isOtherProp]//   import static MyClass.getProp [as getOtherProp]//   import static MyClass.setProp [as setOtherProp]// when resolving property reference//   import static MyClass.prop [as otherProp]// when resolving property or field reference//   import static MyClass.*//   import static MyClass.field [as alias]//   import static MyClass.method [as alias]//   import static MyClass.property [as alias]// when resolving implicit-this call name(args)// assume name refers to a callable static field/property//   import static MyClass.isProperty [as alias]//   import static MyClass.getProperty [as alias]//   import static MyClass.setProperty [as alias]// when resolving isName(), getName() or setName(args)// expression may refer to getter or setter, so make new call// when resolving name(args), getName(), etc.// GROOVY-10329// expression may refer to getter or setter, so ...// GROOVY-9382, GROOVY-10133// TODO: validate args?// <-- will be replaced// perhaps the property accessor will be generated/** Checks for dynamic variables in static contexts. */MethodNode oldMethodNodegetDeclaredOrInheritedField(...)List<ClassNode> interfacesToChecktestVanillaNameForClass(...)// and class as property// a PropertyExpression with the ClassExpression of Integer as objectExpression// this check will ignore a .class property, for Example Integer.class will be// iterate from the inner most to the outer and check for classesLinkedList<Expression> stackClassNode nextInterface// initial expression will be argument to special constructor call// GROOVY-5687: interface constants not visible to implementing sub-class in static contextClassExpression foundObject stackElementPropertyExpression classPropertyExpressionString propertyNamePartPropertyExpression classPropertyExpressionContainerExpression itboolean itlpboolean ipeExpression propertyboolean spreadSafePropertyExpression oldlookupClassName(...)checkThisAndSuperAsPropertyAccess(...)correctClassClassChain(...)directlyImplementsTrait(...)ClassNode originboolean isClassnew LowerCaseClass(...)isRoot(...)removeReferencedClassVariable(...)Types.ASSIGNMENT_OPERATORisOneOf(...)Types.ARRAY_EXPRESSIONTypes.SYNTH_LISTTypes.SYNTH_MAPboolean mapMapExpression meSpreadMapExpression mapExpressionClassNode cceTypeMethodCallExpression retExpression oldLeftDeclarationExpression newDeclExprfixDeclaringClass(...)// TODO: get normal resolving to set declaring classcheckAnnotationMemberValue(...)ClassNode oldNodehasImportsResolved(...)String importNamesetImportsResolved(...)checkCyclicInheritance(...)ClassNode variantInnerClassNode cnnew VariableScopeVisitor(...)Exception.classgetVariableType(...)resolveGenericsType(...)List<Tuple2<ClassNode,GenericsType>> upperBoundsWithGenericsnew LinkedList<Tuple2<ClassNode,GenericsType>>(...)List<Tuple2<ClassNode,ClassNode>> upperBoundsToResolvenew LinkedList<Tuple2<ClassNode,ClassNode>>(...)ClassNode typeTypeboolean isWildcardGTboolean dealWithGenericsboolean nameAddedGenericsType lastTuple2<ClassNode,ClassNode> tpTuple2<ClassNode,GenericsType> tpGenericsType tpsetResolved(...)/** For cases like "Foo&lt;? super Bar> -> Foo&lt;T extends Baz>" there is an ... */typeArguments.lengthGenericsType[] parametersClassNode implicitBoundimport XStreamimport StaxDriverXStream xstream// outer class (aka knownEnclosingType) may have aliased name that should be reflected here toonew XStream(...)new StaxDriver(...)FileWriter astFileWriter// we do not do our name mangling to find an inner class// if the type is a ConstructedClassWithPackage, because in this case we// are resolving the name at a different place alreadyFile astFile// GROOVY-8715astFile(...)// GROOVY-10153: handle "C<? super T>"// GROOVY-4043: for type "X", try "A$X" with each type in the class hierarchy (except for Object)// Another case we want to check here is if we are in a// nested class A$B$C and want to access B without// qualifying it by A.B. A alone will work, since that// is the qualified (minus package) name of that class// anyway.// Since we have B and want to get A we start with the most// outer class, put them together and then see if that does// already exist. In case of B from within A$B we are done// after the first step already. In case of for example// A.B.C.D.E.F and accessing E from F we test A$E=failed,// A$B$E=failed, A$B$C$E=fail, A$B$C$D$E=success.// a class consisting of a vanilla name can never be// a static inner class, because at least one dot is// required for this. Example: foo.bar -> foo$bar// we replace '.' only in the className part// with '$' to find an inner class. The case that// the package is really a class is handled elsewhere// we do not resolve a vanilla name starting with a lower case letter// try to resolve against a default import, because we know that the// default packages do not contain classes like thesetoXML(...)// if the type name was resolved before, we can try the successfully resolved packages first, which are much less and very likely successful to resolve.// As a result, we can avoid trying other default import packages and further resolving, which can improve the resolving performance to some extent.// We limit the inner class lookups here by using ConstructedClassWithPackage.// This way only the name will change, the packagePrefix will// not be included in the lookup. The case where the// packagePrefix is really a class is handled elsewhere.// WARNING: This code does not expect a class that has a static//          inner class in DEFAULT_IMPORTS// Only the non-cached type and packages should be cached// look into the compile unit if there is a class with that name// In case of getting a ConstructedClassWithPackage here we do not do checks for partial// matches with imported classes. The ConstructedClassWithPackage is already a constructed// node and any subclass resolving will then take place elsewhere// check module node imports aliases// the while loop enables a check for inner classes which are not fully imported,// but visible as the surrounding class is imported and the inner class is public/protected static/* we have a name foo.bar and an import foo.foo. This means foo.bar is possibly ... */// static alias only for inner classes and must be at end of chain/** Takes the incoming file-name and checks whether this is a URI using the <tt>file:</tt> protocol or a non-URI and treats ... */// full match// We can compare here by length, because pname is always// a substring of name, so same length means they are equal.//partial match// At this point we know that we have a match for pname. This mayString astFileName// mean, that name[pname.length()..<-1] is a static inner class.// For this the rest of the name does not need any dots in its name.// It is either completely a inner static class or it is not.// Since we do not want to have useless lookups we create the name// completely and use a ConstructedClassWithPackage to prevent lookups against the package.// we decided if we have a vanilla name starting with a lower case// letter that we will not try to resolve this name against .*// imports. Instead a full import is needed for these.// resolveAliasFromModule will do this check for us. This method// does also check the module contains a class in the same package// of this name. This check is not done for vanilla names starting// with a lower case letter anymore// we add a package if there is none yet and the module has one. But we// do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage// hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.// but since the prefix may have them and the code there does ignore that// fact. We check here for ConstructedClassWithPackage.// look into the module node if there is a class with that name// check package this class is defined in. The usage of ConstructedClassWithPackage here// means, that the module package will not be involved when the// compiler tries to find an inner class.// check static imports for static inner types// this may be fully redundant with resolveAliasFromModule// check star imports ("import foo.*" or "import foo.Bar.*")// We do not need to check instances of LowerCaseClass// to be a Class, because unless there was an import for// for this we do not lookup these cases. This was a decision// made on the mailing list. To ensure we will not visit this// method again we set a NO_CLASS for this name// GROOVY-10300, et al.: restart resolve// this loop builds a name from right to left each name part separated by "."// stop at super and this// anything other than PropertyExpressions or// VariableExpressions will stop resolving// the class property stops resolving, dynamic property names too// we are at the first name part. This is the right most part.// If this part is in lower case, then we do not need a class// check. other parts of the property expression will be tested// by a different method call to this method, so foo.Bar.bar// can still be resolved to the class foo.Bar and the static// field bar.// we handle the property part as if it were not part of the property// possibly an inner class (or inherited inner class)/* GROOVY-4009: when a normal variable is simply being used, there is no need to try to ... */// asking isResolved here allows to check if a primitive// type name like "int" was used to make t. In such a case// we have nothing left to do.// It was no primitive type, so next we see if the name,// which is a vanilla name, starts with a lower case letter.// In that case we change it to a LowerCaseClass to let the// compiler skip the resolving at several places in this class.// the name is a type so remove it from the scoping// as it is only a classvariable, it is only in// referencedClassVariables, but must be removed// for each parentscope too// maybe we have C[k1:v1, k2:v2] -> should become (C)([k1:v1, k2:v2])// we have C[*:map] -> should become (C) map// may be we have C[k1:v1] -> should become (C)([k1:v1])// GROOVY-9642// duplicates part of AnnotationVisitor because we cannot wait until later// resolve constant-looking expressions statically// do it now since they get transformed away later// GROOVY-9866, GROOVY-10466// VariableScopeVisitor visits anon. inner class body inline, so resolve now// GROOVY-6977// resolve other class headers before members, et al.// initialize scopes/variables now that imports and super types are resolved// attempt resolution on all types, so don't short-circuit and stop if we've previously failed// JSR-308 support// GROOVY-10622: bounds are too complex for a redirect-only representation//genericsType.setUpperBounds(bounds);/** Base class for compilation customizers which delegate to another customizer. The phase this ... */CompilationCustomizer delegate;/** This compilation customizer allows addiing various types of imports to the compilation unit. Supports adding: ... */new LinkedList<Import>(...)List<Import> imports;ModuleNode astImport anImportanImport.typeanImport.aliasanImport.classNodeanImport.fieldanImport.starnew Import(...)ImportType.regularImportType.staticImportImportCustomizer.ImportType.staticImportImportCustomizer.ImportTypeaddStaticStar(...)ImportType.starImportCustomizer.ImportType.staticStar/** Represents imports which are possibly aliased. */// -------------------- Helper classes -------------------------ImportType type;String star;// only used for star importsthis.starnew ImportType(...)ImportType regular;ImportType staticImport;ImportType staticStar;ImportType star;// GROOVY-8399: apply import customizations only once per module/** This customizer allows securing source code by controlling what code constructs are permitted. ... */new LinkedList<StatementChecker>(...)/** Users wanting to customize the configuration process such as adding imports, restricting the ... */CompilePhase phase;/** A base class for customizers which only have to be applied on specific source units. ... */Closure<Boolean> extensionValidator;Closure<Boolean> baseNameValidator;Closure<Boolean> sourceUnitValidator;Closure<Boolean> classValidator;ReaderSource readerFileReaderSource fileacceptSource(...)acceptClass(...)this.baseNameValidatorthis.extensionValidatorthis.sourceUnitValidatorthis.classValidatorint extString baseNameacceptExtension(...)acceptBaseName(...)new LinkedList<ExpressionChecker>(...)import AbstractFactoryimport FactoryBuilderSupport/** This factory generates an array of compilation customizers. ... */boolean isPackageAllowed;boolean isClosuresAllowed;boolean isMethodDefinitionAllowed;List<String> allowedImports;// importsList<String> disallowedImports;List<String> allowedStaticImports;// static importsList<String> disallowedStaticImports;List<String> allowedStarImports;// star importsList<String> disallowedStarImports;List<String> allowedStaticStarImports;// static star importsList<String> disallowedStaticStarImports;boolean isIndirectImportCheckEnabled;// Direct instantiation of classes without imports will therefore also fail if this option is enabled// if set to true, then security rules on imports will also be applied on classnodes.// indirect import checksList<Class<? extends Statement>> allowedStatements;List<Class<? extends Statement>> disallowedStatements;List<StatementChecker> statementCheckers;List<Class<? extends Expression>> allowedExpressions;List<Class<? extends Expression>> disallowedExpressions;List<ExpressionChecker> expressionCheckers;List<Integer> allowedTokens;// tokens from TypesList<Integer> disallowedTokens;List<String> allowedConstantTypes;// constant typesList<String> disallowedConstantTypes;List<String> allowedReceivers;// receiversList<String> disallowedReceivers;/** Legacy alias for {@link #getDisallowedImports()} */getDisallowedImports(...)this.disallowedImports/** Legacy alias for {@link #setDisallowedImports(List)} */setDisallowedImports(...)/** Legacy alias for {@link #getAllowedImports()} */getAllowedImports(...)this.allowedImports/** Legacy alias for {@link #setAllowedImports(List)} */setAllowedImports(...)/** Legacy alias for {@link #getDisallowedStarImports()} */getDisallowedStarImports(...)this.disallowedStarImportsnormalizeStarImports(...)/** Legacy alias for {@link #setDisallowedStarImports(List)} */setDisallowedStarImports(...)/** Legacy alias for {@link #getAllowedStarImports()} */getAllowedStarImports(...)this.allowedStarImports/** Legacy alias for {@link #setAllowedStarImports(List)} */setAllowedStarImports(...)new CompilationCustomizer[]/** This factory allows the generation of an {@link ImportCustomizer import customizer}. You may embed several ... */String starImportaddImports(...)/** Legacy alias for {@link #getDisallowedStaticImports()} */getDisallowedStaticImports(...)this.disallowedStaticImports/** Legacy alias for {@link #setDisallowedStaticImports(List)} */setDisallowedStaticImports(...)/** Legacy alias for {@link #getAllowedStaticImports()} */getAllowedStaticImports(...)this.allowedStaticImports/** Legacy alias for {@link #setAllowedStaticImports(List)} */setAllowedStaticImports(...)/** Legacy alias for {@link #getDisallowedStaticStarImports()} */getDisallowedStaticStarImports(...)this.disallowedStaticStarImports/** Legacy alias for {@link #setDisallowedStaticStarImports(List)} */setDisallowedStaticStarImports(...)/** Legacy alias for {@link #getAllowedStaticStarImports()} */getAllowedStaticStarImports(...)this.allowedStaticStarImports/** Legacy alias for {@link #setAllowedStaticStarImports(List)} */setAllowedStaticStarImports(...)/** Legacy alias for {@link #getDisallowedExpressions()} */getDisallowedExpressions(...)this.disallowedExpressions/** Legacy alias for {@link #setDisallowedExpressions(List)} */setDisallowedExpressions(...)/** Legacy alias for {@link #getAllowedExpressions()} */getAllowedExpressions(...)this.allowedExpressions/** Legacy alias for {@link #setAllowedExpressions(List)} */setAllowedExpressions(...)/** Legacy alias for {@link #getDisallowedStatements()} */getDisallowedStatements(...)this.disallowedStatements/** Legacy alias for {@link #setDisallowedStatements(List)} */setDisallowedStatements(...)/** Legacy alias for {@link #getAllowedStatements()} */getAllowedStatements(...)this.allowedStatements/** Legacy alias for {@link #setAllowedStatements(List)} */setAllowedStatements(...)/** Set this option to true if you want your import rules to be checked against every class node. This means that if ... *//** Legacy alias for {@link #getDisallowedTokens()} */getDisallowedTokens(...)/** Sets the list of tokens which are not permitted. ... */this.disallowedTokens/** Legacy alias for {@link #setDisallowedTokens(List)}. */setDisallowedTokens(...)/** Legacy alias for {@link #getAllowedTokens()} */Closure<> clonegetAllowedTokens(...)/** Sets the list of tokens which are permitted. ... */this.allowedTokens/** Legacy alias for {@link #setAllowedTokens(List)} */setAllowedTokens(...)new ImportHelper(...)ImportCustomizer customizer;this.customizerClass<> aClassaddStarImports(...)/** This factory lets a user define a compilation customizer without having to define ... */Map<> result/** Legacy alias for {@link #getDisallowedConstantTypes()} */getDisallowedConstantTypes(...)this.disallowedConstantTypesgetAllowedConstantTypes(...)this.allowedConstantTypes/** Legacy alias for {@link #setAllowedConstantTypes(List)} */setAllowedConstantTypes(...)/** An alternative way of setting constant types. ... */List<String> valuesMap<> mapCompilationCustomizer.classObject phasesetConstantTypesWhiteList(...)/** Legacy alias for {@link #setAllowedConstantTypesClasses(List)} */setAllowedConstantTypesClasses(...)setConstantTypesBlackList(...)/** Legacy alias for {@link #setDisallowedConstantTypesClasses(List)} */setDisallowedConstantTypesClasses(...)/** Legacy alias for {@link #getDisallowedReceivers()} */getDisallowedReceivers(...)/** Sets the list of classes which deny method calls. ... */this.disallowedReceivers/** Legacy alias for {@link #setDisallowedReceivers(List)} */setDisallowedReceivers(...)/** An alternative way of setting {@link #setDisallowedReceivers(java.util.List) receiver classes}. ... *//** A helper interface for factories which require post processing of generated nodes. ... */setReceiversBlackList(...)/** Legacy alias for {@link #setDisallowedReceiversClasses(List)}. */setDisallowedReceiversClasses(...)/** Legacy alias for {@link #getAllowedReceivers()} */getAllowedReceivers(...)/** Sets the list of classes which may accept method calls. ... */this.allowedReceivers/** Legacy alias for {@link #setAllowedReceivers(List)} *//** An alternative way of setting {@link #setReceiversWhiteList(java.util.List) receiver classes}. ... */setReceiversWhiteList(...)/** Legacy alias for {@link #setAllowedReceiversClasses(List)} */setAllowedReceiversClasses(...)createGroovyCodeVisitor(...)filterMethods(...)new SecurityException(...)checkMethodDefinitionAllowed(...)import SecureASTCustomizer/** This factory allows the generation of a {@link SecureASTCustomizer}. Embedded elements are delegated ... */new SecureASTCustomizer(...)assertImportIsAllowed(...)assertStarImportIsAllowed(...)Entry<String,ImportNode> entryMap<>.Entry<String,ImportNode>import SourceAwareCustomizer/** Factory for use with {@link CompilerCustomizationBuilder}. Allows the construction of {@link SourceAwareCustomizer ... */SourceOptions datanew SourceOptions(...)data.delegatenew CompilationCustomizer(...) { ... }SourceAwareCustomizerFactory$1CompilePhase.FINALIZATION(...).delegateSourceAwareCustomizer sourceAwareCustomizernew SourceAwareCustomizer(...)data.extensionValidatordata.extensiondata.extensionsdata.basenameValidatordata.basenamedata.basenamesaddExtensionValidator(...)addBasenameValidator(...)data.unitValidatorsetSourceUnitValidator(...)data.classValidatorsetClassValidator(...)List<String> extensionsassertStaticImportIsAllowed(...)ClassNode clNodenew SecuringCodeVisitor(...)Closure<Boolean> extensionValidatornew Closure<Boolean>(...) { ... }SourceAwareCustomizerFactory$2setExtensionValidator(...)List<String> basenamesClosure<Boolean> basenameValidatorSourceAwareCustomizerFactory$3setBaseNameValidator(...)// validate with closuresClosure<Boolean> unitValidator;Closure<Boolean> basenameValidator;// validate with one stringString basename;List<String> extensions;// validate with list of stringsList<String> basenames;// GROOVY-9035 supply a "no-op" CompilationCustomizer if none found to make DSL friendly for empty case/** For ReaderSources that can choose a parent class, a base that ... *//** Returns true if the source can be restarted (ie. if getReader() ... */BufferedReader lineSource;// If set, a reader on the current source fileint number;// The last line read from the current source file/** Returns a line from the source, or null, if unavailable.  If ... */// The last line number readgetWildCardImport(...)/** Cleans up any cached resources used by getLine(). */// If the source is already open and is passed the line we// want, close it.// If the line source is closed, try to open it.// Read until the appropriate line number.// otherwise cleanup() will wipe out valueString fqn/** A ReaderSource for source files. */Charset UTF8;// The File from which we produce Readers./** Creates the ReaderSource from a File descriptor. ... *//** Returns a new Reader on the underlying source object. */Charset cs/** This visitor directly implements the {@link GroovyCodeVisitor} interface instead of using the {@link ... *//** Checks that a given statement is either in the allowed list or not in the disallowed list. ... */Class<? extends Statement> clazzboolean hasBOMStatementChecker statementCheckerisAuthorized(...)/** Checks that a given expression is either in the allowed list or not in the disallowed list. ... */ExpressionChecker expressionCheckerString typenamegetExpressionType(...)StaticMethodCallExpression exprMethodPointerExpression expr/** Checks that a given token is either in the allowed list or not in the disallowed list. ... */assertStatementAuthorized(...)/** Returns a URI for the file of this source. ... */// we want to remove the BOM windows adds from a file if the encoding is UTF-8// in other cases we depend on the charsets/** A ReaderSource for source strings. */InputStream stream;// The InputStream from which we produce a Reader.this.stream/** TODO: Should return the URI for this source, but we can't know what it is here. ... */assertExpressionAuthorized(...)checkConstantTypeIfNotMethodNameOrProperty(...)/** An Writer than eats its input. */new NullWriter(...)NullWriter DEFAULT;assertTokenAuthorized(...)import HasCleanup/** An interface for things that can supply (and potentially resupply) a Reader ... *//** Returns a new Reader on the underlying source object.  Returns ... *//** Returns a URI for this source. ... */String string;// The String from which we produce Readers.this.string/** Returns a Data URI (RFC 2397) containing the literal value of this source string. ... *//** A ReaderSource for source files hosted at a URL. */// The URL from which we produce Readers./** Returns a URI for the URL of this source. ... *//** This interface allows the user to provide a custom expression checker if the dis/allowed expression lists are not ... *//** This interface allows the user to provide a custom statement checker if the dis/allowed statement lists are not ... */import ProcessingUnit/** A class for error messages produced by the parser system. */ProcessingUnit owner;/** Returns the underlying Exception. *//** Writes out a nicely formatted summary of the exception. */String description/* if (debug) */// verify imports// verify static imports// we should now check if the import is in the star imports// check that there's no star import blacklist// noop/** A base class for compilation messages. */CSTNode context;/** The CSTNode that indicates the location to which the message applies. */int columngetSample(...)/** Writes the message to the specified PrintWriter.  The supplied ... *//** A synonym for write( writer, owner, null ). *//** Creates a new Message from the specified text. */// FACTORY METHODS/** Creates a new Message from the specified SyntaxException. */Object data;// Message text// Data, when the message text is an I18N identifierthis.dataSyntaxException cause;setSourceLocator(...)/** Returns the underlying SyntaxException. *//** Writes out a nicely formatted summary of the syntax error. *//** A class for warning messages. */int NONE;// WARNING LEVELSint LIKELY_ERRORS;// For querying, ignore all errorsint POSSIBLE_ERRORS;// Warning indicates likely errorint PARANOIA;// Warning indicates possible error/** Returns true if a warning would be relevant to the specified level. */// Warning indicates paranoia on the part of the compiler/** Returns true if this message is as or more important than the ... */this.importanceint importance;// CONSTRUCTION AND DATA ACCESS/** Creates a new warning message. ... */// The warning level, for filteringimport ReflectPermissionnew ReflectPermission(...)ReflectPermission REFLECT_PERMISSION;SecurityManager securityManagerpackageCanNotBeAddedAnotherClass(...)import ExpandoMetaClassimport CallSiteClassLoaderimport LazyReferenceClassLoader.classcheckCreateClassLoader(...)new LazyReference<CachedField[]>(...) { ... }CachedClass$1PrivilegedAction<CachedField[]> actionnew PrivilegedAction<CachedField[]>(...) { ... }checkAccessPermission(...)isAccessible(...)AccessControlException ecreateCacheAccessControlExceptionOf(...)new CacheAccessControlException(...)// TODO future Groovy versions should deprecate then remove this classimport static ReflectionUtils.makeAccessibleInPrivilegedActionCachedClass clazz;Constructor<> cachedConstructor;this.cachedConstructornew Predicate<Field>(...) { ... }checkCanSetAccessible(...)CachedClass.classnew Function<Field,CachedField>(...) { ... }new CachedField(...)new IntFunction<CachedField[]>(...) { ... }new CachedField[]new LazyReference<CachedConstructor[]>(...) { ... }CachedClass$2CachedConstructor[] constructorsCachedConstructor cachedConstructorcachedConstructor.cachedConstructorPrivilegedAction<CachedConstructor[]> actionConstructor<> constrnew PrivilegedAction<CachedConstructor[]>(...) { ... }isConstructorOfAbstractClass(...)createException(...)new InstantiationException(...)makeAccessibleIfNecessary(...)boolean makeAccessibleDone;makeAccessibleInPrivilegedAction(...)boolean accessAllowed;new Predicate<Constructor<>>(...) { ... }Field field;new Function<Constructor<>,CachedConstructor>(...) { ... }new CachedConstructor(...)CachedClass.thisnew IntFunction<CachedConstructor[]>(...) { ... }new CachedConstructor[]new LazyReference<CachedMethod[]>(...) { ... }CachedClass$3Object goalValueboolean madeAccessible;PrivilegedAction<CachedMethod[]> actionnew PrivilegedAction<CachedMethod[]>(...) { ... }import CallSiteGeneratorimport MethodHelpernew CachedMethod[]CachedMethod[] methodsnew Comparator<Object>(...) { ... }new Predicate<Method>(...) { ... }new Function<Method,CachedMethod>(...) { ... }new CachedMethod(...)new IntFunction<CachedMethod[]>(...) { ... }LinkageError eCachedMethod.EMPTY_ARRAYCachedMethod[] declaredMethodsList<CachedMethod> methodsnew ArrayList<CachedMethod>(...)declaredMethods.lengthCachedClass cachedClass;Method cachedMethod;boolean skipCompiled;CachedMethod transformedMethod;SoftReference<Constructor<CallSite>> pogoCallSiteConstructor, ...;this.cachedMethodthis.cachedClasscompareToCachedMethod(...)compareToMethod(...)int strCompint retCompCachedClass[] paramsCachedClass[] otherParamsint pdotherParams.lengthint classCompint nameCompList<CachedMethod> mopMethodsCachedMethod methodsuperClass.mopMethodsCachedMethodComparatorByName.INSTANCECachedClass.this.mopMethodsnew LazyReference<CachedClass>(...) { ... }CachedClass$4Class<?>[] mparamsmparams.length(...).cachedMethodcheckAccessible(...)new LazyReference<CallSiteClassLoader>(...) { ... }CachedClass$5new PrivilegedAction<CallSiteClassLoader>(...) { ... }new CallSiteClassLoader(...)CachedClass.this.cachedClassthis.transformedMethodnew LazyReference<Collection<ClassInfo>>(...) { ... }CachedClass$6Set<ClassInfo> resnew LinkedHashSet<ClassInfo>(...)Constructor<CallSite> ctorderef(...)isCompilable(...)compilePogoMethod(...)new SoftReference<Constructor<CallSite>>(...)Error enew PogoCachedMethodSiteNoUnwrapNoCoerce(...)PogoMetaMethodSite.PogoCachedMethodSiteNoUnwrapNoCoerceCachedClass ifacegetDeclaredInterfaces(...)compilePojoMethod(...)ReflectionCache.OBJECT_CLASS.classInfonew LazyReference<Set<CachedClass>>(...) { ... }CachedClass$7new PojoCachedMethodSiteNoUnwrapNoCoerce(...)PojoMetaMethodSite.PojoCachedMethodSiteNoUnwrapNoCoerceSet<CachedClass> resnew HashSet<CachedClass>(...)compileStaticMethod(...)new StaticMetaMethodSiteNoUnwrapNoCoerce(...)StaticMetaMethodSite.StaticMetaMethodSiteNoUnwrapNoCoerceCacheAccessControlException exgetCachedMethod(...)// really, this should never happen, it's evidence of corruption if it doesCachedClass$8CachedClass aClassReferenceBundle softBundle;LazyReference<CachedField[]> fields;LazyReference<CachedConstructor[]> constructors;LazyReference<CachedMethod[]> methods;import ExpandoMetaClassCreationHandleimport MetaClassRegistryLazyReference<CachedClass> cachedSuperClass;import ComputeValueimport ArrayCachedClassimport BigDecimalCachedClassimport BigIntegerCachedClassimport BooleanCachedClassimport ByteCachedClassimport CachedSAMClassimport CharacterCachedClassimport DoubleCachedClassimport FloatCachedClassimport IntegerCachedClassimport LongCachedClassimport NumberCachedClassimport ObjectCachedClassimport ShortCachedClassimport StringCachedClassLazyReference<CallSiteClassLoader> callSiteClassLoader;import FinalizableLazyReference<Collection<ClassInfo>> hierarchy;import LockableObjectimport ManagedConcurrentLinkedQueueimport ManagedReferenceLazyReference<Set<CachedClass>> declaredInterfaces;LazyReference<Set<CachedClass>> interfaces;Class<?> cachedClass;ClassInfo classInfo;boolean isArray;boolean isPrimitive;boolean isInterface;boolean isNumber;...[] mopMethods;int distance;this.classInfo/** Handle for all information we want to keep about the class ... */new LockableObject(...)new ManagedConcurrentLinkedQueue<ClassInfo>(...)createGroovyClassValue(...)new ComputeValue<ClassInfo>(...) { ... }ClassInfo$1ClassInfo retnew ClassInfo(...)new GlobalClassSet(...)LazyCachedClassRef cachedClassRef;LazyClassLoaderRef artifactClassLoader;LockableObject lock;CachedClass infWeakReference<Class<?>> classRef;AtomicInteger version;MetaClass strongMetaClass;ManagedReference<MetaClass> weakMetaClass;inf.cachedClass...[] dgmMetaMethods;...[] newMetaMethods;ManagedIdentityConcurrentMap<Object,MetaClass> perInstanceMetaClassMap;CachedClass curReferenceBundle weakBundle;ManagedConcurrentLinkedQueue<ClassInfo> modifiedExpandos;GroovyClassValue<ClassInfo> globalClassValue;GlobalClassSet globalClassSet;setAssignableFrom(...)this.classRefnew WeakReference<Class<?>>(...)cur.cachedClassnew LazyCachedClassRef(...)CachedMethod resnew LazyClassLoaderRef(...)arrayContentsEq(...)invalidateCallSites(...)MetaClass strongRefIterator<ClassInfo> itrthis.distanceClassInfo infosetStrongMetaClass(...)/** Returns the {@code Class} associated with this {@code ClassInfo}. ... */List<MetaMethod> arr/** Removes a {@code ClassInfo} from the cache. ... */getAllGlobalClassInfo(...)ClassInfo classInfoonClassInfo(...)(...).inRegistryreplaceWeakMetaClassRef(...)ManagedReference<MetaClass> weakRefManagedReference<MetaClass> newRefnew ManagedReference<MetaClass>(...)MetaClass strongMcMetaClass weakMcgetWeakMetaClass(...)isValidWeakMetaClass(...)MetaClass answerMetaClassRegistry.MetaClassCreationHandleMetaClassCreationHandle mccHandleisKeepJavaMetaClasses(...)setWeakMetaClass(...)classInfo.newMetaMethods/** if EMC.enableGlobally() is OFF, return whatever the cached answer is. ... */boolean enableGloballyOnboolean cachedAnswerIsEMCaddSubclassExpandos(...)CachedClass cls/** Returns the {@code MetaClass} for the {@code Class} associated with this {@code ClassInfo}. ... */cls.classInfogetMetaClassUnderLock(...)MetaClass instanceMetaClassgetPerInstanceMetaClass(...)inf.classInfofullSize(...)new ObjectCachedClass(...)ExpandoMetaClass emcnew StringCachedClass(...)Object mmgetExpandoSubclassMethods(...)FastArray farrfarr.sizeMetaClassImpl mciupdateSetNewMopMethods(...)ExpandoMetaClass newEmcclassInfo.dgmMetaMethodsList<MetaMethod> resMetaClassImpl answergetRegistry(...)updateAddNewMopMethods(...)MetaMethod mmnew NumberCachedClass(...)new IntegerCachedClass(...)new DoubleCachedClass(...)new BigDecimalCachedClass(...)new LongCachedClass(...)resetCachedMetaClasses(...)new FloatCachedClass(...)new ShortCachedClass(...)new CachedMethodComparatorByName(...)Comparator<> INSTANCE;new CachedMethodComparatorWithString(...)/** compatibility method ... */new BooleanCachedClass(...)// GROOVY-9245: exclude inner class ctors// no synthetic JDK 5+ methodsnew CharacterCachedClass(...)// populate mopMethods// TODO a future Groovy version should perform the action not as a privileged actionnew BigIntegerCachedClass(...)new ByteCachedClass(...)new CachedClass(...)new ArrayCachedClass(...)import GroovySunClassLoaderSoftReference<Class<>> klazz;AtomicInteger classNamesCounter;new CachedClosureClass(...)isSAM(...)new CachedSAMClass(...)getSAMMethod(...)new SoftReference<Class<>>(...)GroovySunClassLoader.sunVMdoesKnow(...)createClassName(...)String clsNameint suffixgetAndIncrement(...)definePrivileged(...)MetaMethod.classConstructor<>.classnew ManagedIdentityConcurrentMap<Object,MetaClass>(...)new PrivilegedAction<Class<>>(...) { ... }define(...)import BufferedOutputStreamimport DataInputStreamimport DataOutputStreamClassInfo info;CachedClass declaringClass;Class<> returnType;this.infocreateCachedClass(...)info.classRefMetaMethod proxy;new PrivilegedAction<ClassLoaderForClassArtifacts>(...) { ... }new ClassLoaderForClassArtifacts(...)createProxy(...)ManagedConcurrentLinkedQueue<ClassInfo> items;Class<?> aClass// safe value here to avoid multiple reads with possibly// differing values due to concurrency/** Abstraction for Java version dependent ClassValue implementations. ... */Constructor<?> constructorimport GroovyClassValueJava7boolean USE_CLASSVALUE;/** This flag is introduced as a (hopefully) temporary workaround for a JVM bug, that is to say that using ... */new GroovyClassValueJava7<T>(...)new GroovyClassValuePreJava7<T>(...)import ManagedConcurrentMap...[] PRIMITIVE_CLASSES;/** Approximation of Java 7's {@link java.lang.ClassValue} that works on earlier versions of Java. ... */new GroovyClassValuePreJava7Map(...)ManagedConcurrentMap<>.EntryWithValue<Class<?>,T>DataOutputStream outnew DataOutputStream(...)new BufferedOutputStream(...)Map<String,Integer> classesnew LinkedHashMap<String,Integer>(...)computeValue(...)T valuefinalizeReference(...)ManagedConcurrentMap<>.Segment<Class<?>,T>new EntryWithValue(...)ReferenceBundle bundlenew GroovyClassValuePreJava7Segment(...)ComputeValue<T> computeValue;GroovyClassValuePreJava7Map map;this.computeValue// the value isn't use in the getOrPut call - see the EntryWithValue constructor above//all entries are guaranteed to be EntryWithValue. Value can only be null if computeValue returns nullimport HandleMetaClassimport MixinInstanceMetaPropertynew ManagedIdentityConcurrentMap<>(...)ManagedIdentityConcurrentMap<>.ReferenceType.SOFTint nextClassIdClass<> primitiveDgmMethodRecord recordrecord.returnTypeInteger idrecord.parameters.lengthrecord.parametersEntry<String,Integer> stringIntegerEntryMap<>.Entry<String,Integer>writeUTF(...)writeInt(...)ManagedIdentityConcurrentMap<>.ReferenceTypeExpandoMetaClass emc;CachedClass mixinClass;CachedConstructor constructor;ManagedIdentityConcurrentMap<> managedIdentityConcurrentMap;this.emcthis.mixinClassthis.constructorfindDefaultConstructor(...)addMixinClass(...)CachedConstructor constrCachedClass[] classesObject mixinInstancenew MixedInMetaClass(...)Class<> selfClassExpandoMetaClass mcrecord.classNamerecord.methodNameInteger keyClassLoader loaderDgmMethodRecord.classDataInputStream innew DataInputStream(...)Map<Integer,Class<>> classesnew HashMap<Integer,Class<>>(...)replaceDelegate(...)Class<> categoryClassCachedClass cachedCategoryClassnew MixinInMetaClass(...)List<MetaProperty> propListint skipMetaProperty propreadInt(...)List<DgmMethodRecord> resnew ArrayList<DgmMethodRecord>(...)new MixinInstanceMetaProperty(...)staticMethod(...)MixinInstanceMetaMethod metaMethodMetaMethod resCachedClass[] paramTypesNewInstanceMetaMethod metaMethodparamTypes.lengthnew NewInstanceMetaMethod(...) { ... }MixinInMetaClass$1PRIMITIVE_CLASSES.lengthreadUTF(...)int keyboolean skipRecordnew DgmMethodRecord(...)int psize// under certain restrictive environments, loading certain classes may be forbidden// and could yield a ClassNotFoundException (Google App Engine)MixinInMetaClass thatthat.mixinClass//                    if (self.pickMethod(method.getName(), method.getNativeParameterTypes()) == null) {import TripleKeyHashMapnew TripleKeyHashMap(...)autoboxType(...)TripleKeyHashMap mopNames;TripleKeyHashMap.EntryEntry mopNameEntrymopNameEntry.valueCachedClass STRING_CLASS;a2.lengtha1.lengthCachedClass OBJECT_CLASS;CachedClass OBJECT_ARRAY_CLASS;// the method is never called// FIXME no implementation?//        SoftDoubleKeyMap.Entry val = (SoftDoubleKeyMap.Entry) assignableMap.getOrPut(klazz, aClass, null);//        if (val.getValue() == null) {//            val.setValue(Boolean.TRUE);//            val.setValue(Boolean.valueOf(klazz.isAssignableFrom(aClass)));//        return ((Boolean)val.getValue()).booleanValue();import AccessibleObject/** This class contains utility methods to determine which class called the ... */Set<String> setnew ClassContextHelper(...)MethodHandle isSealedMethodHandleMethodHandle getPermittedSubclassesMethodHandlefindVirtual(...)ReflectiveOperationException ignoredSet<String> IGNORED_PACKAGES;/** The packages in the call stack that are only part of the Groovy MOP. */ClassContextHelper HELPER;/** Determines whether or not the getCallingClass methods will return ... *//** Gets the immediate calling class, ignoring MOP frames. ... */getCallingClass(...)/** Gets the called that is matchLevel stack frames before the call, ... */Class<>[] classContextgetClassContext(...)int depthclassShouldBeIgnored(...)classContext.lengthThrowable ignoredoGetMethods(...)new Function<Class<?>,Method[]>(...) { ... }List<Method> methodListnew LinkedList<Method>(...)Class<?>[] methodParameterTypesargTypes.lengthClass<?> parameterTypeClass<?> argTypeClass<?> boxedArgTypeClass<?> boxedParameterTypetrySetAccessible(...)new PrivilegedAction<Optional<AccessibleObject>>(...) { ... }makeAccessible(...)// to be run in PrivilegedAction!setAccessible(...)...[] nativeParamTypes;boolean isVargsMethod;List<AccessibleObject> retnew ArrayList<AccessibleObject>(...)aoa.lengthpt.lengthNoClassDefFoundError errthis.parameterTypes...[...].isArraygetParametersTypes0(...)Class<>[] nptgetPT(...)npt.lengthCachedClass[] ptgetNativeParameterTypes0(...)AccessibleObject aoint lenMinus1Object lastThrowable ignoredClass<?>[] resultargumentArray.lengthcorrectArguments(...)coerceArgument(...)MethodHandle IS_SEALED_METHODHANDLE;MethodHandle GET_PERMITTED_SUBCLASSES_METHODHANDLE;//set.add("java.lang.reflect");MetaClassHelper.ARRAY_WITH_NULLisVargsMethod(...)fitToVargs(...)/** this method is called when the number of arguments to a method is greater than 1 ... */Class<> vargsClassOrig// swallow for strict security managers, module systems, android or othersClass<> vargsClass// replace isAccessible with canAccess once min JDK version >= 9// swallow for strict security managers, module systems, android, etc.// swallow for strict security managers, module systems, android or others,Object[] argumentArrayObject[] newArgsObject vargsnewArgs.lengthObject lastArgument// but try one-by-one to get the allowed ones at least// TODO a future Groovy version should deprecate this classObject wrappedmakeCommonArray(...)/** Special class loader, which when running on Sun VM allows to generate accessor classes for any method */int nArgumentsargumentTypes.lengthisValidVargsMethod(...)CachedClass arrayTypeCachedClass componentTypeClass<> argumentTypegetArgClass(...)SunClassLoader resnew PrivilegedAction<SunClassLoader>(...) { ... }new SunClassLoader(...)Map<String,Class<>> knownClasses;SunClassLoader sunVM;Class<> magicSunClassLoader.class// Uncomment if at some point this method can be called before parameterTypes initialized// getParameterTypes();// -1 because the varg part is optional// only case left is arguments.length == parameterTypes.length// correct argumentArray's length// the vargs argument is missing, so fill it with an empty array// the number of arguments is correct, but if the last argument// is no array we have to wrap it in a array. If the last argument// is null, then we don't have to do anything// no array so wrap it// we may have to box the argument!// the number of arguments is too big, wrap all exceeding elements// in an array, but keep the old elements that are no vargs// copy arguments that are not a varg// create a new array for the vargs and copy them// implicit null argument// lets check the parameter types matchboolean isAndroidAndroidSupport.classloadMagic(...)ClassWriter cwnew ClassWriter(...)InputStream asStreamresName(...)ClassReader.SKIP_DEBUGboolean IS_ANDROID;Class<> argumentClassClass<> argumentComponentClass<> paramComponentconvertToPrimitiveArray(...)GString[] stringsstrings.lengthprimitiveArrayBox(...)boolean allowNull;this.allowNullint maximumNumberOfParametersClass<>[] parameterTypesClass<>[] ptthis.maximumNumberOfParameters// set it to -1 for starters so parameterTypes will always get a type// this line should be useless, but well, just in caseimport ProxyGeneratornew Method[]// Double, doubleDouble resisInfinite(...)Float resint ABSTRACT_STATIC_PRIVATE;int VISIBILITY;...[] EMPTY_METHOD_ARRAY;// public|protectedMethod method;// int, IntegercoerceToSAM(...)/* Should we make the following method private? */Map<String,Closure<>> implsingletonMap(...)ProxyGenerator.INSTANCEMap<String,Object> mnew PrivilegedAction<Method[]>(...) { ... }AccessControlException acecoerceNumber(...)Class<?> ciMethod foundint aspint visibleClass<> paramNoSuchMethodException ignore/* || param == Byte.TYPE */Method m2/** returns the abstract method from a SAM type, if it is a SAM type. ... */getSAMMethodImpl(...)NoClassDefFoundError ignoreMethod resMethod miTraits.Implemented.classTraits.ImplementedList<Method> methodsClass<> STRING_CLASS;Class<> GSTRING_CLASS;getSingleNonDuplicateMethod(...)// swallow and do as if no method is available// SAM = single public abstract method// if the class is not abstract there is no abstract method// res stores the first found abstract method// ignore methods, that are not abstract and from Object// ignore trait methods which have a default implementation// avoid throwing `NoSuchMethodException` as possible as we couldimport GroovyClassValue/** GroovyClassValue implementaion that simply delegates to Java 7's java.lang.ClassValue ... *//** Utilities for handling array types *//** Calculate the dimension of array ... */checkArrayType(...)/** Get the type of array elements ... *//** Get the type of array elements by the dimension ... *//** Check whether the type passed in is array type. ... *//** This class contains methods special to optimizations used directly from bytecode in Groovy 1.8 */disabledStandardMetaClass(...)// ------------------ int ------------------isOrigInt(...)// ------------------ int[] ------------------isOrigIntArray(...)/** get value from int[] using normalized index *//** set value from int[] using normalized index */// ------------------ byte ------------------isOrigByte(...)// ------------------ byte[] ------------------/** get value from byte[] using normalized index *//** set value from byte[] using normalized index */// ------------------ short ------------------isOrigShort(...)// ------------------ short[] ------------------/** get value from short[] using normalized index *//** set value from short[] using normalized index */// ------------------ char ------------------isOrigChar(...)// ------------------ char[] ------------------/** get value from char[] using normalized index *//** set value from char[] using normalized index */// ------------------ long ------------------isOrigLong(...)// ------------------ long[] ------------------/** get value from long[] using normalized index *//** set value from long[] using normalized index */// ------------------ boolean ------------------isOrigBool(...)// ------------------ boolean[] ------------------/** get value from boolean[] using normalized index *//** set value from boolean[] using normalized index */// ------------------ float ------------------isOrigFloat(...)// ------------------ float[] ------------------/** get value from float[] using normalized index *//** set value from float[] using normalized index */// ------------------ double ------------------isOrigDouble(...)// ------------------ double[] ------------------/** get value from double[] using normalized index *//** set value from double[] using normalized index */// ------------------ Object[] ------------------/** This is a generated class used internally during the writing of bytecode within the CallSiteWriter logic. ... */...[] EMPTY;/** A wrapper for Closure to support composition. ... */Closure<> first;Closure<V> second;this.firstthis.secondnew ComposedClosure(...)import InvocationHandler/** This class is a general adapter to map a call to a Java interface ... */new ConcurrentHashMap<Method,Object>(...)ConcurrentHashMap<Method,Object> handleCache;/** Creates a ConversionHandler with an delegate. ... *//** Returns the delegate. ... *//** This method is a default implementation for the invoke method given in ... */isDefaultMethod(...)defaultOverridden(...)VMPlugin pluginObject handlenew Function<Method,Object>(...) { ... }getInvokeSpecialHandle(...)invokeHandle(...)checkMethod(...)invokeCustom(...)isCoreObjectMethod(...)/** This method is called for all Methods not defined on Object. ... *//** Indicates whether some other object is "equal to" this one. ... */getInvocationHandler(...)/** Returns a hash code value for the delegate. ... *//** Returns a String version of the delegate. ... *//** Checks whether a method is a core method from java.lang.Object. ... *//** This class is a general adapter to adapt a closure to any Java interface. *//** to create a ConvertedClosure object. ... *//** This class is a general adapter to adapt a map of closures to ... *//** to create a ConvertedMap object. ... */Map<> mClosure<> cl/** A wrapper for Closure to support currying. ... */...[] curriedParams;int minParamsExpected;Class<> varargType;/** Creates the curried closure. ... */int origMaxLenClass<> lastTypeisVararg(...)int newIndexcurriedParams.lengthint normalizedIndexcreateNewCurriedParams(...)Object[] newCurriedParamsClosure<V> uncurriedClosurenew CurriedClosure(...)Class<>[] oldParamsint extraParamsint gobbledParamsClass<>[] newParamsoldParams.lengthint numNonVarargsint leadingKeptint trailingKeptint absIndexint newNumNonVarargsint keptParamsnewParams.length// perform some early param checking for non-vararg case// normalise// rcurried arguments are done lazily to allow normal method selection between overloaded alternatives// do -ve indexes based on actual args, so can't accurately calculate type here// so work out minimal type params and vararg on end will allow for other possibilities/** A default implementation of MethodKey */import GroovyPrintWriterimport DelegatesToimport EmptyRangeimport IntRangeimport ListWithDefaultimport MapWithDefaultimport ObjectRangeimport SpreadMapimport FirstParamimport MapEntryOrKeyValueimport BufferedIteratorimport ClosureComparatorimport GroovyCollectionsimport MapEntryimport OrderByimport PermutationGeneratorimport ReversedListimport BooleanClosureForMapPredicateimport BooleanClosurePredicateimport BooleanReturningMethodInvokerimport NumberNumberDivimport NumberNumberMinusimport NumberNumberMultiplyimport NumberNumberPlusimport BooleanArrayGetAtMetaMethodimport BooleanArrayPutAtMetaMethodimport ByteArrayGetAtMetaMethodimport ByteArrayPutAtMetaMethodimport CharacterArrayGetAtMetaMethodimport CharacterArrayPutAtMetaMethodimport DoubleArrayGetAtMetaMethodimport DoubleArrayPutAtMetaMethodimport FloatArrayGetAtMetaMethodimport FloatArrayPutAtMetaMethodimport IntegerArrayGetAtMetaMethodimport IntegerArrayPutAtMetaMethodimport LongArrayGetAtMetaMethodimport LongArrayPutAtMetaMethodimport ObjectArrayGetAtMetaMethodimport ObjectArrayPutAtMetaMethodimport ShortArrayGetAtMetaMethodimport ShortArrayPutAtMetaMethodimport RootLoaderimport ArrayIterableimport ArrayIteratorimport BooleanArrayIteratorimport ByteArrayIteratorimport CharArrayIteratorimport DoubleArrayIterableimport DoubleArrayIteratorimport FloatArrayIteratorimport IntArrayIterableimport IntArrayIteratorimport IteratorBufferedIteratorimport ListBufferedIteratorimport LongArrayIterableimport LongArrayIteratorimport ShortArrayIteratorimport MessageFormatimport BitSetimport Randomimport Timerimport TimerTaskimport BlockingQueueimport AtomicBooleanimport static Groovydoc.EMPTY_GROOVYDOC/** This class defines new groovy methods which appear on normal JDK ... */Long.MIN_VALUENumberNumberPlus.classNumberNumberMultiply.classNumberNumberMinus.classNumberNumberDiv.classObjectArrayGetAtMetaMethod.classObjectArrayPutAtMetaMethod.classBooleanArrayGetAtMetaMethod.classBooleanArrayPutAtMetaMethod.classByteArrayGetAtMetaMethod.classByteArrayPutAtMetaMethod.classCharacterArrayGetAtMetaMethod.classCharacterArrayPutAtMetaMethod.classShortArrayGetAtMetaMethod.classShortArrayPutAtMetaMethod.classIntegerArrayGetAtMetaMethod.classIntegerArrayPutAtMetaMethod.classLongArrayGetAtMetaMethod.classLongArrayPutAtMetaMethod.classFloatArrayGetAtMetaMethod.classFloatArrayPutAtMetaMethod.classDoubleArrayGetAtMetaMethod.classDoubleArrayPutAtMetaMethod.classEncodingGroovyMethods.classIOGroovyMethods.classProcessGroovyMethods.classResourceGroovyMethods.classSocketGroovyMethods.classStreamGroovyMethods.classStringGroovyMethods.classnew NumberAwareComparator<Comparable<>>(...)Integer ONE;BigInteger BI_INT_MAX;BigInteger BI_INT_MIN;BigInteger BI_LONG_MAX;BigInteger BI_LONG_MIN;...[] ADDITIONAL_CLASSES;...[] DGM_LIKE_CLASSES;NumberAwareComparator<Comparable<>> COMPARABLE_NUMBER_AWARE_COMPARATOR;/** Identity check. Since == is overridden in Groovy with the meaning of equality ... *//** Allows the closure to be called for the object reference self. ... */DelegatesTo.Target.classDelegatesTo.Targetwith(...)Closure<V> clonedClosureV result/** Allows the closure to be called for the object reference self (similar ... *//** Allows the subscript operator to be used to lookup dynamic property values. ... *//** Allows the subscript operator to be used to set dynamically named property values. ... *//** Generates a detailed dump string of an object showing its class, ... */boolean groovyObjecttoHexString(...)new PrivilegedAction<Object>(...) { ... }/** Retrieves the list of {@link groovy.lang.MetaProperty} objects for 'self' and wraps it ... */List<MetaProperty> mpsnew ArrayList<PropertyValue>(...)new PropertyValue(...)/** Convenience method that calls {@link #getMetaPropertyValues(java.lang.Object)}(self) ... */List<PropertyValue> metaPropsMap<String,Object> propsPropertyValue mpthrowing(...)/** Scoped use method ... */use(...)/** Extend object with category methods. ... */mixinClassesToMetaClass(...)/** Extend class globally with category methods. ... *//** Gets the url of the jar file/source file containing the specified class ... */getLocation(...)/** Allows the usage of addShutdownHook without getting the runtime first. ... */addShutdownHook(...)/** Scoped use method with list of categories. ... *//** Allows you to use a list of categories, specifying the list as varargs. ... */List<Class<>> listClassCastException e/** Inspects returns the String that matches what would be typed into a ... *//** Provide a dynamic method invocation method which can be overloaded in ... *//** Print a value formatted Groovy style to self if it ... */// print/println/printf/sprintf/** Print a value formatted Groovy style to the print writer. ... *//** Print a value formatted Groovy style to the print stream. ... *//** Print a value to the standard output stream. ... */getClosureOwner(...)/** Print to a console in interactive format. ... *//** Print a linebreak to the standard output stream. ... */new GroovyPrintWriter(...)/** Print a value formatted Groovy style (followed by a newline) to self ... *//** Print a value formatted Groovy style (followed by a newline) to the print writer. ... *//** Print a value formatted Groovy style (followed by a newline) to the print stream. ... *//** Print a value (followed by a newline) to the standard output stream. ... *//** Printf to the standard output stream. ... *//** Printf 0 or more values to the standard output stream using a format string. ... */Object[] newValues/** Printf a value to the standard output stream using a format string. ... */sprintf(...)/** Sprintf to a string. ... */ByteArrayOutputStream outputStreamPrintStream outnew PrintStream(...)/** Returns a formatted string using the specified format string and ... */Object[] ansString elemTypeObject[] oint[] iachar[] cashort[] safloat[] falong[] ladouble[] danew Integer[]ia.lengthnew Character[]ca.lengthboolean[] banew Boolean[]ba.lengthbyte[] banew Byte[]new Short[]sa.lengthnew Float[]fa.lengthnew Long[]la.lengthnew Double[]da.length/** Method for overloading the behavior of the 'case' method in switch statements. ... */isCase(...)/** Special 'Case' implementation for Class, which allows testing ... */Class<> val/** 'Case' implementation for collections which tests if the 'switch' ... *//** 'Case' implementation for maps which tests the groovy truth ... */castToBoolean(...)/** Special 'case' implementation for all numbers, which delegates to the ... *//** Returns an iterator equivalent to this iterator with all duplicated items removed ... */uniqueItems(...)new IteratorIterableAdapter<T>(...)/** Modifies this collection to remove all duplicated items, using Groovy's ... */unique(...)/** Modifies this List to remove all duplicated items, using Groovy's ... *//** Remove all duplicates from a given Collection using Groovy's default number-aware comparator. ... */List<T> answerT tboolean duplicatedT t2coercedEquals(...)/** Remove all duplicates from a given List using Groovy's default number-aware comparator. ... *//** Provides a method that compares two comparables using Groovy's ... *//** Returns an iterator equivalent to this iterator but with all duplicated items ... *//** A convenience method for making a collection unique using a Closure ... *//** A convenience method for making a List unique using a Closure ... *//** A convenience method for making a collection unique using a Closure to determine duplicate (equal) items. ... */int params/** A convenience method for making a List unique using a Closure to determine duplicate (equal) items. ... *//** Returns an iterator equivalent to this iterator with all duplicated ... */Iterator<T> self;this.self/** Remove all duplicates from a given Collection. ... *//** Remove all duplicates from a given List. ... */toUnique(...)Iterator<E> delegate;Set<E> seen;boolean exhausted;E next;new TreeSet<E>(...)E resultboolean foundNextnew ToUniqueIterator<T>(...)/** Returns a Collection containing the items from the Iterable but with duplicates removed. ... */Collection<T> resultcreateSimilarCollection(...)/** Returns a List containing the items from the List but with duplicates removed. ... *//** Returns a Collection containing the items from the Iterable but with duplicates removed ... *//** Returns a List containing the items from the List but with duplicates removed ... *//** Returns a new Array containing the items from the original Array but with duplicates removed with the supplied ... */Collection<T> itemsnew ArrayIterable<T>(...)createSimilarArray(...)/** Returns a new Array containing the items from the original Array but with duplicates removed using the ... *//** Iterates through an array passing each array entry to the given closure. ... */FirstParam.Component.classFirstParam.Component/** Iterates through an aggregate type or data structure, ... */each(...)/** Iterates through an array, ... *//** Iterates through an iterable type, ... */eachWithIndex(...)/** Iterates through an iterator type, ... *//** Iterates through a Collection, ... *//** Iterates through a List, ... *//** Iterates through a Set, ... *//** Iterates through a SortedSet, ... *//** Iterates through an Iterable, passing each item to the given closure. ... */FirstParam.FirstGenericType.classFirstParam.FirstGenericType/** Iterates through an Iterator, passing each item to the given closure. ... *//** Iterates through a Collection, passing each item to the given closure. ... *//** Iterates through a List, passing each item to the given closure. ... *//** Iterates through a Set, passing each item to the given closure. ... *//** Iterates through a SortedSet, passing each item to the given closure. ... *//** Allows a Map to be iterated through using a closure. If the ... */callClosureForMapEntry(...)/** Allows a Map to be iterated through in reverse order using a closure. ... */Iterator<Entry<K,V>> entriescallClosureForMapEntryAndCounter(...)/** Iterate over each element of the list in the reverse order. ... */new ReverseListIterator<T>(...)/** Iterate over each element of the array in the reverse order. ... *//** Used to determine if the given predicate closure is valid (i.e. returns ... */every(...)BooleanClosureWrapper bcwnew ArrayIterator<T>(...)/** Iterates over the entries of a map, and checks whether a predicate is ... */callForMap(...)/** Iterates over every element of a collection, and checks whether all ... */BooleanReturningMethodInvoker bminew BooleanReturningMethodInvoker(...)convertToBoolean(...)/** Iterates over the contents of an object or collection, and checks whether a ... */any(...)/** Iterates over the contents of an iterator, and checks whether a ... *//** Iterates over the contents of an iterable, and checks whether a ... *//** Iterates over the contents of an Array, and checks whether a ... *//** Iterates over the elements of a collection, and checks whether at least ... *//** Iterates over the collection of items which this Object represents and returns each item that matches ... */Collection<> answercreateSimilarOrDefaultCollection(...)/** Iterates over the collection of items and returns each item that matches ... */Collection<T> answerT elementgrep(...)/** Iterates over the array of items and returns a collection of items that match ... */Closure<>.IDENTITY/** Iterates over the collection returning each element that matches ... *//** Iterates over the array returning each element that matches ... *//** Counts the number of occurrences of the given value from the ... */long answer/** Counts the number of occurrences which satisfy the given closure from the ... *//** Counts the number of occurrences of the given value inside this Iterable. ... *//** Counts the number of occurrences which satisfy the given closure from inside this Iterable. ... *//** Counts the number of occurrences which satisfy the given closure from inside this map. ... *//** Counts the number of occurrences of the given value inside this array. ... *//** Counts the number of occurrences which satisfy the given closure from inside this array. ... *//** Convert an iterator to a List. The iterator will become ... *//** Convert an Iterable to a List. The Iterable's iterator will ... *//** Convert an enumeration to a List. ... *//** Collates this iterable into sub-lists of length <code>size</code>. ... */collate(...)/** Collates an array. ... *//** Collates this iterable into sub-lists of length <code>size</code> stepping through the code <code>step</code> ... *//** Collates an array into sub-lists. ... *//** Collates this iterable into sub-lists of length <code>size</code>. Any remaining elements in ... *//** Collates this array into sub-lists. ... */List<T> selfListList<List<T>> answerint selfListSizeint posList<T> elementint offs/** Collates this array into into sub-lists. ... *//** Iterates through this aggregate Object transforming each item into a new value using Closure.IDENTITY ... *//** Iterates through this aggregate Object transforming each item into a new value using the ... *//** Iterates through this aggregate Object transforming each item into a new value using the <code>transform</code> closure ... *//** Iterates through this Array transforming each item into a new value using the ... *//** Iterates through this Array transforming each item into a new value using the <code>transform</code> closure ... *//** Iterates through this Iterator transforming each item into a new value using the ... *//** Iterates through this Iterator transforming each item into a new value using the <code>transform</code> closure ... *//** Iterates through this collection transforming each entry into a new value using Closure.IDENTITY ... *//** Iterates through this Iterable transforming each entry into a new value using the <code>transform</code> closure ... *//** Iterates through this collection transforming each value into a new value using the <code>transform</code> closure ... */Closure<>.DONE/** Recursively iterates through this collection transforming each non-Collection value ... */collectNested(...)/** Recursively iterates through this Iterable transforming each non-Collection value ... */Collection<> c/** Projects each item from a source Iterable to a collection and concatenates (flattens) the resulting collections into a single list. ... */collectMany(...)/** Projects each item from a source collection to a result collection and concatenates (flattens) the resulting ... *//** Projects each item from a source map to a result collection and concatenates (flattens) the resulting ... *//** Projects each item from a source array to a collection and concatenates (flattens) the resulting collections into a single list. ... *//** Projects each item from a source iterator to a collection and concatenates (flattens) the resulting collections into a single list. ... *//** Iterates through this Map transforming each map entry into a new value using the <code>transform</code> closure ... *//** Iterates through this Map transforming each map entry using the <code>transform</code> closure ... */Entry<X,Y> entryMap<>.Entry<X,Y>addEntry(...)/** Iterates through this Map transforming each entry using the <code>transform</code> closure ... */collectEntries(...)createSimilarMap(...)/** A variant of collectEntries for Iterators. ... *//** Iterates through this Iterable transforming each item using the <code>transform</code> closure ... *//** A variant of collectEntries for Iterators using the identity closure as the transform. ... *//** A variant of collectEntries for Iterable objects using the identity closure as the transform. ... *//** A variant of collectEntries for Iterators using a supplied map as the destination of transformed entries. ... *//** Iterates through this Iterable transforming each item using the closure ... *//** A variant of collectEntries for Iterators using the identity closure as the ... *//** A variant of collectEntries for Iterables using the identity closure as the ... *//** Iterates through this array transforming each item using the <code>transform</code> closure ... *//** A variant of collectEntries using the identity closure as the transform. ... */new MapEntry(...)Object[] arrayasType(...)/** Finds the first value matching the closure condition. ... *//** Finds the first item matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). ... *//** Finds the first value matching the closure condition.  Example: ... *//** Finds the first element in the array that matches the given closure condition. ... *//** Treats the object as iterable, iterating through the values it represents and returns the first non-null result obtained from calling the closure, otherwise returns null. ... *//** Treats the object as iterable, iterating through the values it represents and returns the first non-null result obtained from calling the closure, otherwise returns the defaultResult. ... */findResult(...)/** Iterates through the Iterator calling the given closure condition for each item but stopping once the first non-null ... */T resultU next/** Iterates through the Iterable calling the given closure condition for each item but stopping once the first non-null ... *//** Iterates through the Array calling the given closure condition for each item but stopping once the first non-null ... *//** Returns the first non-null closure result found by passing each map entry to the closure, otherwise null is returned. ... *//** Returns the first non-null closure result found by passing each map entry to the closure, otherwise the defaultResult is returned. ... *//** Iterates through the Iterable transforming items using the supplied closure ... */findResults(...)/** Iterates through the Iterator transforming items using the supplied closure ... */List<T> resultU valueT transformed/** Iterates through the Array transforming items using the supplied closure ... *//** Iterates through the map transforming items using the supplied closure ... *//** Finds the first entry matching the closure condition. ... *//** Finds all entries matching the closure condition. If the ... */Map<K,V> answer/** Finds all values matching the closure condition. ... */findAll(...)findMany(...)/** Finds all elements of the array matching the given Closure condition. ... *//** Finds the items matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). ... *//** Finds the elements of the array matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). ... *//** Finds all items matching the closure condition. ... *//** Finds all items matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). ... */BooleanClosureWrapper test/** Returns <tt>true</tt> if this iterable contains the item. ... *//** Returns <tt>true</tt> if this iterable contains all of the elements ... *//** Modifies this collection by removing its elements that are contained ... */Collection<> pickFromnew TreeSet<>(...)new NumberAwareComparator<>(...)/** Modifies this collection so that it retains only its elements that are contained ... *//** Modifies this collection so that it retains only its elements ... *//** Modifies this map so that it retains only its elements that are matched ... */Iterator<Entry<K,V>> iter/** Modifies this collection by removing the elements that are matched according ... */new BooleanClosurePredicate<T>(...)/** Modifies this map by removing the elements that are matched according to the ... */new BooleanClosureForMapPredicate<K,V>(...)/** Modifies the collection by adding all of the elements in the specified array to the collection. ... *//** Modifies this list by inserting all of the elements in the specified array into the ... *//** Splits all items into two lists based on the closure condition. ... */List<> acceptList<> reject/** Splits all items into two collections based on the closure condition. ... */Collection<T> acceptCollection<T> rejectIterator<T> iterList<T> acceptList<T> rejectList<Collection<T>> answernew ArrayList<Collection<T>>(...)/** Adds GroovyCollections#combinations(Iterable) as a method on Iterables. ... *//** Adds GroovyCollections#combinations(Iterable, Closure) as a method on collections. ... *//** Applies a function on each combination of the input lists. ... */subsequences(...)/** Finds all permutations of an iterable. ... */PermutationGenerator<T> generatornew PermutationGenerator<T>(...)/** Finds all permutations of an iterable, applies a function to each permutation and collects the result ... */permutations(...)/** Iterates over all permutations of a collection, running a closure for each iteration. ... */Iterator<List<T>> generator/** Adds GroovyCollections#transpose(List) as a method on lists. ... *//** A transpose method for 2D int arrays. ... */int[][] resultnew int[][]...[...].lengthself.length/** A transpose method for 2D long arrays. ... */long[][] resultnew long[][]/** A transpose method for 2D double arrays. ... */double[][] resultnew double[][]/** Sorts all Iterable members into groups determined by the supplied mapping closure. ... */Map<K,List<T>> answernew LinkedHashMap<K,List<T>>(...)K valuegroupAnswer(...)/** Sorts all array members into groups determined by the supplied mapping closure. ... */groupBy(...)/** Sorts all Iterable members into (sub)groups determined by the supplied ... */Closure<> headclosures.lengthMap<Object,List<>> firstObject[] tailMap<Object,Map<>> accnew LinkedHashMap<Object,Map<>>(...)Entry<Object,List<>> itemMap<>.Entry<Object,List<>>/** Sorts all array members into (sub)groups determined by the supplied ... */new ArrayIterable<Object>(...)/** Sorts all collection members into groups determined by the supplied mapping ... */countBy(...)/** Sorts all array members into groups determined by the supplied mapping ... *//** Sorts all iterator items into groups determined by the supplied mapping ... */Map<K,Integer> answernew LinkedHashMap<K,Integer>(...)countAnswer(...)/** Groups all map entries into groups determined by the ... */Map<G,List<Entry<K,V>>> answernew LinkedHashMap<G,List<Entry<K,V>>>(...)G value/** Groups the members of a map into sub maps determined by the ... */Map<G,List<Entry<K,V>>> initialgroupEntriesBy(...)Map<G,Map<K,V>> answernew LinkedHashMap<G,Map<K,V>>(...)Entry<G,List<Entry<K,V>>> outerMap<>.Entry<G,List<Entry<K,V>>>G keyList<Entry<K,V>> entriesMap<K,V> target/** Groups the members of a map into sub maps determined by the supplied ... */Closure<Object> headMap<Object,Map<>> firstEntry<Object,Map<>> itemMap<>.Entry<Object,Map<>>/** Groups the members of a map into groups determined by the ... */Entry<U,V> entryMap<>.Entry<U,V>/** Groups the current element according to the value ... */List<T> groupedElementsnew Function<K,List<T>>(...) { ... }Integer current// internal helper method/** Performs the same function as the version of inject that takes an initial value, but ... */T headCollection<T> tailtail(...)inject(...)/** Iterates through the given Collection, passing in the initial value to ... *//** Iterates through the given Map, passing in the initial value to ... *//** Iterates through the given Iterator, passing in the initial value to ... */Object[] params/** Iterates through the given Object, passing in the first value to ... */Object initialValue/** Iterates through the given Object, passing in the initial value to ... *//** Iterates through the given array as with inject(Object[],initialValue,closure), but ... *//** Iterates through the given array, passing in the initial value to ... *//** Sums the items in an Iterable. This is equivalent to invoking the ... *//** Sums the items in an array. This is equivalent to invoking the ... */new ArrayIterator<Object>(...)/** Sums the items from an Iterator. This is equivalent to invoking the ... *//** Sums the items in an array. ... *//** Sums the items in an Iterable, adding the result to some initial value. ... *//** Sums the items in an array, adding the result to some initial value. ... *//** Sums the items from an Iterator, adding the result to some initial value. This is ... */Object[] parambyte sbyte vshort sshort vint vlong slong vchar schar vfloat sfloat vdouble sdouble v/** Sums the result of applying a closure to each item of an Iterable. ... *//** Sums the result of applying a closure to each item of an array. ... *//** Sums the result of applying a closure to each item returned from an iterator. ... *//** Sums the result of applying a closure to each item of an Iterable to some initial value. ... *//** Sums the result of applying a closure to each item of an array to some initial value. ... *//** Sums the result of applying a closure to each item of an Iterator to some initial value. ... */Object[] closureParamObject[] plusParam/** Averages the items in an Iterable. This is equivalent to invoking the ... */average(...)/** Averages the items in an array. This is equivalent to invoking the ... *//** Averages the items from an Iterator. This is equivalent to invoking the ... */long count/** Calculates the average of the bytes in the array. ... *//** Calculates the average of the shorts in the array. ... *//** Calculates the average of the ints in the array. ... *//** Calculates the average of the longs in the array. ... *//** Calculates the average of the floats in the array. ... *//** Calculates the average of the doubles in the array. ... *//** Averages the result of applying a closure to each item of an Iterable. ... *//** Averages the result of applying a closure to each item of an array. ... *//** Averages the result of applying a closure to each item returned from an iterator. ... *//** Concatenates the <code>toString()</code> representation of each ... *//** Concatenates the string representation of each ... */new BooleanArrayIterator(...)new ByteArrayIterator(...)new CharArrayIterator(...)new DoubleArrayIterator(...)new FloatArrayIterator(...)new IntArrayIterator(...)new LongArrayIterator(...)new ShortArrayIterator(...)/** Adds min() method to Collection objects. ... *//** Adds min() method to Iterator objects. The iterator will become ... */T answer/** Adds min() method to Object arrays. ... *//** Adds min() method to int arrays. ... */int answer/** Adds min() method to long arrays. ... */long value/** Adds min() method to double arrays. ... */double answerdouble value/** Selects the minimum value found in the Iterable using the given comparator. ... *//** Selects the minimum value found from the Iterator using the given comparator. ... *//** Selects the minimum value found from the Object array using the given comparator. ... *//** Selects the item in the iterable which when passed as a parameter to the supplied closure returns the ... *//** Selects an entry in the map having the minimum ... *//** Selects an entry in the map having the maximum ... *//** Selects the minimum value found from the Iterator ... */Object answerValue/** Selects the minimum value found from the Object array ... *//** Adds max() method to Iterable objects. ... *//** Adds max() method to Iterator objects. The iterator will become ... *//** Adds max() method to Object arrays. ... *//** Adds max() method to int arrays. ... *//** Adds max() method to long arrays. ... *//** Adds max() method to double arrays. ... *//** Selects the maximum value found from the Iterator ... *//** Selects the maximum value found from the Object array ... *//** Selects the maximum value found in the Iterable using the given comparator. ... *//** Selects the maximum value found from the Iterator using the given comparator. ... *//** Selects the maximum value found from the Object array using the given comparator. ... *//** Returns indices of the collection. ... *//** Returns indices of the array. ... *//** Returns indices of the boolean array. ... *//** Returns indices of the byte array. ... *//** Returns indices of the char array. ... *//** Returns indices of the double array. ... *//** Returns indices of the float array. ... *//** Returns indices of the int array. ... *//** Returns indices of the long array. ... *//** Returns indices of the short array. ... *//** Provide the standard Groovy <code>size()</code> method for <code>Iterator</code>. ... *//** Provide the standard Groovy <code>size()</code> method for <code>Iterable</code>. ... *//** Provide the standard Groovy <code>size()</code> method for an array. ... *//** Check whether an <code>Iterable</code> has elements ... *//** Support the range subscript operator for a List. ... */RangeInfo infoList<T> subListinfo.frominfo.tocreateSimilarList(...)info.reverse/** Select a List of items from an eager or lazy List using a Collection to ... */isLazyDefaultValues(...)getInitClosure(...)/** Support the range subscript operator for an eager or lazy List. ... *//** Select a List of items from a List using a Collection to ... *//** Select a List of items from an array using a Collection to ... */getAtImpl(...)/** Creates a sub-Map containing the given keys. This method is similar to ... */keys.length/** Looks up an item in a Map for the given key and returns the corresponding value. ... *//** Support the range subscript operator for an Array ... *//** Allows conversion of arrays into a mutable List. ... *//** Support the subscript operator for a List. ... *//** Support subscript operator for list access. *//** Support the subscript operator for an Iterator. The iterator ... */int adjustedIndex/** Support the subscript operator for an Iterable. Typical usage: ... *//** A helper method to allow lists to work with subscript operators. ... *//** Support subscript operator for list modification. */putAt(...)List<> sublistCollection<> col/** List subscript assignment operator when given a range as the index and ... */resizeListWithRangeAndGetSublist(...)/** List subscript assignment operator when given a range as the index. ... */Object firstIterator<?> valuesIterObject index// todo: remove after putAt(Splice) gets deletedint leftint rightboolean emptyRange/** Support the subscript operator for a Map. ... *//** Returns a new <code>Map</code> containing all entries from <code>left</code> and <code>right</code>, ... */cloneSimilarMap(...)/** A helper method to allow maps to work with subscript operators ... *//** Support the subscript operator for Collection. ... */List<Object> answergetAtIterable(...)MissingPropertyExceptionNoStack mpeString causeString/** A convenience method for creating an immutable Map. ... */asUnmodifiable(...)/** A convenience method for creating an immutable SortedMap. ... */new TreeMap<K,V>(...)/** A convenience method for creating an immutable List. ... *//** A convenience method for creating an immutable Set. ... *//** A convenience method for creating an immutable SortedSet. ... *//** A convenience method for creating an immutable Collection. ... *//** Creates an unmodifiable view of a Map. ... *//** Creates an unmodifiable view of a SortedMap. ... */unmodifiableSortedMap(...)/** Creates an unmodifiable view of a List. ... *//** Creates an unmodifiable view of a Set. ... *//** Creates an unmodifiable view of a SortedSet. ... */unmodifiableSortedSet(...)/** Creates an unmodifiable view of a Collection. ... *//** A convenience method for creating a synchronized Map. ... */synchronizedMap(...)/** A convenience method for creating a synchronized SortedMap. ... */synchronizedSortedMap(...)/** A convenience method for creating a synchronized Collection. ... */synchronizedCollection(...)/** A convenience method for creating a synchronized List. ... */synchronizedList(...)/** A convenience method for creating a synchronized Set. ... */synchronizedSet(...)/** A convenience method for creating a synchronized SortedSet. ... */synchronizedSortedSet(...)/** Synonym for {@link #toSpreadMap(java.util.Map)}. ... */toSpreadMap(...)/** Returns a new <code>SpreadMap</code> from this map. ... */new SpreadMap(...)/** Creates a spreadable map from this array. ... *//** Creates a spreadable map from this list. ... *//** Creates a spreadable map from this iterable. ... *//** Wraps a map using the decorator pattern with a wrapper that intercepts all calls ... *//** An alias for <code>withLazyDefault</code> which decorates a list allowing ... */withLazyDefault(...)withDefault(...)/** Decorates a list allowing it to grow when called with a non-existent index value. ... *//** Zips an Iterable with indices in (value, index) order. ... */withIndex(...)/** Zips an Iterable with indices in (index, value) order. ... */indexed(...)Map<Integer,E> resultnew LinkedHashMap<Integer,E>(...)Iterator<Tuple2<Integer,E>> indexedTuple2<Integer,E> next/** Zips an int[] with indices in (index, value) order starting from index 0. ... *//** Zips an int[] with indices in (index, value) order. ... */new IntArrayIterable(...)/** Zips a long[] with indices in (index, value) order starting from index 0. ... *//** Zips a long[] with indices in (index, value) order. ... */new LongArrayIterable(...)/** Zips a double[] with indices in (index, value) order starting from index 0. ... *//** Zips a double[] with indices in (index, value) order. ... */new DoubleArrayIterable(...)/** Zips an iterator with indices in (value, index) order. ... *//** Zips an iterator with indices in (index, value) order. ... */new ZipPostIterator<E>(...)new ZipPreIterator<E>(...)new Tuple2<E,Integer>(...)new Tuple2<Integer,E>(...)/** Sorts the Collection. Assumes that the collection items are comparable ... *//** Sorts the Iterable. Assumes that the Iterable items are ... *//** Sorts the elements from the given map into a new ordered map using ... */Map<K,V> result/** Sorts the elements from the given map into a new ordered Map using ... *//** Modifies this array so that its elements are in sorted order. ... *//** Sorts the given array into sorted order. ... */T[] answer/** Sorts the given iterator items into a sorted iterator. The items are ... *//** Sorts the given iterator items into a sorted iterator using the comparator. The ... *//** Sorts the Iterable using the given Comparator. If the Iterable is a List and mutate ... *//** Sorts the given array into sorted order using the given comparator. ... *//** Modifies this array so that its elements are in sorted order as determined by the given comparator. ... *//** Sorts the given iterator items into a sorted iterator using the Closure to determine the correct ordering. ... *//** Sorts the elements from this array into a newly created array using ... *//** Modifies this array so that its elements are in sorted order using the Closure to determine the correct ordering. ... */Comparator<T> c/** Sorts this Iterable using the given Closure to determine the correct ordering. If the Iterable is a List, ... *//** Sorts this Iterable using the given Closure to determine the correct ordering. If the Iterable is a List ... *//** Avoids doing unnecessary work when sorting an already sorted set (i.e. an identity function for an already sorted set). ... *//** Avoids doing unnecessary work when sorting an already sorted map (i.e. an identity function for an already sorted map). ... *//** Sorts the Iterable. Assumes that the Iterable elements are ... */toSorted(...)/** Sorts the Iterable using the given Comparator. The elements are first placed ... *//** Sorts this Iterable using the given Closure to determine the correct ordering. The elements are first placed ... *//** Sorts the Iterator. Assumes that the Iterator elements are ... *//** Sorts the given iterator items using the comparator. The ... *//** Returns a sorted version of the given array using the supplied comparator. ... *//** Returns a sorted version of the given array using the supplied comparator to determine the resulting order. ... */new NumberAwareValueComparator<K,V>(...)new NumberAwareComparator<V>(...)Comparator<V> delegate;List<Entry<K,V>> sortedEntriesComparator<Entry<K,V>> comparatornew OrderBy<Entry<K,V>>(...)new ClosureComparator<Entry<K,V>>(...)/** Avoids doing unnecessary work when sorting an already sorted set ... *//** Avoids doing unnecessary work when sorting an already sorted map ... *//** Removes the initial item from the List. ... *//** Removes the last item from the List. ... *//** Provides an easy way to append multiple Map.Entry values to a Map. ... */Map<>.Entry<? extends K,? extends V>Entry<? extends K,? extends V> entry/** Returns a new <code>Map</code> containing all entries from <code>self</code> and <code>entries</code>, ... *//** Prepends an item to the start of the List. ... *//** An optimized version of {@link #last(List)}. ... *//** Returns the last item from the List. ... *//** Returns the last item from the Iterable. ... */Iterator<T> iterator/** Returns the last item from the array. ... *//** Returns the first item from the List. ... *//** Returns the first item from the Iterable. ... *//** Returns the first item from the array. ... */first(...)/** Returns the first item from the Object array. ... *//** Returns the items from the List excluding the first item. ... *//** Returns the items from the SortedSet excluding the first item. ... *//** Calculates the tail values of this Iterable: the first value will be this list of all items from the iterable and the final one will be an empty list, with the intervening values the results of successive applications of tail on the items. ... */tails(...)/** Returns the items from the Iterable excluding the first item. ... *//** Returns the items from the array excluding the first item. ... *//** Returns the original iterator after throwing away the first element. ... *//** Calculates the init values of this Iterable: the first value will be this list of all items from the iterable and the final one will be an empty list, with the intervening values the results of successive applications of init on the items. ... */inits(...)/** Returns the items from the Iterable excluding the last item. Leaves the original Iterable unchanged. ... */Collection<T> selfCol/** Returns the items from the List excluding the last item. Leaves the original List unchanged. ... *//** Returns the items from the SortedSet excluding the last item. Leaves the original SortedSet unchanged. ... *//** Returns an Iterator containing all of the items from this iterator except the last one. ... */new InitIterator<T>(...)/** Returns the items from the Object array excluding the last item. ... *//** Returns the first <code>num</code> elements from the head of this List. ... */take(...)/** Returns the first <code>num</code> elements from the head of this SortedSet. ... *//** Returns the first <code>num</code> elements from the head of this array. ... */T[] ret/** Returns the first <code>num</code> elements from the head of this Iterable. ... *//** Adds all items from the iterator to the Collection. ... *//** Adds all items from the iterable to the Collection. ... *//** Returns a new map containing the first <code>num</code> elements from the head of this map. ... */Map<K,V> ret/** Returns an iterator of up to the first <code>num</code> elements from this iterator. ... */new TakeIterator<T>(...)Integer num;this.num/** Returns the last <code>num</code> elements from the tail of this array. ... *//** Returns the last <code>num</code> elements from the tail of this Iterable. ... */Collection<T> ret/** Returns the last <code>num</code> elements from the tail of this List. ... */takeRight(...)/** Returns the last <code>num</code> elements from the tail of this SortedSet. ... *//** Drops the given number of elements from the head of this List. ... */drop(...)/** Drops the given number of elements from the head of this Iterable. ... *//** Drops the given number of elements from the head of this array ... *//** Drops the given number of key/value pairs from the head of this map if they are available. ... *//** Drops the given number of elements from the head of this iterator if they are available. ... *//** Drops the given number of elements from the tail of this SortedSet. ... */dropRight(...)/** Drops the given number of elements from the tail of this List. ... *//** Drops the given number of elements from the tail of this Iterable. ... *//** Drops the given number of elements from the tail of this Iterator. ... */new DropRightIterator<T>(...)LinkedList<E> discards;int num;new LinkedList<E>(...)/** Drops the given number of elements from the tail of this array ... *//** Returns the longest prefix of this list where each element ... */int num/** Returns a Collection containing the longest prefix of the elements from this Iterable ... */takeWhile(...)/** Returns the longest prefix of this SortedSet where each element ... *//** Returns the longest prefix of this Map where each entry (or key/value pair) when ... *//** Returns the longest prefix of this array where each element ... *//** Returns the longest prefix of elements in this iterator where ... */new TakeWhileIterator<T>(...)BooleanClosureWrapper condition;this.condition/** Returns a suffix of this SortedSet where elements are dropped from the front ... */dropWhile(...)/** Returns a suffix of this List where elements are dropped from the front ... *//** Returns a suffix of this Iterable where elements are dropped from the front ... *//** Create a suffix of the given Map by dropping as many entries as possible from the ... */boolean dropping/** Create a suffix of the given array by dropping as many elements as possible from the ... *//** Creates an Iterator that returns a suffix of the elements from an original Iterator. As many elements ... */new DropWhileIterator<T>(...)Closure<> condition;boolean buffering;E buffer;prepare(...)/** Converts this Iterable to a Collection. Returns the original Iterable ... *//** Converts this Iterable to a List. Returns the original Iterable ... *//** Coerce an object instance to a boolean value. ... *//** Coerce a Boolean instance to a boolean value. ... *//** Coerce an AtomicBoolean instance to a boolean value. ... *//** Coerce a collection instance to a boolean value. ... *//** Coerce a map instance to a boolean value. ... *//** Coerce an iterator instance to a boolean value. ... *//** Coerce an enumeration instance to a boolean value. ... *//** Coerce an Object array to a boolean value. ... *//** Coerces a byte array to a boolean value. ... *//** Coerces a short array to a boolean value. ... *//** Coerces an int array to a boolean value. ... *//** Coerces a long array to a boolean value. ... *//** Coerces a float array to a boolean value. ... *//** Coerces a double array to a boolean value. ... *//** Coerces a boolean array to a boolean value. ... *//** Coerces a char array to a boolean value. ... *//** Coerce a character to a boolean value. ... *//** Coerce a Float instance to a boolean value. ... */float fisNaN(...)/** Coerce a Double instance to a boolean value. ... */double d/** Coerce a number to a boolean value. ... *//** Converts the given iterable to another type. ... *//** Converts the given collection to another type. A default concrete ... */Queue<>.classStack<>.classasArrayType(...)GroovyCastException eCollection<> result/** Converts the given array to either a List, Set, or ... *//** Coerces the closure to an implementation of the given class. The class ... */Method samGroovyCastException gce/** Coerces this map to the given type, using the map's keys as the public ... */new ConvertedMap(...)GroovyCastException ceGroovyRuntimeException cause/** Randomly reorders the elements of the specified list. ... */shuffle(...)/** Randomly reorders the elements of the specified list using the ... *//** Creates a new list containing the elements of the specified list ... *//** Creates a new list containing the elements of the specified list but in a random ... *//** Randomly reorders the elements of the specified array. ... */Random rndnew Random(...)Random r;/** Randomly reorders the elements of the specified array using the ... */int nextIndexnextInt(...)T tmp/** Creates a new array containing the elements of the specified array but in a random order. ... */shuffled(...)/** Creates a new array containing the elements of the specified array but in a random ... */T[] resultList<T> items/** Creates a view list with reversed order, and the order of original list will not change. ... */new ReversedList<T>(...)/** Creates a new List with the identical contents to this list ... *//** Reverses the elements in a list. If mutate is true, the original list is modified in place and returned. ... */ListIterator<T> iter/** Creates a new array containing items which are the same as this array but in reverse order. ... *//** Reverse the items in an array. If mutate is true, the original array is modified in place and returned. ... *//** Reverses the iterator. The original iterator will become ... *//** Create an array as a union of two arrays. ... */left.lengthright.lengthT[] temptemp.length/** Create an array containing elements from an original array plus an additional appended element. ... *//** Create an array containing elements from an original array plus those from a Collection. ... */Class<?> leftTypeObject t/** Create an array containing elements from an original array plus those from an Iterable. ... *//** Create an Object array as a union of two arrays. ... *//** Create an Object array containing elements from an original array plus an additional appended element. ... *//** Create an object array containing elements from an original array plus those from a Collection. ... *//** Create an Object array containing elements from an original array plus those from an Iterable. ... *//** Create a Collection as a union of two collections. If the left collection ... */cloneSimilarCollection(...)/** Create a Collection as a union of two iterables. If the left iterable ... *//** Create a Collection as a union of a Collection and an Iterable. If the left collection ... *//** Create a List as a union of a List and an Iterable. ... *//** Create a List as a union of a List and a Collection. ... *//** Create a Set as a union of a Set and an Iterable. ... *//** Create a Set as a union of a Set and a Collection. ... *//** Create a SortedSet as a union of a SortedSet and an Iterable. ... *//** Create a SortedSet as a union of a SortedSet and a Collection. ... *//** Creates a new List by inserting all of the elements in the specified array ... *//** Creates a new List by inserting all of the elements in the given additions List ... *//** Creates a new List by inserting all of the elements in the given Iterable ... *//** Create a collection as a union of a Collection and an Object. If the collection ... *//** Create a collection as a union of an Iterable and an Object. If the iterable ... *//** Create a List as a union of a List and an Object. ... *//** Create a Set as a union of a Set and an Object. ... *//** Create a SortedSet as a union of a SortedSet and an Object. ... *//** Create a Collection composed of the elements of this Iterable, repeated ... *//** Create a List composed of the elements of this Iterable, repeated ... *//** Create a Collection composed of the intersection of both collections.  Any ... */intersect(...)Collection<T> compareWith/** Create a Collection composed of the intersection of both iterables.  Any ... *//** Create a Collection composed of the intersection of both iterables. ... *//** Create a List composed of the intersection of a List and an Iterable.  Any ... *//** Create a Set composed of the intersection of a Set and an Iterable.  Any ... *//** Create a SortedSet composed of the intersection of a SortedSet and an Iterable.  Any ... *//** Create a Map composed of the intersection of both maps. ... */Map<K,V> ansMapEntry<K,V> e1Entry<K,V> e2/** Returns <code>true</code> if the intersection of two iterables is empty. ... */Collection<> leftColCollection<> rightCol/** Chops the array into pieces, returning lists with sizes corresponding to the supplied chop sizes. ... */chop(...)/** Chops the Iterable into pieces, returning lists with sizes corresponding to the supplied chop sizes. ... *//** Chops the iterator items into pieces, returning lists with sizes corresponding to the supplied chop sizes. ... */int nextSize/** Compare the contents of this array to the contents of the given array. ... *//** Determines if the contents of this array are equal to the ... *//** Determines if the contents of this list are equal to the ... */Object o2/** Compare the contents of two Lists.  Order matters. ... */Iterator<> it1Iterator<> it2/** Compare the contents of two Sets for equality using Groovy's coercion rules. ... */Iterator<T> it1Collection<T> otherItemsnew HashSet<T>(...)Iterator<T> it2T foundItemT o2/** Compares two Maps treating coerced numerical values as identical. ... *//** Create a Set composed of the elements of the first Set minus the ... */Comparator<> comparatorcomparator(...)Set<T> ansSetcreateSimilarSet(...)T o1boolean areEqual/** Create a Set composed of the elements of the first Set minus the given element. ... *//** Create a SortedSet composed of the elements of the first SortedSet minus the ... *//** Create a SortedSet composed of the elements of the first SortedSet minus the given element. ... *//** Create a new array composed of the elements of the first array minus the ... */Collection<T> tempremoveMe.length/** Create a List composed of the elements of the first list minus ... *//** Create a new Collection composed of the elements of the first Collection minus ... *//** Create a new List composed of the elements of the first List minus ... *//** Create a new Collection composed of the elements of the first Iterable minus ... */Collection<T> self1Collection<?> removeMe1Collection<T> ansCollectionboolean nlgnSortsameType(...)new Collection<>[]Set<T> answerObject t2T oList<T> tmpAnswernew LinkedList<T>(...)boolean elementRemovedIterator<?> iteratorObject elt/** Create a new List composed of the elements of the first List minus every occurrence of the ... *//** Create a new Collection composed of the elements of the first Iterable minus every occurrence of the ... */Collection<T> ansList/** Create a new array composed of the elements of the given array minus every occurrence the given object. ... *//** Create a Map composed of the entries of the first map minus the ... */Object e2/** Flatten a Collection. This Collection and any nested arrays or ... *//** Flatten an Iterable. This Iterable and any nested arrays or ... *//** Flatten a List. This List and any nested arrays or ... *//** Flatten a Set. This Set and any nested arrays or ... *//** Flatten a SortedSet. This SortedSet and any nested arrays or ... *//** Flatten an array. This array and any nested arrays or ... */arrayAsCollection(...)T flattenedboolean returnedSelfList<?> list/** Overloads the left shift operator to provide an easy way to append ... *//** Overloads the left shift operator to provide an easy way to put ... *//** Implementation of the left shift operator for integral types.  Non integral ... *//** Implementation of the right shift operator for integral types.  Non integral ... *//** Implementation of the right shift (unsigned) operator for integral types.  Non integral ... *//** Support the subscript operator with a range for a byte array ... */// Primitive type array methodsprimitiveArrayGet(...)/** Support the subscript operator with a range for a char array ... *//** Support the subscript operator with a range for a short array ... *//** Support the subscript operator with a range for an int array ... *//** Support the subscript operator with a range for a long array ... *//** Support the subscript operator with a range for a float array ... *//** Support the subscript operator with a range for a double array ... *//** Support the subscript operator with a range for a boolean array ... *//** Support the subscript operator with an IntRange for a byte array ... */List<Byte> answersubListRange(...)/** Support the subscript operator with an IntRange for a char array ... */List<Character> answer/** Support the subscript operator with an IntRange for a short array ... */List<Short> answer/** Support the subscript operator with an IntRange for an int array ... */List<Integer> answer/** Support the subscript operator with an IntRange for a long array ... */List<Long> answer/** Support the subscript operator with an IntRange for a float array ... */List<Float> answer/** Support the subscript operator with an IntRange for a double array ... */List<Double> answer/** Support the subscript operator with an IntRange for a boolean array ... */List<Boolean> answer/** Support the subscript operator with an ObjectRange for a byte array ... *//** Support the subscript operator with an ObjectRange for a char array ... *//** Support the subscript operator with an ObjectRange for a short array ... *//** Support the subscript operator with an ObjectRange for an int array ... *//** Support the subscript operator with an ObjectRange for a long array ... *//** Support the subscript operator with an ObjectRange for a float array ... *//** Support the subscript operator with an ObjectRange for a double array ... *//** Support the subscript operator with a collection for a byte array ... *//** Support the subscript operator with a collection for a char array ... *//** Support the subscript operator with a collection for a short array ... *//** Support the subscript operator with a collection for an int array ... *//** Support the subscript operator with a collection for a long array ... *//** Support the subscript operator with a collection for a float array ... *//** Support the subscript operator with a collection for a double array ... *//** Support the subscript operator with a collection for a boolean array ... *//** Support the subscript operator for a Bitset ... *//** Support retrieving a subset of a BitSet using a Range ... */BitSet resultnew BitSet(...)int numberOfBitsint adjuster/** Support assigning a range of values with a single assignment statement. ... *//** Support subscript-style assignment for a BitSet. ... *//** Allows arrays to behave similar to collections. ... *//** Converts this array to a List of the same size, with each element ... */primitiveArrayToList(...)/** Converts this array to a Set, with each unique element ... *//** Convert a Collection to a Set. Always returns a new Set ... *//** Convert an Iterable to a Set. Always returns a new Set ... *//** Convert an iterator to a Set. The iterator will become ... *//** Convert an enumeration to a Set. ... *//** Implements the getAt(int) method for primitive type arrays. ... *//** Implements the getAt(Range) method for primitive type arrays. ... *//** Implements the getAt(Collection) method for primitive type arrays.  Each ... *//** Implements the setAt(int idx) method for primitive type arrays. ... *//** Identity conversion which returns Boolean.TRUE for a true Boolean and Boolean.FALSE for a false Boolean. ... *//** Checks whether the array contains the given value. ... */long nextshort nextchar nextboolean nextdouble nextfloat nextbyte next/** Returns the string representation of the given array. ... *//** Returns the string representation of the given map. ... */toMapString(...)/** Returns the string representation of this map.  The string displays the ... *//** Returns the string representation of the given collection.  The string ... */toListString(...)/** Returns the string representation of the given list.  The string ... *//** Returns the string representation of this array's contents. ... *//** Returns the string representation of the given array.  The string ... *//** Create a String representation of this object. ... *//** Increment a Character by one. ... */// Number based methods/** Increment a Number by one. ... *//** Decrement a Character by one. ... *//** Decrement a Number by one. ... *//** Add a Character and a Number. The ordinal value of the Character ... *//** Add a Number and a Character.  The ordinal value of the Character ... *//** Add one Character to another. The ordinal values of the Characters ... *//** Appends a String to the literal of the Map instance. ... *//** Appends a GString to the literal of the Map instance. ... *//** Compare a Character and a Number. The ordinal value of the Character ... *//** Compare a Number and a Character. The ordinal value of the Character ... *//** Compare two Characters. The ordinal values of the Characters ... *//** Compare two Numbers.  Equality (==) for numbers dispatches to this. ... *//** Subtract a Number from a Character. The ordinal value of the Character ... *//** Subtract a Character from a Number. The ordinal value of the Character ... *//** Subtract one Character from another. The ordinal values of the Characters ... *//** Multiply a Character by a Number. The ordinal value of the Character ... *//** Multiply a Number by a Character. The ordinal value of the Character ... *//** Multiply two Characters. The ordinal values of the Characters ... *//** Multiply a BigDecimal and a Double. ... *//** Multiply a BigDecimal and a BigInteger. ... *//** Compare a BigDecimal to another. ... *//** Compare a BigDecimal to a String representing a number. ... *//** Power of a Number to a certain exponent. Called by the '**' operator. ... */double basedouble exppow(...)/** Power of a BigDecimal to an integer certain exponent. If the ... *//** Power of a BigInteger to an integer certain exponent. If the ... *//** Power of an integer to an integer certain exponent. If the ... */BigInteger answer/** Power of a long to an integer certain exponent. If the ... *//** Power of a BigInteger to a BigInteger certain exponent. Called by the '**' operator. ... *//** Divide a Character by a Number. The ordinal value of the Character ... */div(...)/** Divide a Number by a Character. The ordinal value of the Character ... *//** Divide one Character by another. The ordinal values of the Characters ... *//** Integer Divide a Character by a Number. The ordinal value of the Character ... *//** Integer Divide a Number by a Character. The ordinal value of the Character ... *//** Integer Divide two Characters. The ordinal values of the Characters ... *//** Integer Divide two Numbers. ... *//** Bitwise OR together two numbers. ... *//** Bitwise AND together two Numbers. ... *//** Bitwise AND together two BitSets. ... *//** Bitwise XOR together two BitSets.  Called when the '^' operator is used ... *//** Bitwise NEGATE a BitSet. ... */flip(...)/** Bitwise NEGATE a Number. ... *//** Bitwise OR together two BitSets.  Called when the '|' operator is used ... *//** Bitwise XOR together two Numbers.  Called when the '^' operator is used. ... *//** Performs a division modulus operation.  Called by the '%' operator. ... */mod(...)/** Negates the number.  Equivalent to the '-' operator when it preceeds ... */unaryMinus(...)/** Returns the number, effectively being a noop for numbers. ... */unaryPlus(...)/** Executes the closure this many times, starting from zero.  The current ... *//** Iterates from this number up to the given number, inclusive, ... */int self1int to1long to1float to1float idouble to1double iBigDecimal oneBigDecimal self1BigDecimal to1BigDecimal iBigInteger oneBigInteger to1BigInteger i/** Iterates from this number down to the given number, inclusive, ... */BigDecimal selfD/** Iterates from this number up to the given number using a step increment. ... */BigDecimal zeroBigDecimal stepNumber1BigInteger zeroBigInteger self1BigInteger stepNumber1int stepNumber1//those classes implement a method with a better exact match.//Note: This method is NOT called if number is a BigInteger or BigDecimal because/** Get the absolute value ... *//** Compares this object against the specified object returning the same result ... *//** Round the value ... */round(...)floor(...)/** Truncate the value ... */double pdouble nceil(...)import NumberRangeimport Closeableimport PriorityQueueimport Vectorimport WeakHashMapimport ArrayBlockingQueueimport ConcurrentSkipListMapimport ConcurrentSkipListSetimport CopyOnWriteArrayListimport CopyOnWriteArraySetimport DelayQueueimport LinkedBlockingDequeimport LinkedBlockingQueueimport PriorityBlockingQueueimport SynchronousQueue/** Support methods for DefaultGroovyMethods and PluginDefaultMethods. */setScale(...)RoundingMode.HALF_UPDefaultGroovyMethodsSupport.classtrunc(...)/** Determine if a Character is uppercase. ... *//** Determine if a Character is lowercase. ... *//** Determines if a character is a letter. ... */isLetter(...)/** Determines if a character is a digit. ... */isDigit(...)/** Determines if a character is a letter or digit. ... */isLetterOrDigit(...)/** Determines if a character is a whitespace character. ... */isWhitespace(...)/** Converts the character to uppercase. ... *//** Converts the character to lowercase. ... *//** Transform a Number into an Integer ... *//** Transform a Number into a Long ... *//** Transform a Number into a Float ... *//** Transform a Number into a Double ... *//** Transform a Number into a BigDecimal ... *//** Transform this number to a the given type, using the 'as' operator.  The ... *//** Transform this Number into a BigInteger. ... *//** Logical conjunction of two boolean operators. ... */// Boolean based methods/** Logical disjunction of two boolean operators ... *//** Logical implication of two boolean operators ... *//** Exclusive disjunction of two boolean operators ... *//** Allows a simple syntax for using timers. This timer will execute the ... *///        return Boolean.valueOf(!left.booleanValue());//    public static Boolean negate(Boolean left) {TimerTask timerTasknew TimerTask(...) { ... }DefaultGroovyMethods$1schedule(...)/** Traverse through each byte of this Byte array. Alias for each. ... *//** Traverse through each byte of this byte array. Alias for each. ... *//** Iterates over the elements of an aggregate of items and returns ... */findIndexOf(...)/** Iterates over the elements of an aggregate of items, starting from a ... *//** Iterates over the elements of an Iterator and returns the index of the first item that satisfies the ... *//** Iterates over the elements of an Iterator, starting from a ... */// helper method for getAt and putAt/** Iterates over the elements of an Iterable and returns the index of the first item that satisfies the ... *//** Iterates over the elements of an Iterable, starting from a ... *//** Iterates over the elements of an Array and returns the index of the first item that satisfies the ... *//** Iterates over the elements of an Array, starting from a ... */findLastIndexOf(...)/** Iterates over the elements of an aggregate of items, starting ... *//** Iterates over the elements of an Iterator and returns ... *//** Iterates over the elements of an Iterator, starting ... *//** Iterates over the elements of an Iterable and returns ... *//** Iterates over the elements of an Iterable, starting ... */boolean reverseint tmp/** Iterates over the elements of an Array and returns ... *//** Iterates over the elements of an Array, starting ... */findIndexValues(...)/** Iterates over the elements of an aggregate of items, starting from ... *//** Iterates over the elements of an Iterator, starting from ... */List<Number> resultnew ArrayList<Number>(...)// Helper method for primitive array getAtboolean inclusiveLeftgetInclusiveLeft(...)boolean inclusiveRight/** This converts a possibly negative index to a real index into the array. ... *//** Close the Closeable. Logging a warning if any problems occur. ... */tryClose(...)/** Attempts to close the closeable returning rather than throwing ... */Throwable thrownwarning(...)/** Close the Closeable. Ignore any problems that might occur. ... */long startCountcloneObject(...)/** Iterates over the elements of an Iterable, starting from ... *//** Iterates over the elements of an Array, starting from ... *//** Iterates through the classloader parents until it finds a loader with a class ... */isRootLoaderClassOrSubClass(...)Class<> currentRootLoader.class/** Converts a given object to a type. This method is used through ... */createSimilarQueue(...)Object mixedIncastToMixedType(...)Collection<> listClass<> elementTypeObject arraysetBoolean(...)invokeAsType(...)setByte(...)setChar(...)setDouble(...)setFloat(...)setInt(...)setLong(...)setShort(...)Class<?> target/** Convenience method to dynamically create a new instance of this ... *//** Helper to construct a new instance from the given arguments. ... *//** Adds a "metaClass" property to all class objects so you can use the syntax ... */new HandleMetaClass(...)/** Obtains a MetaClass for an object either from the registry or in the case of ... *//** Sets the metaclass for a given class. ... */removeMetaClass(...)NullObject.classgetNullObject(...)/** Sets the metaclass for an object. ... */new Stack<T>(...)/** Sets the metaclass for a {@code GroovyObject}. ... */disablePrimitiveOptimization(...)Field sdyn/** Sets/updates the metaclass for a given class to a closure. ... *//** Sets/updates the metaclass for a given object to a closure. ... */MetaClass emchasPerInstanceMetaClass(...)ExpandoMetaClass metaClassnew Vector<T>(...)new CopyOnWriteArrayList<T>(...)/** Attempts to create an Iterator for the given object by first ... *//** Allows an Enumeration to behave like an Iterator.  Note that the ... */new Iterator<T>(...) { ... }DefaultGroovyMethods$2/** An identity function for iterators, supporting 'duck-typing' when trying to get an ... *//** Returns a <code>BufferedIterator</code> that allows examining the next element without ... */new IteratorBufferedIterator<T>(...)new ListBufferedIterator<T>(...)/** Dynamically wraps an instance into something which implements the ... *//** Swaps two elements at the specified positions. ... */boolean tmpbyte tmpnew ConcurrentSkipListSet<T>(...)char tmpdouble tmpfloat tmplong tmpshort tmp/** Modifies this list by removing the element at the specified position ... *//** Modifies this collection by removing a single instance of the specified ... *//** Get runtime groovydoc ... */Groovydoc groovydocAnnotation/** Get the detail information of {@link Throwable} instance's stack trace ... */StringBuilderWriter swnew CopyOnWriteArraySet<T>(...)/* registered extensions: ... */ArrayBlockingQueue<> queuenew ArrayBlockingQueue<T>(...)// TODO a future Groovy version should perform the accessible check not as a privileged action// we won't get here if we are a PrintWriter// TODO: Should we have some unified function like PrintWriter.checkError()?remainingCapacity(...)new ArrayDeque<T>(...)new ConcurrentLinkedQueue<T>(...)// use a comparator of one item or twonew DelayQueue<>(...)new LinkedBlockingDeque<T>(...)/* @ClosureParams(value=FromString.class, options="?,Integer") */new LinkedBlockingQueue<T>(...)new PriorityBlockingQueue<T>(...)new PriorityQueue<T>(...)new SynchronousQueue<T>(...)new ConcurrentSkipListMap<K,V>(...)// for b/c with Java return an int if we can// def (key, value) == list// def (key, value) == array.toList()// TODO: enforce stricter behavior?// given Map.Entry is an interface, we get a proxy which gives us lots// of flexibility but sometimes the error messages might be unexpectednew Hashtable<K,V>(...)new IdentityHashMap<K,V>(...)new WeakHashMap<K,V>(...)// Arrays.copyOfRange only since JDK 1.6// inject([:]) { a,e {@code ->} a {@code <<} [(e.key): e.value.groupBy(tail)] }// cast with explicit weaker generics for now to keep jdk6 happy, TODO: find better fix// trying to guess the concrete list type and create a new instance from it// if a positive index is accessed not initialized so far// initialization up to that index takes place// instead of using the SubList backed by the parent list, a new ArrayList instance is used// calculate whole list in this case// recommend avoiding -ve's as this is not as efficient/* = 0 *//* = null *//** Determines if all items of this array are of the same type. ... */List<> allClass<> baseClasswriteUTF16BomIfRequired(...)writeUtf16Bom(...)// support list[1..-1]// Undo inclusiveness effects done by subListBorders()// ignore result// fall back to creation// Do not use HashSet// Do not use HashMap// fall back to some defaults//trying to determine the base class of the collections//special case for Numbers// FE// FFimport ManagementFactoryimport ThreadInfoimport ThreadMXBeanimport Filesimport Pathimport ResourceBundle/** This class defines all the new static groovy methods which appear on normal ... *//** Start a Thread with the given closure as a Runnable instance. ... */createThread(...)/** Start a Thread with a given name and the given closure ... *//** Start a daemon Thread with the given closure as a Runnable instance. ... *//** Start a daemon Thread with a given name and the given closure as ... */setDaemon(...)/** Dump the thread dump of all threads ... */ThreadMXBean threadMxBeangetThreadMXBean(...)dumpAllThreads(...)new Function<ThreadInfo,String>(...) { ... }/** Get the last hidden matcher that the system used to do a match. ... */getLastMatcher(...)/** This method is used by both sleep() methods to implement sleeping ... */long startlong restlong currentboolean interruptedsleep(...)InterruptedException einterrupt(...)/** Sleep for so many milliseconds, even if interrupted. ... */sleepImpl(...)/** Sleep for so many milliseconds, using a given closure for interrupt processing. ... *//** Works exactly like ResourceBundle.getBundle(String).  This is needed ... */getBundle(...)getDefault(...)/** Works exactly like ResourceBundle.getBundle(String, Locale).  This is needed ... */ClassLoader targetCLcreateTempDir(...)createTempDirNio(...)Path tempPathcreateTempDirectory(...)toFile(...)/** Get the current time in seconds ... */// ignore, the constructor that takes a Collection as an argument may not exist// ignore, the no arg constructor might not exist.// compensate for closure's time// GROOVY-8243// more secure Files api doesn't support suffix, so just append it to the prefix// harmless race.import StringWriterIOExceptionimport ByteBufferimport MessageDigestimport static EncodingGroovyMethodsSupport.TRANSLATE_TABLEimport static EncodingGroovyMethodsSupport.TRANSLATE_TABLE_URLSAFE/** This class defines all the encoding/decoding groovy methods which enhance ... */...[] T_TABLE;...[] T_TABLE_URLSAFE;String CHUNK_SEPARATOR;String MD5;String SHA_256;/** Produce a Writable object which writes the Base64 encoding of the byte array. ... */encodeBase64(...)convertToByteArray(...)new Writable(...) { ... }EncodingGroovyMethods$1int charCountint dLimitdata.lengthchar[] tableint dIndexint d... >> ...//creates the collection to look for values./** Produce a Writable object which writes the Base64 URL and Filename Safe encoding of the byte array. ... */encodeBase64Url(...)/** Decode the String from Base64 into a byte array. ... */decodeBase64(...)/** Decodes a Base64 URL and Filename Safe encoded String into a byte array. ... */int byteShiftbyte[] tableint sixBitStandardCharsets.ISO_8859_1/** Produces a Writable that writes the hex encoding of the Byte[]. Calling ... */encodeHex(...)/** Produces a Writable that writes the hex encoding of the byte[]. Calling ... */EncodingGroovyMethods$2byte datumString hexString/** Decodes a hex string to a byte array. The hex string can contain either upper ... */new NumberFormatException(...)/** Calculate md5 of the CharSequence instance ... */digest(...)/** Calculate md5 of the byte array ... *//** Calculate SHA-256 of the CharSequence instance ... *//** Calculate SHA-256 of the byte array ... *//** digest the CharSequence instance ... *//** digest the byte array ... */MessageDigest mdupdate(...)wrap(...)// TODO: change this exception type// RFC 2045 says that I'm allowed to take the presence of// these characters as evidence of data corruption// So I will// convert byte into unsigned hex string// add leading zero if the length of the string is one// write hex string to writer// if string length is odd then throw exception/** Keep this constant in a separate file as it is troublesome for Antlr to parse for doc purposes. */...[] TRANSLATE_TABLE;...[] TRANSLATE_TABLE_URLSAFE;//           \t    \n                \r//     sp     !     "     #     $     %     &     '//      (     )     *     +     ,     -     .     ///      0     1     2     3     4     5     6     7//      8     9     :     ;     <     =     >     ?//      @     A     B     C     D     E     F     G//      H     I J K     L     M N     O//      P     Q     R     S     T     U     V     W//      X     Y     Z     [     \     ]     ^     _//      '     a     b     c     d     e     f     g//      h i     j     k     l     m     n     o//      p     q     r     s     t     u     v     w//      x     y     z/** Stream writer which flushes after each write operation. */// We can't use the same tactic as for intersection// since AbstractCollection only does a remove on the first// element it encounters.//n*LOG(n) version//n*n version//remove duplicates//can't use treeset since the base classes are different// found a leaf// That's what you get for "1.0".// Quick way to get "1.0".// Same as "0.0".// Conversions in which all decimal digits are known to be good.// Chances are this is a Float or a Big.// With Float we're extending binary precision and that gets ugly in decimal.// If we used Float.doubleValue() on 0.1f we get 0.10000000149011612.// Note that this is different than casting '(double) 0.1f' which will do the// binary extension just like in Java.// With Bigs and other unknowns, this is likely to be the same.// TODO could be made more efficient by using a reverse index// fall back to cast// we need this method as trick to guarantee correct method selection//DO NOTHINGimport Pure/** Default implementation of a GString used by the compiler. A GString consists ... */...[] strings;boolean frozen;boolean cacheable;String cachedStringLiteral;/** Create a new GString with values and strings. ... */checkValuesStringConstant(...)this.cacheablethis.cachedStringLiteralthis.frozenGString thatFrozenfreeze(...)/** Get the strings of this GString. ... */codePointBefore(...)codePointCount(...)offsetByCodePoints(...)getChars(...)contentEquals(...)compareToIgnoreCase(...)regionMatches(...)import NamedParamimport NamedParamsimport Elementimport static Math.max/* comment out the Java 11 API for now: ... */intern(...)String strbuiltinOrMarkedImmutableClass(...)toStringMarkedPure(...)/** Formatting methods */(...).cacheableMethod toStringMethodResolveVisitor.DEFAULT_IMPORTSFormatHelper.DEFAULT_IMPORT_PKGSPure.classFormatHelper.DEFAULT_IMPORT_CLASSESString SQ;String DQ;...[] EMPTY_ARGS;int ITEM_ALLOCATE_SIZE;// heuristic size to pre-allocate stringbuffers for collections of itemsMetaClassRegistry metaRegistry;String XMLUTIL_CLASS_FULL_NAME;String SERIALIZE_METHOD_NAME;Set<String> DEFAULT_IMPORT_PKGS;Set<String> DEFAULT_IMPORT_CLASSES;/** Output the {@code toString} for the argument(s) with various options to configure. ... */Object safe/** This class is primarily intended for INTERNAL USE. Use at your own risk. */String MKP;String YIELD;appendValues(...)appendStrings(...)thisValues.lengthint strings1Lengthstrings1.lengthboolean isStringsLongerint strings2Lengthstrings2.lengthString[] newStringsint lastIndexOfStringsObject maxSizeObject verboseObject inspectObject escapeBackslashesint values1Lengthvalues1.lengthint values2Lengthvalues2.lengthint numberOfValuesvs.lengthss.lengthNullObject nullObject// merge onto end of previous GString to avoid an empty bridging valueformatCollection(...)Range<> range/** Marker interface to identify closures generated by the groovy compiler. ... */RuntimeException exhandleFormattingException(...)/** Marker interface to identify lambda generated by the groovy compiler. ... */formatMap(...)Method serialize/** Support methods for Groovy category usage */Element.classnew MyThreadLocal(...)int categoriesInUse;String argescapeBackslashes(...)multiline(...)int level;CategoryMethodList previous;AtomicInteger usage;this.levelthis.previousprevious.usagegetCategoryNameUsage(...)String hashtypeName(...)sizeLeft(...)/** A helper method to format the arguments types as a comma-separated list. ... */StringBuilder argBuf/** Gets the type name ... */boolean useShort/** A helper method to return the string representation of a map with bracket boundaries "[" and "]". ... *//** A helper method to return the string representation of a list with bracket boundaries "[" and "]". ... *//** A helper method to return the string representation of an array of objects ... */Object LOCK;Map<String,String> propertyGetterMap;Map<String,String> propertySetterMap;setCategoryUsed(...)Iterator<Entry<String,CategoryMethodList>> it/** Writes an object to a Writer using Groovy's default representation for the object. */Writable writableMap<>.Entry<String,CategoryMethodList>Entry<String,CategoryMethodList> eCategoryMethodList listReader r/** Appends an object to an Appendable using Groovy's default representation for the object. */Writer stringWriterlist.levelCategoryMethodList prevlist.previousaddAndGet(...)list.usage// other primitives// TODO: For GROOVY-2599 do we need something like below but it breaks other things//            return (String) invokeMethod(arguments, "toString", EMPTY_ARGS);// must replace backslashes first, as the other replacements add backslashes not to be escaped// backslash// line feed// carriage return// tab// form feednewScope(...)// Copy stream to streamendScope(...)import MetaBeanPropertyObject NONE;CachedClass metaClassdoSetMetaClass(...)CategoryMethod mmethodnew CategoryMethod(...)new CategoryMethodList(...)// this method mimics EMC behaviorcachePropertyAccessor(...)ExpandoMetaClass.STATIC_QUALIFIERExpandoMetaClass.CONSTRUCTORHolder.META_CLASSputPropertyAccessor(...)// Precondition: accessorName.length() > prefixLength// Lazily initialize the single instance of the HandleMetaClass metaClassHandleMetaClass.classMetaClass META_CLASS;// object has default meta class, so we need to replace it on demand// object already has per instance meta classLinkedList<CachedClass> classStackCachedClass klazzapplyUse(...)String getterMyThreadLocal THREAD_INFO;Class<> metaClass;/** Sort by most specific to least specific. ... */Class<> thatClass(...).metaClassgetUsage(...)/** Create a scope based on given categoryClass and invoke closure within that scope. ... */getInfo(...)/** Create a scope based on given categoryClasses and invoke closure within that scope. ... */ThreadCategoryInfo infoNullablegetInfoNullable(...)infoNullable.levelThreadCategoryInfo.LOCK/** This method is used to pull all the new methods out of the local thread context with a particular name. ... */ThreadCategoryInfo categoryInfonew ConcurrentHashMap<String,AtomicInteger>(...)ConcurrentHashMap<String,AtomicInteger> usage;SoftReference<> referenceThreadCategoryInfo tcinfonew ThreadCategoryInfo(...)new SoftReference<>(...)AtomicInteger uAtomicInteger aiAtomicInteger prev// GROOVY-5245/* Synchronization is avoided here for performance reasons since ... */import SpreadMapEvaluatingExceptionimport PowerAssertionErrorimport PojoWrapper/** A static helper class to make bytecode generation easier and act as a facade over the Invoker */...[] EMPTY_TYPES;flushFromCaches(...)import PickFirstResolverimport EOFExceptionimport ObjectOutputStreamimport ObjectStreamClassimport Formatterimport static ClosureUtils.hasSingleStringArgimport static DefaultGroovyMethods.callClosureForLine/** This class defines new groovy methods for Readers, Writers, InputStreams and ... */Enumeration<> eGroovyObject pogo/** This is so we don't have to reorder the stack when we call this method. ... */setProperty2(...)/** Returns the method pointer for the given object name */new MethodClosure(...)Integer numberLong numbernegate(...)Double numberFloat numberShort numberByte numberList<> newlist/** Find the right hand regex within the left hand string and return a matcher. ... */String stringToCompareString regexToCompareToPattern patternMatcher matchersetLastMatcher(...)new Tuple<>(...)Object[] valuesnew SpreadMapEvaluatingException(...)/** According to the initial entry count, calculate the initial capacity of hash map, which is power of 2 ... */highestOneBit(...)Map<> answerinitialCapacity(...)Map<> smapnew PowerAssertionError(...)Binding contextnew NullScript(...)/** Overloads the leftShift operator for Writer to allow an object to be written ... *//** Overloads the leftShift operator for Appendable to allow an object to be appended ... */MetaClass smcnew Script(...) { ... }InvokerHelper$1/** Invokes a Closure that uses a Formatter taking care of resource handling. ... */Object[] mainArgsFormatter formatternew Formatter(...)Object argscallWithFormatter(...)new BiConsumer<?,?>(...) { ... }setPropertySafe(...)/** A helper method so that dynamic dispatch of the writer.write(object) method ... */Constructor<? extends Script> constructor/** Overloads the leftShift operator to provide an append mechanism to add values to a stream. ... */OutputStreamWriter writernew FlushingStreamWriter(...)/** Overloads the leftShift operator to add objects to an ObjectOutputStream. ... *//** Pipe an InputStream into an OutputStream for efficient stream copying. ... */byte[] buf/** Overloads the leftShift operator to provide an append mechanism to add bytes to a stream. ... *//** Create an object output stream for this output stream. ... */new ObjectOutputStream(...)/** Create a new ObjectOutputStream for this output stream and then pass it to the ... */withStream(...)newObjectOutputStream(...)/** Create an object input stream for this input stream. ... */new ObjectInputStream(...)/** Create an object input stream for this input stream using the given class loader. ... */new ObjectInputStream(...) { ... }IOGroovyMethods$1/** Iterates through the given object stream object by object. The ... */InputStream tempObject objEOFException ecloseWithWarning(...)/** Create a new ObjectInputStream for this input stream and pass it to the closure. ... */newObjectInputStream(...)/** Iterates through this stream reading with the provided charset, passing each line to the ... */eachLine(...)/** Iterates through this stream reading with the provided charset, passing each line to ... *//** Iterates through this stream, passing each line to the given 1 or 2 arg closure. ... *//** Iterates through the given reader line by line.  Each line is passed to the ... *//** Sets the properties on the given object */Reader tempcreateRange(...)callClosureForLine(...)Throwable re// Kept in for backwards compatibility/** Iterates through the given reader line by line, splitting each line using ... */splitEachLine(...)not(...)List<> vals/** Invokes the given method on the object. */asArray(...)invokePojoMethod(...)invokePogoMethod(...)hasSingleStringArg(...)GroovyObject groovyboolean interceptingasUnwrappedArray(...)/** Converts the given object into an array; if its an array then just ... *//** Iterates through the given InputStream line by line using the specified ... *//** Iterates through the given InputStream line by line, splitting each line using ... *//** Read a single, whole line from the given Reader. This method is designed for use with ... */markSupported(...)readLineFromReaderWithMark(...)readLineFromReaderWithoutMark(...)int charBufferSize;int expectedLineLength;// let's assume its a collection of 1// half the default stream buffer sizeint EOF;// double the default line length/* This method tries to read subsequent buffers from the reader using a mark */// End Of Filechar[] cbuf// value is a list.StringBuilder line// GROOVY-8995: Improve the performance of creating list// answer.addAll(Arrays.asList(values));int lslineSeparatorIndex(...)int skipLS// wrap call "ScriptClass.main(args)" with a Script instance// call with empty array// assume underscore variables are for the wrapper// Fallback for non-standard "Script" classes.// GROOVY-5802 IAE for missing properties with classes that extend List// value is a regular expression.// if the object is a Class, call a static method from that class// it's an instance; check if it's a Java one// a groovy instance (including builder, closure, ...)// if it's a pure interceptable object (even intercepting toString(), clone(), ...)//else try a statically typed method or a GDK method// in case there's nothing else, invoke the object's own invokeMethod()/* This method reads without a buffer. ... *//* searches for \n or \r ... */isLineSeparator(...)/* true if either \n or \r *//** Reads the stream into a list, with one element for each line. ... */readLines(...)newReader(...)/** An exception thrown if a method is called and an exception occurred *//** Reads the reader into a list of Strings, with one entry for each line. ... */IteratorClosureAdapter<String> closurenew IteratorClosureAdapter<String>(...)/** Read the content of this InputStream and return it as a String. ... *//** Read the content of this InputStream using specified charset and return ... *//** Read the content of the Reader and return it as a String.  The reader ... */BufferedReader bufferedReader/** Read the content of the BufferedReader and return it as a String. ... */StringBuilder answerchar[] charBufferint nbCharRead/** Read the content of this InputStream and return it as a byte[]. ... */ByteArrayOutputStream answerbyte[] byteBufferint nbByteRead/** Write the byte[] to the output stream. ... *//** Write the text and append a newline (using the platform's line-ending). ... *//** Creates an iterator which will traverse through the reader a line at a time. ... */new Iterator<String>(...) { ... }IOGroovyMethods$2String nextVal;boolean nextMustRead;boolean hasNext;readNext(...)String retvalString nv/** Standard iterator for a input stream which iterates through the stream ... *//** Standard iterator for a data input stream which iterates through the ... */new Iterator<Byte>(...) { ... }IOGroovyMethods$3Byte nextVal;readByte(...)Byte retval/** Creates a reader for this input stream. ... *//** Creates a reader for this input stream, using the specified ... *//** Create a new PrintWriter for this Writer. ... *//** Create a new PrintWriter for this OutputStream. ... *//** Create a new PrintWriter for this Writer.  The writer is passed to the ... */withWriter(...)newPrintWriter(...)/** Create a new PrintWriter for this OutputStream.  The writer is passed to the ... *//** Allows this writer to be used within the closure, ensuring that it ... *//** A closure which stores calls in a List so that method calls ... */List<T> list;Writer temp/** Allows this reader to be used within the closure, ensuring that it ... *//** Allows this input stream to be used within the closure, ensuring that it ... */import static CachedSAMClass.getSAMMethodMetaClassHelper.class/** Helper method to create a new Reader for a stream and then ... */withReader(...)/** Creates a writer from this stream, passing it to the given closure. ... *//** Creates a writer for this stream. ... *//** Creates a writer for this stream using the given charset. ... *//** Passes this OutputStream to the closure, ensuring that the stream ... */OutputStream temp/** Traverse through each byte of the specified stream. The ... */int b/** Traverse through each the specified stream reading bytes into a buffer ... */byte[] buffer/** Transforms each character from this reader by passing it to the given ... */Writer temp2Reader temp1/** Transforms the lines from a reader with a Closure and ... */BufferedWriter bw/** Filter the lines from a reader and write them on the writer, ... *//** Filter the lines from this Reader, and return a Writable which can be ... */IOGroovyMethods$4...[] ARRAY_WITH_NULL;int MAX_ARG_LEN;int OBJECT_SHIFT, ...;/* dist binary layout: ... *//** Filter lines from an input stream using a closure predicate.  The closure ... */filterLine(...)/** Uses a closure to filter lines from this InputStream and pass them to ... *//** Allows this closeable to be used within the closure, ensuring that it ... */Throwable suppressedaddSuppressed(...)/** Allows this AutoCloseable to be used within the closure, ensuring that it ... */Boolean isAccessiblecheckCompatiblePackages(...)boolean flagint DEFAULT_BUFFER_SIZE;Object[] retboolean[] array// we allow null objects in the object stream// this should never happen// fallback// could be changed into do..while, but then// we might create an additional StringBuilder// instance at the end of the stream// we are at the end of the input data// now work on the buffer(s)// correct ls if we have \r\n// we are not at the end of the buffer//reset() and skip over last linesep// reading the content of the reader within a char buffer// allow to keep the correct line endings// appends buffer// reading the content of the stream within a byte buffer// try to continue even in case of error// 8kchar[] arraybyte[] arrayint[] arrayshort[] arraylong[] arraydouble[] arrayfloat[] array/** Represents a method on an object using a closure, which can be invoked at any ... */boolean ALLOW_RESOLVE;String ANY_INSTANCE_METHOD_EXISTS;// choose readObject/readResolve return/throwString NEW;boolean anyInstanceMethodExists;/** Indicates if this may be related to an instance method. */Object objArray...[] PRIMITIVES;...[] PRIMITIVE_DISTANCE_TABLE;byte iPRIMITIVES.lengthClass<?>[] sizeTypesint fromIndexgetPrimitiveIndex(...)int toIndexint maxsetParameterTypesAndNumber(...)int superClassMaxCachedConstructor cgetMaximumInterfaceDistance(...)int submakeParameterTypes(...)this.anyInstanceMethodExistsnewParameterTypes.length/* Create a new array of parameter type. ... */Class<>[] newParameterTypesClass<>[] nativeParameterTypesnativeParameterTypes.length// TODO: This method seems to be never called..., because MetaClassImpl.invokeMethod will intercept calls and return the result.Class<?> parameterClasslong objectDistancegetPrimitiveDistance(...)parameter.isArrayint parametersLengthlong retint noVargsLengthint argumentsLengthCachedClass baseTypeCachedClass vargsTypeObject vargsMethodParameterTypes ptint paramLength/** Warning: this method does not choose properly if multiple methods with ... */CachedClass closestClassCachedClass closestVargsClassint closestDistCachedClass theTypetheType.isPrimitiveCachedClass newVargsClassint newDist// Object aListparams1.lengthparams2.lengthboolean matches/** param instance array to the type array ... */Class<>[] ansgetClassWithNullAndWrapper(...)Class<> argClassint tmpCountClass<> tmpClassSet<Class<>> intfsnew HashSet<Class<>>(...)/** Returns a callable object for the given method name on the object. ... */isIntegerLongShortByte(...)String lognameLogger objLogLevel.FINERnormalizedValue(...)logp(...)int lastDotPosClass<>[] wrappedArgumentswrappedArguments.lengthisSuperclass(...)Class<> compareClassWrapper wObject argType/** Sets the meta class for an object, by delegating to the appropriate ... *//** Converts a String into a standard property name. ... *///                    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19/* boolean[0] *//* Boolean[1] *//* byte[2] *//* Byte[3] *//* short[4] *//* Short[5] *//* char[6] *//* Character[7] *//* int[8] *//* Integer[9] *//* long[10] *//* Long[11] *//* BigInteger[12] *//* float[13] *//* Float[14] *//* double[15] *//* Double[16] *//* BigDecimal[17] *//* Number[18] *//* Object[19] */// we know here that from!=to, so a distance of 0 is never valid// get primitive type indexes// -1 means a mismatch// 0 means a direct match// we need to keep the -1 to track the mismatch, a +1// by any means could let it look like a direct match// we want to add one, because there is an interface between// the interface we search for and the interface we are in.// we are interested in the longest path only// we do not add one for super classes, only for interfaces// determine parameter count from generated "doCall" method(s)// 0 or 1/* note: when shifting with 32 bit, you should only shift on a long. If you do ... */// add one to dist to be sure interfaces are preferred// GROOVY-5114: if choosing between foo(Object[]) and foo(Object)// and the argument is an array, then array version is preferable// GROOVY-9881// ahead of Object but behind GroovyObjectSupport// choose the distance to Object if an argument is null, which means// that Object is preferred over a more specific type// if the number of parameters does not match we have // a vargs usage// case A: arguments.length<parameters.length//         In this case arguments.length is always equal to//         noVargsLength because only the last parameter//         might be a optional vargs parameter//         VArgs penalty: 1l// case B: arguments.length>parameters.length//         In this case all arguments with a index bigger than//         paramMinus1 are part of the vargs, so a //         distance calculation needs to be done against //         parameters[noVargsLength].getComponentType()//         VArgs penalty: 2l+arguments.length-parameters.length// case C: arguments.length==parameters.length && //         isAssignableFrom( parameters[noVargsLength],//                           arguments[noVargsLength] )//         In this case we have no vargs, so calculate directly//         VArgs penalty: 0l// case D: arguments.length==parameters.length && //         !isAssignableFrom( parameters[noVargsLength],//                            arguments[noVargsLength] )//         In this case we have a vargs case again, we need //         to calculate arguments[noVargsLength] against//         parameters[noVargsLength].getComponentType//         VArgs penalty: 2l//         This gives: VArgs_penalty(C)<VArgs_penalty(A)//                     VArgs_penalty(A)<VArgs_penalty(D)//                     VArgs_penalty(D)<VArgs_penalty(B)/** In general we want to match the signature that allows us to use ... */// first we calculate all arguments, that are for sure not part// of vargs.  Since the minimum for arguments is noVargsLength// we can safely iterate to this point// case C&D, we use baseType to calculate and set it// to the value we need according to case C and D// case C// case D// penalty for vargs// case B// we give our a vargs penalty for each exceeding argument and iterate// by using parameters[noVargsLength].getComponentType()// case A// we give a penalty for vargs, since we have no direct// match for the last argument// let's look for methods with 1 argument which matches the type of the// closestClass and theType are not in a subtype relation, we need// to check the distance to Object// arguments.length>0 && !=null// all arguments were null/* If no specific super class has been found and type fallback is an interface, check if all arg classes ... */// all arg classes implement interface fallback, so use that as the array component type/* if (GString.class.isAssignableFrom(baseClass)) { ... */// note: there is no coercion for boolean and char. Range matters, precision doesn't// *very* defensive...//                throw new IllegalArgumentException("Arguments to method [respondsTo] must be of type java.lang.Class!");// Temp code to ignore wrapped parameters// The New MOP will deal with these properly/** Utility class for MissingMethodException, MissingPropertyException etc. ... */int DL_SUBSTITUTION;//they are used by the two DamerauLevenshtein implementations//These are the costs for the various edit operationsint DL_DELETE;int DL_TRANSPOSITION;//This is also the cost for a insertint DL_CASE;int MAX_RECOMENDATIONS;int MAX_METHOD_SCORE;int MAX_CONSTRUCTOR_SCORE;int MAX_FIELD_SCORE;U u;V v;this.uthis.v/** Returns a string detailing possible solutions to a missing method ... */List<MetaMethod> methodsList<MetaMethod> suggrankMethods(...)Class<>[] argumentClassesgetArgumentClasses(...)List<Pair<Class<>,Class<>>> conflictClassesgetConflictClasses(...)listParameterNames(...)/** An abstract base class for a key used for comparators and Map keys to lookup a method by ... */Class<> sender;boolean isCallToSuper;this.senderthis.isCallToSuper/** Creates an immutable copy that we can cache. */getParameterType(...)new DefaultMethodKey(...)that.senderthat.isCallToSupercreateHashCode(...)getParamterTypes(...)List<> paramsPair<Class<>,Class<>> pairpair.upair.vList<Pair<Class<>,Class<>>> retnew LinkedList<Pair<Class<>,Class<>>>(...)// can't remember the exact Josh Bloch algorithm and I've not got the book handy// but its something like this IIRCnew NullObject(...)NullObject INSTANCE;/** private constructor *//** get the NullObject reference ... *//** Since this is implemented as a singleton, we should avoid the ... *//** Tries to get a property on null, which will always fail ... *//** Allows the closure to be called for NullObject ... */Set<Class<>> recordedClasses/** Tries to set a property on null, which will always fail ... *//** Tries to invoke a method on null, which will always fail ... *//** null is only equal to null ... *//** iterator() method to be able to iterate on null. ... */Class<>[] paraClass<> aParanew Pair<Class<>,Class<>>(...)argumentClasses.length/** Returns a string detailing possible solutions to a missing constructor ... */Constructor<>[] suggrankConstructors(...)sugg.length/** Allows to add a String to null. ... *//** Fallback for null+null. ... *//** The method "is" is used to test for equal references. ... *//** Type conversion method for null. ... *//** A null object always coerces to false. ... *//** Returns a string detailing possible solutions to a missing field or property ... */List<MetaProperty> fiList<RankableField> rfnew ArrayList<RankableField>(...)new RankableField(...)RankableField ff.scoref.f/** creates a comma separated list of each of the class names. ... */cachedClasses.length/** Returns a sorted(ranked) list of a selection of the methods among candidates which ... */List<RankableMethod> rmnew ArrayList<RankableMethod>(...)Class<>[] taoriginal.lengthClass<> nullCList<MetaMethod> lnew RankableMethod(...)RankableMethod mm.scorem.m/** This class wraps a method object and a score variable so methods ... */MetaMethod m;Integer score;int nameDistdelDistance(...)Class<>[] mArgsint argDistdamerauLevenshteinDistance(...)this.mmArgs.lengthboxVar(...)this.scoreRankableMethod momo.score/** Returns a sorted(ranked) list of a selection of the constructors among candidates which ... */RankableConstructor[] rcnew RankableConstructor[]candidates.lengthList<Constructor<>> lnew ArrayList<Constructor<>>(...)new RankableConstructor(...)rc.length...[...].score...[...].cnew Constructor<>[]Constructor<> c;Class<>[] cArgsthis.ccArgs.lengthRankableConstructor coco.scoreMetaProperty f;this.fRankableField co/** If c is a primitive class this method returns a boxed version ... *//** This is a small wrapper for nulls *//** This is a slightly modified version of the Damerau Levenshtein distance ... */int[][] valsint[] _dchar t_jchar s_iint costcaselessCompare(...)/** Compares two characters whilst ignoring case. ... *//** This is a implementation of DL distance between two Object arrays instead ... */s.lengtht.lengthObject t_j/** Compares two objects using Groovy's friendly comparison algorithm, i.e. ... */boolean ignoreZeroSign;this.ignoreZeroSignint x1int x2RuntimeException cce// since the object does not have a valid compareTo method// we compare using the hashcodes. null cases are handled by// DefaultTypeTransformation.compareTo// This is not exactly a mathematical valid approach, since we compare object//All nulls have to be wrapped so that they can be compared// that cannot be compared. To avoid strange side effects we do a pseudo order//unbox primitives// using hashcodes, but without equality. Since then an x and y with the same//All args have to be boxed since argumentTypes is always boxed// hashcodes will behave different depending on if we compare x with y or// x with y, the result might be unstable as well. Setting x and y to equal// may mean the removal of x or y in a sorting operation, which we don't want.// length of s// length of t//we have to keep 3 rows instead of the 2 used in Levenshtein//placeholder to assist in rotating vals// indexes into strings s and t// iterates through s// iterates through t// jth character of t// ith character of s// cost//if s_i and t_i don't have have the same case//if they share case check for substitution// minimum of cell to the left+1, to the top+1, diagonally left and up +cost//Check for transposition, somewhat more complex now since we have to check for case// rotate all value arrays upwards(older rows get a higher index)// our last action in the above loop was to rotate vals, so vals[1] now// actually has the most recent cost counts// indexes into arrays s and t// jth object of t//Check for transpositionimport GeneratedGroovyProxyimport static ReflectionUtils.isSealed/** A proxy generator responsible for mapping a map of closures to a class implementing a list of interfaces. For ... */getInheritedMethods(...)new ArrayList<Method>(...)List<String> names/** An alias method so that a process appears similar to System.out, System.in, System.err; ... *//** Read the text of the output stream of the Process. ... */closeStreams(...)getErrorStream(...)/** Overloads the left shift operator (&lt;&lt;) to provide an append mechanism ... *//** Overloads the left shift operator to provide an append mechanism ... *//** Wait for the process to finish during a certain amount of time, otherwise stops the process. ... */ProcessRunner runnablenew ProcessRunner(...)waitForOrKill(...)/** Closes all the streams associated with the process (ignoring any IOExceptions). ... *//** Gets the output and error streams from a process and reads them ... */consumeProcessOutput(...)Map<String,Boolean> EMPTY_DELEGATECLOSURE_MAP;Set<String> EMPTY_STRING_SET;String CLOSURES_MAP_FIELD;String DELEGATE_OBJECT_FIELD;List<Method> OBJECT_METHODS;List<Method> GROOVYOBJECT_METHODS;AtomicLong pxyCounter;Set<String> GROOVYOBJECT_METHOD_NAMESS;Class<?> superClass;Class<?> delegateClass;InnerLoader loader;String proxyName;consumeProcessOutputStream(...)consumeProcessErrorStream(...)waitForProcessOutput(...)LinkedHashSet<Class<>> classList;Map<String,Boolean> delegatedClosures;Thread toutboolean emptyBody;// if emptyBody == true, then we generate an empty body instead throwing error on unimplemented methodsboolean hasWildcard;boolean generateDelegateField;Set<String> objectDelegateMethods;Set<Object> visitedMethods;Thread terrClass<> cachedClass;// cached classConstructor<> cachedNoArgConstructor;/** Construct a proxy generator. This generator is used when we need to create a proxy object for a class or an ... */InterruptedException ignorewaitFor(...)Class<?> fixedSuperClassadjustSuperClass(...)ClassWriter writerbyte[] bClass<?>[] argscreateInnerLoader(...)findClassLoader(...)this.visitedMethodsnew LinkedHashSet<Object>(...)/** Gets the error stream from a process and reads it ... */new ByteDumper(...)new TextDumper(...)/** Gets the output stream from a process and reads it ... *//** Creates a new BufferedWriter as stdin for this process, ... */getOut(...)/** Creates a new buffered OutputStream as stdin for this process, ... *//** Allows one Process to asynchronously pipe data to another Process. ... */getIn(...)OutputStream out/** Overrides the or operator to allow one Process to asynchronously ... */pipeTo(...)/** A Runnable which waits for a process to complete together with a notification scheme ... */Process process;boolean finished;this.delegatedClosuresthis.processdoProcessWait(...)notifyAll(...)wait(...)destroy(...)InputStream in;Appendable app;this.inthis.appInputStreamReader isrString nextOutputStream out;/** Executes the command specified by <code>self</code> as a command-line process. ... */exec(...)/** Executes the command specified by <code>self</code> with environment defined by <code>envp</code> ... *//** Executes the command specified by <code>self</code> with environment defined ... */execute(...)stringify(...)/** Executes the command specified by the given <code>String</code> array. ... *//** Executes the command specified by the <code>String</code> array given in the first parameter, ... *//** Executes the command specified by the given list. The toString() method is called ... *//** Executes the command specified by the given list, ... */Entry<Object,Object> entryMap<>.Entry<Object,Object>this.hasWildcardthis.generateDelegateFieldthis.objectDelegateMethodscreateDelegateMethodList(...)this.classListnew LinkedHashSet<Class<>>(...)new Predicate<Class<>>(...) { ... }this.proxyNameproxyName(...)this.emptyBodySet<ClassNode> traitscollectTraits(...)/** Utility class to call methods through reflection, and falls through using the <code>Invoker</code> to call the method if it fails. ... *//** Invoke a method through reflection. ... */Class<>[] classTypesList<GroovyClass> classesclassTypes.lengthClass<?> faceClassNode selfType/** Provides as alternative to reflection using bytecode generation. */noSuchMethod(...)ClassLoader cl/** Used to store the last regex match. */new ThreadLocal<>(...)ThreadLocal<> CURRENT_MATCHER;Set<String> selectedMethodsList<Method> interfaceMethodsList<Method> superClassMethodsList<Method> additionalMethodsClass<?> thisInterfacecontainsEquivalentMethod(...)Class<?> currentClassMethod[] protectedMethodsimport EncodingAwareBufferedWriterimport FileTypeimport FileVisitResulthasMatchingParameterTypes(...)Class<?>[] candidateParamTypesClass<?>[] methodParamTypescandidateParamTypes.lengthmethodParamTypes.length/** This class defines new groovy methods for Files, URLs, URIs which appear ... *//** Provide the standard Groovy <code>size()</code> method for <code>File</code>. ... *//** Calculates directory size as total size of all its files, recursively. ... */long[] sizeeachFileRecurse(...)FileType.FILESResourceGroovyMethods$1Set<String> interfacesSetboolean addGroovyObjectSupportClass<?> extraInterfaceGeneratedGroovyProxy.classaddDelegateFields(...)createGroovyObjectSupport(...)/** Visit every class/interface this proxy should implement, and generate the appropriate ... */Constructor<?>[] constructorsClass<?> superclassClass<?>[] exceptionTypes/** Create an object output stream for this file. ... */String[] exceptionsexceptionTypes.length/** Create a new ObjectOutputStream for this file and then pass it to the ... *//** Create an object input stream for this file. ... */Constructor<?> method/** Create an object input stream for this file using the given class loader. ... *//** Iterates through the given file object by object. ... */eachObject(...)/** Create a new ObjectInputStream for this file and pass it to the closure. ... *//** Create a new ObjectInputStream for this file associated with the given class loader and pass it to the closure. ... *//** Iterates through this file line by line.  Each line is passed to the ... *//** Iterates through this file line by line.  Each line is passed ... */Class<?> intfEntry<String,Boolean> entryMap<>.Entry<String,Boolean>Boolean visited/** Iterates through the lines read from the URL's associated input stream passing each ... *//** When an object doesn't implement the GroovyObject interface, we generate bytecode for the ... *//** Iterates through this file line by line, splitting each line using ... *//** Creates delegate fields for every closure defined in the map. *//** Iterates through the input stream associated with this URL line by line, splitting each line using ... *//** Reads the file into a list of Strings, with one item for each line. ... */Class<?> parentisImplemented(...)/** Reads the URL contents into a list, with one element for each line. ... */boolean objectDelegate/** Read the content of the File using the specified encoding and return it ... */boolean closureDelegateboolean wildcardDelegate/** Read the content of the File and returns it as a String. ... *//** Read the content of this URL and returns it as a String. ... */makeDelegateToClosureCall(...)makeDelegateCall(...)/** Read the data from this URL and return it as a String.  The connection ... */createGetProxyTargetMethod(...)/** Read the content of the File and returns it as a byte[]. ... *//** Read the content of this URL and returns it as a byte[]. ... */configuredInputStream(...)/** Write the bytes from the byte array to the File. ... */Type[] argssetBytes(...)/** Creates, if needed, any parent directories for this File. ... */createDirectories(...)Type returnTypetoPath(...)Type.VOID_TYPE/** Write the text to the File without writing a BOM. ... */int loadInsgetLoadInsn(...)/** Write the text to the File.  If the default charset is ... */getReturnInsn(...)defaultCharset(...)/** Synonym for write(text) allowing file.text = 'foo'. ... */registerLen(...)/** Synonym for write(text, charset) allowing: ... *//** Write the text to the File. ... *//** Write bytes to a File. ... *//** Append binary data to the file.  See {@link #append(java.io.File, java.io.InputStream)} ... */Type arg/** Write the text to the File without writing a BOM, ... *//** Write the text to the File, using the specified encoding.  If the given ... */FileOutputStream out/** Append the text at the end of the File without writing a BOM. ... *//** Append the text at the end of the File.  If the default ... */StringBuilder newDesc/** Append the text supplied by the Writer at the end of the File without writing a BOM. ... *//** Append the text supplied by the Writer at the end of the File.  If the default ... */appendBuffered(...)BufferedWriter writerboolean shouldWriteBominitializeDelegateClosure(...)initializeDelegateObject(...)getTypeArgsRegisterLength(...)newWriter(...)/** Append bytes to the end of a File.  It <strong>will not</strong> be ... */OutputStream stream/** Generate a call to the delegate object. *//** Append binary data to the file.  It <strong>will not</strong> be ... *//** Append the text at the end of the File without writing a BOM, ... *//** Append the text at the end of the File, using a specified encoding.  If ... */boxPrimitiveType(...)unwrapResult(...)/** Append the text supplied by the Writer at the end of the File ... *//** Append the text supplied by the Writer at the end of the File, using a specified encoding. ... */int stackSize/** Append the text supplied by the Reader at the end of the File, using a specified encoding. ... */int arrayStore/** Append the text supplied by the Reader at the end of the File ... */int arrayIndexLabel notNull/** This method is used to throw useful exceptions when the eachFile* and eachDir closure methods ... *//** Invokes the closure for each 'child' file in this 'parent' folder/directory. ... */File[] fileslistFiles(...)checkDir(...)FileType.ANYFileType.DIRECTORIESString wrappedTypegetWrappedClassDescriptor(...)eachFile(...)/** Invokes the closure for each subdirectory in this directory, ... *//** Processes each descendant file in this directory and any sub-directories. ... */constructorArgs.lengthboolean preRootboolean postRootboolean visitRootClosure<> pre/** Ensures that the provided object is wrapped into a closure if it's not ... */new ReturnValueWrappingClosure<>(...)Closure<> postFileType typeObject filterObject nameFilterObject excludeFilterObject excludeNameFilterObject preResultFileVisitResult terminatedtraverse(...)Object maxDepthValueObject preRootValueObject postRootValueObject visitRootValuegetLoadInsnByType(...)getReturnInsnByType(...)List<ClassLoader> internalClassLoaders;FileVisitResult.TERMINATEFileVisitResult.SKIP_SUBTREEnotFiltered(...)Object closureResultnew ArrayList<ClassLoader>(...)Object filterToUseObject filterParamObject excludeFilterToUseObject excludeParamMetaClass filterMCMetaClass excludeMCboolean includedboolean excludedClass<?> loadedClassClassNotFoundException exClassLoader i// if we have to delegate to another object, generate the appropriate delegate field// and collect the name of the methods for which delegation is active// a proxy is supposed to be a concrete class, so it cannot extend an interface.// If the provided superclass is an interface, then we replace the superclass with Object// and add this interface to the list of implemented interfaces// create the base list of classes which have possible methods to be overloaded// generate bytecode//        CheckClassAdapter.verify(new ClassReader(b), true, new PrintWriter(System.err));/** Invokes the closure specified with key 'visit' in the options Map ... */// cache no-arg constructor// check trait for @SelfType types that are / extend traitsClosure<> visit// for each method defined in the class, generate the appropriate delegation bytecode// Ultimately, methods can be available in the closure map which are not defined by the superclass// nor the interfaces// generate a new method// getMetaClass// setMetaClass// do not generate bytecode for final, native, private or synthetic methods// GROOVY-8244: proxy for abstract class/trait/interface only overrides abstract method(s)// for compatibility with the legacy proxy generator, we should throw an UnsupportedOperationException// instead of an AbtractMethodException// the closure map// load argument i// this// constructor arg n is the closure map// load this// load delegate// using InvokerHelper to allow potential intercepted calls// method name// primitive types must be boxed// store value into array//        TraceMethodVisitor tmv = new TraceMethodVisitor(mv);//        mv = tmv;// method body should be://  this.$delegate$closure$methodName.call(new Object[] { method arguments })// stack size = 1// stack size = 2// array index, stack size = 3// store array// load closure map// load method name// if null, test if wildcard exists// load wildcard// load argument array// call closure//        System.out.println("tmv.getText() = " + tmv.getText());// if there isn't any argument, we can make invocation faster using the cached constructor// First check whether it's already been loaded, if so use it// Check this class loader// Check parent classloader, keep the exception for future use// Not loaded, try to load it// Ignore parent delegation and just try to load locally// Swallow exception - does not exist locally// Throw earlier exception from parent loader if it exists, otherwise create a new exceptionClosure<> sortFile[] origFilesList<File> filesFileVisitResult.SKIP_SIBLINGSObject postResult/** A reverse iterator over a list. Utilizes the {@link ListIterator} ... */ListIterator<T> delegate;/** Constructs a new <code>ReverseListIterator</code> for the provided list. ... */FileVisitResult.CONTINUE/** Recursively processes each descendant subdirectory in this directory. ... *//** Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory ... */File currentFileeachFileMatch(...)/** Invokes the closure for each subdirectory whose name (dir.name) matches the given nameFilter in the given directory ... *//** Deletes a directory with all contained files and subdirectories. ... */deleteDir(...)/** Renames the file. It's a shortcut for {@link java.io.File#renameTo(File)} ... *//** Relative path to file. ... */String fromPathString toPathString[] fromPathStackgetPathStack(...)String[] toPathStackint minLengthfromPathStack.lengthtoPathStack.lengthint sameList<String> relativePathStack/** Converts this File to a {@link groovy.lang.Writable}. ... */new WritableFile(...)/** Converts this File to a {@link groovy.lang.Writable} or delegates to default ... */Writable.class/** Allows a file to return a Writable implementation that can output itself ... *//** Create a buffered reader for this file. ... */CharsetToolkit toolkitnew CharsetToolkit(...)/** Create a buffered reader for this file, using the specified ... *//** Create a new BufferedReader for this file and then ... *//** Create a new BufferedReader for this file using the specified charset and then ... *//** Create a buffered output stream for this file. ... *//** Creates a new data output stream for this file. ... *//** Creates a new OutputStream for this file and passes it into the closure. ... */newOutputStream(...)/** Create a new InputStream for this file and passes it into the closure. ... */newInputStream(...)/** Creates a new InputStream for this URL and passes it into the closure. ... *//** Create a new DataOutputStream for this file and passes it into the closure. ... */newDataOutputStream(...)/** Create a new DataInputStream for this file and passes it into the closure. ... */newDataInputStream(...)/** Create a buffered writer for this file. ... *//** Creates a buffered writer for this file, optionally appending to the ... *//** Helper method to create a buffered writer for a file without writing a BOM. ... *//** Helper method to create a buffered writer for a file.  If the given ... */new EncodingAwareBufferedWriter(...)/** Creates a buffered writer for this file, writing data without writing a ... *//** Creates a new BufferedWriter for this file, passes it to the closure, and ... *//** Create a new BufferedWriter which will append to this file.  If the ... *//** Create a new BufferedWriter for this file in append mode.  The writer ... *//** Create a new PrintWriter for this file. ... *//** Create a new PrintWriter for this file, using specified ... *//** Create a new PrintWriter for this file which is then ... *//** Create a new PrintWriter with a specified charset for this file.  If the ... *//** Helper method to create a new BufferedReader for a URL and then ... *//** Helper method to create a new Reader for a URL and then ... *//** Creates a buffered input stream for this file. ... *//** Creates an inputstream for this URL, with the possibility to set different connection parameters using the ... */URLConnection connectionsetConnectTimeout(...)setReadTimeout(...)setUseCaches(...)setAllowUserInteraction(...)Map<String,CharSequence> propertiesEntry<String,CharSequence> entryMap<>.Entry<String,CharSequence>setRequestProperty(...)/** Creates a buffered input stream for this URL. ... *//** Creates a buffered reader for this URL. ... *//** Creates a buffered reader for this URL using the given encoding. ... *//** Create a data input stream for this file ... *//** Traverse through each byte of this File ... */BufferedInputStream iseachByte(...)/** Traverse through the bytes of this File, bufferLen bytes at a time. ... *//** Reads the InputStream from this URL, passing each byte to the given ... */InputStream is/** Reads the InputStream from this URL, passing a byte[] and a number of bytes ... *//** Filters the lines of a File and creates a Writable in return to ... *//** Filter the lines from this File, and write them to the given writer based ... *//** Filter lines from a URL using a closure predicate.  The closure ... *//** Uses a closure to filter lines from this URL and pass them to ... *//** Reads the content of the file into a byte array. ... */FileInputStream fileInputStreamDataInputStream disreadFully(...)/** Transforms a CharSequence representing a URI into a URI object. ... *//** Transforms a String representing a URI into a URI object. ... *//** Transforms a CharSequence representing a URL into a URL object. ... *//** Transforms a String representing a URL into a URL object. ... *//** Gets all names of the path as an array of <code>String</code>s. ... */String normalizedPath/** Gets path from a <code>List</code> of <code>String</code>s. ... */import GroovyObjectWrapper/** A static helper class to interface bytecode and runtime */Integer ZERO;Integer MINUS_ONE;//  --------------------------------------------------------//                   exception handlingThrowable thMissingPropertyExceptionNoStack noStackMissingMethodExceptionNoStack noStack//                       methods for this// null check because of http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4803836invokeMethodOnCurrentN(...)// couldn't access files// delete contained files// now delete directory itself// build the path stack info to compare// not the same device (would be "" on Linux/Unix)// no comparison possible// Used outside the for loop// get index of parts which are equal// if "from" part is longer, fill it up with ".."// to reach path which is equal to both paths// fill it up path with parts which were not equalinvokeMethodNSafe(...)invokeMethodOnCurrentNSafe(...)invokeMethodOnCurrentNSpreadSafe(...)//                       methods for superinvokeMethodOnSuperN(...)invokeMethodOnSuperNSafe(...)invokeMethodOnSuperNSpreadSafe(...)//              normal method invocationinvokeMethodN(...)invokeMethodNSpreadSafe(...)//                static normal method invocationinvokeStaticMethodN(...)//              normal constructor invocation (via new)// can safely use '/' because Windows understands '/' as separatorinvokeNewN(...)//       special constructor invocation (via this/super)//              field handling super: getgetFieldOnSuper(...)/** Represents a reference to a variable in a script *///              field handling super: setsetFieldOnSuper(...)//              normal field handling : getgetFieldSafe(...)//              normal field handling : set/** This class defines new groovy methods for Sockets which enhance ... */setFieldSafe(...)//              normal GroovyObject field handling : get//              Property handling super: getgetPropertyOnSuper(...)/** Passes the Socket's InputStream and OutputStream to the closure.  The ... */OutputStream outputIterator<?> itInputStream temp1OutputStream temp2//              Property handling super: set/** Creates an InputObjectStream and an OutputObjectStream from a Socket, and ... */ObjectOutputStream oosObjectInputStream oissetPropertyOnSuper(...)//              normal Property handling : get//              normal Property handling : set/** Overloads the left shift operator to provide an append mechanism to ... *//** Accepts a connection and passes the resulting Socket to the closure ... *///              normal GroovyObject Property handling : getSocket socketgetGroovyObjectProperty(...)invokeClosureWithSocket(...)//              normal GroovyObject Property handling : set/** Returns the method pointer for the given object name ... *///                     Closures//  **********************************************************************************//  **************          methods not covered by the new MOP          **************getMethodPointer(...)// TODO: set sender class/** Provides a hook for type coercion of the given object to the required type ... *///                     type conversion/** Provides a hook for type casting of the given object to the required type ... */import LogManager/** Originally was grails.utils.GrailsUtils, removed some grails specific stuff. ... */createList(...)Enumeration<String> existingLogsgetLoggerNames(...)getLogManager(...)new PojoWrapper(...)new GroovyObjectWrapper(...)setUseParentHandlers(...)Object tmpFromint fromCompint toCompboolean sameSignnew EmptyRange<>(...)invokeMethod0(...)//assertassertFailed(...)//TODO: set sender class//isCase//compareClass<?> leftClassClass<?> rightClassString STACK_LOG_NAME;Logger STACK_LOG;...[] GROOVY_PACKAGES;List<Closure<>> tests;/** Adds a groovy.lang.Closure to test whether the stack trace ... *//** Remove all apparently groovy-internal trace entries from the exception instance ... */GStringImpl.classStackTraceElement[] traceList<StackTraceElement> newTracenew ArrayList<StackTraceElement>(...)StackTraceElement[] cleannew StackTraceElement[]StackTraceElement stackTraceElementisApplicationClass(...)setStackTrace(...)sanitize(...)printSanitizedStackTrace(...)Closure<> testString groovyPackage/** Extracts the root cause of the exception, no matter how nested it is ... */Throwable result/** Get the root cause of an exception and sanitize it for display to the user ... */extractRootCause(...)/** Sanitize the exception and ALL nested causes ... */Throwable current// set log to consume traces by default, end user can override later// Note that this getBoolean access may well be synced...// We don't want to lose anything, so log it//regexprfindRegex(...)matchRegex(...)//spread expressionsint argsPosint spreadPosint positionimport OptionalDoubleimport OptionalIntimport OptionalLongimport Spliteratorimport Spliteratorsimport BaseStreamimport DoubleStreamimport IntStreamimport LongStreamimport StreamSupport/** Returns element at {@code index} or {@code null}. ... */spreadMap(...)//else if there's a statically typed method or a GDK method// ignore interception and missing method fallback// Create an empty range if the difference between from and to is one and they have the same sign. This// means that range syntaxes like 5<..<6 will result in an empty range, but 0<..<-1 won't, since the latter// is used in list indexing where negative indices count from the end towards the beginning. Note that// positive numbers and zeros are considered to have the same sign to make ranges like 0<..<1 be EmptyRanges// Currently, empty ranges where from != to, the range is full exclusive (e.g. 0<..<-1) and from and to// have a different sign are constructed as IntRanges. This is because t3hese ranges can still be used to// index into lists.// ObjectRange does not include information about inclusivity, so we need to consider it here/** Returns element(s) in {@code range} or an empty list. ... *//** This class codes around a silly limitation of StringWriter which doesn't allow a StringBuffer ... */StringBuffer buffer;/** Create a new string writer which will append the text to the given StringBuffer *//** Write a single character. *//** Write a portion of an array of characters. ... */text.length/** Write a string. *//** Write a portion of a string. ... *//** Return the buffer's current value as a string. *//** Flush the stream. *//** Closing a <tt>StringWriter</tt> has no effect. The methods in this ... */getFromInt(...)/** Returns an empty list. ... */import CharSequenceReaderimport static ClosureUtils.hasSingleCharacterArgimport static DefaultGroovyMethods.eachimport static DefaultGroovyMethods.join/** This class defines new groovy methods which appear on String-related JDK ... */String lineSeparator;/** Coerces a CharSequence to a boolean value. A sequence string is coerced to ... *//** Coerces a Matcher instance to a boolean value. ... *//** Provides a method to perform custom 'dynamic' type conversion ... *//** Converts the GString to a File, or delegates to the default ... */File.class/** Returns a (possibly empty) stream. ... *//** Returns an empty stream. ... *//** Returns a lazily concatenated stream whose elements are all the elements of this stream followed by all the elements of the {@link Collection} object. ... *//** Returns a lazily concatenated stream whose elements are all the elements of this stream followed by all the elements of the {@link Iterable} object. ... *//** Returns a lazily concatenated stream whose elements are all the elements of this stream followed by all the elements of the second stream. ... *//** Returns a sequential {@link Stream} containing a single element. ... *//** Returns a sequential {@link Stream} with the specified array as its ... */boxed(...)mapToObj(...)new IntFunction<Character>(...) { ... }toShort(...)new IntFunction<Byte>(...) { ... }toCharacter(...)new IntFunction<Short>(...) { ... }new IntFunction<Boolean>(...) { ... }new IntFunction<Float>(...) { ... }/** Returns a sequential {@link Stream} with the specified element(s) as its ... */new Spliterators.AbstractSpliterator<T>(...) { ... }StreamGroovyMethods$1Spliterators.AbstractSpliterator<T>Spliterator<>.ORDERED/** Turns a CharSequence into a regular expression Pattern. ... *//** Append the GString to the StringBuilder using a more efficient ... *//** Convenience method to uncapitalize the first letter of a CharSequence ... */spliterator(...)spliteratorUnknownSize(...)/** Convenience method to capitalize the first letter of a CharSequence ... *//** Returns an empty sequential {@link Stream}. ... *//** If a value is present in the {@link Optional}, returns a {@link Stream} ... *//** Pads a CharSequence to a minimum length specified by {@code numberOfChars} by adding the space character around it as many times as needed so that it remains centered. ... */center(...)/** Pad a CharSequence to a minimum length specified by {@code numberOfChars}, appending the supplied padding CharSequence around the original as many times as needed keeping it centered. ... */int numCharsint charsToAddString semiPadgetPadding(...)/** Provides an implementation of contains() like {@link java.util.Collection#contains(Object)} to make CharSequences more polymorphic. ... *//** Counts the number of occurrences of a sub CharSequence. ... */new Function<T,Stream<T>>(...) { ... }/** Return a CharSequence with lines (separated by LF, CR/LF, or CR) ... */CharSequence csnew Supplier<Stream<T>>(...) { ... }/** If a value is present in the {@link OptionalInt}, returns an {@link IntStream} ... */getAsInt(...)/** If a value is present in the {@link OptionalLong}, returns a {@link LongStream} ... */getAsLong(...)/** If a value is present in the {@link OptionalDouble}, returns a {@link DoubleStream} ... */getAsDouble(...)/** Returns a sequential {@link IntStream} with the specified array as its ... *//** Returns a sequential {@link LongStream} with the specified array as its ... *//** Drops the given number of chars from the head of this CharSequence ... *//** Returns a sequential {@link DoubleStream} with the specified array as its ... *//** Returns an array containing the elements of the stream. ... *//** A GString variant of the equivalent CharSequence method. ... *//** A String variant of the equivalent CharSequence method. ... *//** Creates a suffix of the given CharSequence by dropping as many characters as possible from the ... */Iterator<> selfIterhasSingleCharacterArg(...)new CharacterIterator(...)new StringIterator(...)CharSequence delegate;int length;new IntFunction<T[]>(...) { ... }/** Accumulates the elements of stream into a new List. ... */new CharSequenceReader(...)/** Iterates through this CharSequence line by line.  Each line is passed ... */new LineIterable(...)/** Iterates through this String a character at a time collecting either the ... */String replacement/** Accumulates the elements of stream into a new Set. ... */Optional<String> replacementFunction<Character,Optional<String>> next/** Processes each regex group matched substring of the given CharSequence. If the closure ... */eachMatch(...)/** Processes each regex group matched substring of the given pattern. If the closure ... *//** Process each regex group matched substring of the given string. If the closure ... *//** Expands all tabs into spaces with tabStops of size 8. ... */expand(...)/** Expands all tabs into spaces. If the CharSequence has multiple ... */StringBuilder builderexpandLine(...)/** Expands all tabs into spaces. Assumes the CharSequence represents a single line of text. ... *//** Finds the first occurrence of a regular expression String within a String. ... *//** Returns the result of calling a closure with the first occurrence of a regular expression found within a CharSequence. ... *//** Finds the first occurrence of a compiled regular expression Pattern within a String. ... *//** Returns the result of calling a closure with the first occurrence of a compiled regular expression found within a String. ... */hasGroup(...)groupCount(...)List<String> groups/** A Writable File. */this.encoding/** Returns a (possibly empty) list of all occurrences of a regular expression (provided as a CharSequence) found within a CharSequence. ... *//** Finds all occurrences of a regular expression string within a CharSequence.   Any matches are passed to the specified closure.  The closure ... *//** Returns a (possibly empty) list of all occurrences of a regular expression (in Pattern format) found within a CharSequence. ... */boolean hasGroup/** Finds all occurrences of a compiled regular expression Pattern within a CharSequence. Any matches are passed to ... */// TODO: Expose this for stream based scenarios?/** Selects a List of characters from a CharSequence using a Collection ... *//** Supports the range subscript operator for CharSequence or StringBuffer with EmptyRange ... *//** Supports the subscript operator for CharSequence. ... *//** Supports the subscript operator for GString. ... *//** Supports the range subscript operator for CharSequence with IntRange. ... *//** Supports the range subscript operator for GString with IntRange. ... *//** Supports the range subscript operator for CharSequence. ... */CharSequence sequence/** Supports the range subscript operator for GString. ... *//** Selects a List of values from a Matcher using a Collection ... */getInclusive(...)/** Supports the subscript operator, e.g. {@code matcher[index]}, for a {@code Matcher}. ... */getCount(...)IllegalStateException ex/** Given a matcher that matches a string against a pattern, returns true when ... */hitEnd(...)/** Supports the subscript operator for String. ... *//** Supports the range subscript operator for String with IntRange. ... *//** Supports the range subscript operator for String. ... *//** Converts the given CharSequence into an array of characters. ... *//** Finds the number of Strings matched to the given Matcher. ... *//** Gets a replacement corresponding to the matched pattern for {@link org.codehaus.groovy.runtime.StringGroovyMethods#replaceAll(CharSequence,Pattern,Closure)}. ... */import NullObject/** Checks whether a Matcher contains a group or not. ... *//** Returns true if a CharSequence only contains whitespace characters. ... *//** Determines if a CharSequence can be parsed as a BigDecimal. ... *//** Base class for all call sites. */CallSiteArray array;NumberFormatException nfe/** Determines if a CharSequence can be parsed as a BigInteger. ... *//** 'Case' implementation for a CharSequence, which uses equals between the ... *//** 'Case' implementation for the {@link java.util.regex.Pattern} class, which allows ... */this.array/** Determines if a CharSequence can be parsed as a Double. ... *//** Determines if a CharSequence can be parsed as a Float. ... *//** Determines if a CharSequence can be parsed as an Integer. ... *//** Determines if a CharSequence can be parsed as a Long. ... *//** Determines if a CharSequence can be parsed as a Number. ... */isBigDecimal(...)/** Returns an {@link java.util.Iterator} which traverses each match. ... */new Iterator<>(...) { ... }StringGroovyMethods$1boolean done, ...;defaultCall(...)CallSiteArray.NOPARAMCallSite storedarray.arraycreateArray(...)/** Overloads the left shift operator to provide an easy way to append multiple ... */// TODO: Deprecate in favor of leftShift(CharSequence,Object): StringBuilder?new StringBuffer(...)/** Overloads the left shift operator to provide syntactic sugar for appending to a StringBuilder. ... *//** Determines if a CharSequence matches the given regular expression. ... *//** Removes a part of a CharSequence by replacing the first occurrence ... *//** Removes a part of a CharSequence. This replaces the first occurrence ... */defaultCallCurrent(...)/** Repeats a CharSequence a certain number of times. ... */callCurrent(...)/** Overloads the {@code ++} operator for the class CharSequence. ... */Character.MIN_VALUEchar lastCharacter.MAX_VALUEdefaultCallStatic(...)setCharAt(...)/** Returns a String with linefeeds and carriage returns normalized to linefeeds. ... */int nxcallStatic(...)/** Pads a CharSequence to a minimum length specified by {@code numberOfChars} by adding the space character ... *//** Pads a CharSequence to a minimum length specified by {@code numberOfChars}, adding the supplied ... *//** Pads a CharSequence to a minimum length specified by {@code numberOfChars} by adding the space ... */padRight(...)/** Pads a CharSequence to a minimum length specified by {@code numberOfChars}, adding the supplied padding ... */defaultCallConstructor(...)callConstructor(...)/** Appends the String representation of the given operand to this CharSequence. ... *//** Appends a String to the string representation of this number. ... *//** Appends the String representation of the given operand to this string. ... *//** Appends a String to this StringBuffer. ... *//** Overloads the {@code --} operator for the class CharSequence. ... *//** Supports the range subscript operator for StringBuffer. ... *//** Supports the range subscript operator for StringBuffer.  Index values are ... *//** Returns the lines of a CharSequence as a List of String. ... */CachedClass[] paramClasses/** Replaces each substring of this CharSequence that matches the given ... */paramClasses.length/** Replaces all occurrences of a captured group by the result of calling a closure on that text. ... */CachedClass paramClassisDirectlyAssignable(...)/** Replaces all substrings of a CharSequence that match the given ... *//** Replaces all occurrences of a captured group by the result of a closure call on that text. ... */acceptGetProperty(...)StringBuffer sbgetReplacement(...)appendReplacement(...)quoteReplacement(...)appendTail(...)acceptGroovyObjectGetProperty(...)/** Replaces the first substring of this CharSequence that matches the given ... */createGetPropertySite(...)createGroovyObjectGetPropertySite(...)new NullCallSite(...)createClassMetaClassGetPropertySite(...)createPojoMetaClassGetPropertySite(...)/** Replaces the first occurrence of a captured group by the result of a closure call on that text. ... *//** Replaces the first substring of a CharSequence that matches the given ... *//** Helper class used by {@link #replace(CharSequence,Map)}. */this.noMoreMatchesthis.replacementsListMap<>.Entry<CharSequence,CharSequence>int textIndex;int tempIndex;int replaceIndex;int start;...[] noMoreMatches;List<Entry<CharSequence,CharSequence>> replacementsList;isMarkedInternal(...)createPogoMetaClassGetPropertySite(...)createPogoGetPropertySite(...)CallSite sitenew PojoMetaClassGetPropertySite(...)MetaProperty effectivegetEffectiveGetMetaProperty(...)new GetEffectivePojoFieldSite(...)new GetEffectivePojoPropertySite(...)new ClassMetaClassGetPropertySite(...)/** Replaces all occurrences of replacement CharSequences (supplied via a map) within a provided CharSequence. ... */new PogoMetaClassGetPropertySite(...)this.array.owner/** Replaces all occurrences of replacement CharSequences (supplied via a map) within a provided CharSequence ... */new GetEffectivePogoFieldSite(...)new GetEffectivePogoPropertySite(...)ReplaceState statenew ReplaceState(...)new PogoGetPropertySite(...)guessCapacity(...)int textLengthnextMatch(...)callGetProperty(...)state.textIndexstate.startcallGroovyObjectGetProperty(...)// fall threwstate.replaceIndex/** Crude heuristic for setting the created StringBuilder capacity if not supplied: ... */boolean possiblyBiggerEntry<CharSequence,CharSequence> entry/** Helper method to find the next match for the replace method. */numReplacements(...)state.noMoreMatchesstate.tempIndex/** Creates a String which is the reverse (backwards) of this CharSequence ... *//** Sets the position of the given Matcher to the given index. ... *//** Helper class for internal use only. ... */BooleanReturningMethodInvoker bmi;Closure<> wrapped;int numberOfArguments;this.wrapped/** Provides the standard Groovy {@code size()} method for {@code CharSequence}. ... *//** Provides the standard Groovy {@code size()} method for {@code Matcher}. ... *//** Provides the standard Groovy {@code size()} method for {@code String}. ... *//** Provides the standard Groovy {@code size()} method for {@code StringBuffer}. ... *//** Compares a String representing a number to another. A fluent API style alias for {@code compareTo} on {@code BigDecimal}. ... *//** Splits a CharSequence (with whitespace as delimiter). Similar to tokenize, but returns an Array of String instead of a List. ... */StringTokenizer stcountTokens(...)String[] strings/** Iterates through the given CharSequence line by line, splitting each line using ... *//** If the call to the backing {@link Closure} is done on a {@link Closure} ... *//** Strips leading spaces from every line in a CharSequence. The ... */int runningCountisAllWhitespace(...)findMinimumLeadingSpaces(...)stripIndent(...)/** Same logic as {@link #stripIndent(CharSequence)} if {@code forceGroovyBehavior} is {@code true}, ... */MethodHandle mh/** Strips {@code numChars} leading characters from every line in a CharSequence. ... */this.bmistripIndentFromLine(...)// TODO: Expose this for stream based stripping?/** Strips leading whitespace/control characters followed by '|' from ... */stripMargin(...)/** Strips leading whitespace/control characters followed by {@code marginChar} from ... */stripMarginFromLine(...)String mc// TODO: Expose this for other usage scenarios, e.g. stream based stripping?/** Returns the first {@code num} elements from this CharSequence. ... *//** Returns the longest prefix of this CharSequence where each ... *//** A GString variant of the equivalent GString method. ... *//** Parses a CharSequence into a BigDecimal ... *//** Parses a CharSequence into a BigInteger ... *//** Converts the given string into a Boolean object. If the trimmed string is ... */String trimmed/** Converts the given string into a Character object ... *//** Parses a CharSequence into a Double. ... *//** Parses a CharSequence into a Float. ... *//** Parses a CharSequence into an Integer. ... *//** Tokenizes a CharSequence (with a whitespace as the delimiter). ... *//** Tokenizes a CharSequence based on the given character delimiter. ... *//** Tokenizes a CharSequence based on the given CharSequence. Each character ... *//** Converts the given CharSequence into a List of Strings of one character. ... *//** Parses a CharSequence into a Long ... *//** Converts the given CharSequence into a Set of unique Strings of one character. ... *//** Parses a CharSequence into a Short. ... *//** Translates a CharSequence by replacing characters from the sourceSet with characters from replacementSet. ... *//** Replaces sequences of whitespaces with tabs using tabStops of size 8. ... */unexpand(...)/** Replaces sequences of whitespaces with tabs. ... */unexpandLine(...)/** Replaces sequences of whitespaces with tabs within a line. ... */String piece/** Tests if this CharSequence starts with any specified prefixes. ... */CharSequence prefix/** Tests if this CharSequence ends with any specified suffixes. ... */CharSequence suffix/** Tests if this CharSequence is blank. ... *//** Returns the last {@code num} elements from this CharSequence. ... */int begin/** A GString variant of the equivalent CharSequence method {@link #takeRight(CharSequence,int)}. ... *//** A String variant of the equivalent CharSequence method {@link #takeRight(CharSequence,int)}. ... *//** Returns the {@code CharSequence} that exists after the first occurrence of the given ... *//** A String variant of the equivalent CharSequence method {@link #takeAfter(CharSequence,CharSequence)}. ... */takeAfter(...)/** A GString variant of the equivalent CharSequence method {@link #takeAfter(CharSequence,CharSequence)}. ... *//** Returns the {@code CharSequence} that exists before the first occurrence of the given ... *//** A GString variant of the equivalent CharSequence method {@link #takeBefore(CharSequence,CharSequence)}. ... */takeBefore(...)/** A String variant of the equivalent CharSequence method {@link #takeBefore(CharSequence,CharSequence)}. ... *//** Returns new CharSequence after removing the right {@code num} chars. ... *//** A String variant of the equivalent CharSequence method {@link #dropRight(CharSequence,int)}. ... *//** A GString variant of the equivalent CharSequence method {@link #dropRight(CharSequence,int)}. ... *//** Returns the CharSequence that is in between the first occurrence of the given {@code from} and {@code to} ... */String fint fiint ti/** A String variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence,CharSequence)}. ... */takeBetween(...)/** A GString variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence,CharSequence)}. ... *//** Takes the characters between the first occurrence of the two subsequent {@code enclosure} strings. ... *//** A String variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence)}. ... *//** A GString variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence)}. ... *//** Returns the CharSequence that is in between the given the nth (specified by occurrence) pair of ... *//** A String variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence,CharSequence,int)}. ... *//** A GString variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence,CharSequence,int)}. ... *//** Takes the characters between nth (specified by occurrence) pair of {@code enclosure} strings. ... *//** A String variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence,int)}. ... *//** A GString variant of the equivalent CharSequence method {@link #takeBetween(CharSequence,CharSequence,int)}. ... *//** Checks whether this CharSequence starts with the {@code searchString} ignoring the case considerations. ... *//** Checks whether this CharSequence ends with the {@code searchString} ignoring the case considerations. ... *//** Checks whether this CharSequence contains the {@code searchString} ignoring the caseConsiderations. ... *///GROOVY-8855// break once idx goes to -1 or for case of empty string once// we get to the end to avoid JDK library bug (see GROOVY-5858)// Don't do this in static initializer because we may never be needed.// TODO: Put this lineSeparator property somewhere everyone can use it.// use BufferedWriter rather than System.getProperty because it has// the security manager rigamarole to deal with the possible exception// This shouldn't happen, but this is the same default used by// BufferedWriter on a security exception.// GROOVY-7873: GString calls toString() on each invocation of CharSequence methods such// as charAt which is very expensive for large GStrings.// Eat the following LF if any.// for binary compatibility only// lazy create for edge-case efficiency// output differs from input; we write to our local buffer// earlier output differs from input; we write to our local buffer// remove the normalized ending line ending if it was not present/** Helper class for internal use only. This allows to call a {@link Closure} and ... *//** normal closure call *//** Bridge for a call based on a map entry. If the call is done on a {@link Closure} ... */// are we using groups?// yes, so return the specified group as list// not using groups, so return the nth// occurrence of the pattern// skip the LF in CR LF/** Helper class for internal use only. This allows to call a given method and ... */CallSiteArray csa;new CallSiteArray(...)BooleanReturningMethodInvoker.classcsa.array// make cached call for given method// UncheckedThrow allows throwing checked exceptions without declaring a throws// handle conversion to boolean// it was not null and not boolean, so call asBoolean// modelled very closely on the commons lang StringUtils replaceEach method// don't take blank lines into account for calculating the indent// normalize an empty or whitespace line to \n// or strip the indent for lines containing non-space characters// TODO IllegalArgumentException for marginChar.length() > 1 ? Or support String as marker?// cut original string in tabstop-length pieces// count trailing whitespace characters// replace if whitespace was found...[] NOPARAM;...[] array;Class<> owner;new IntFunction<AbstractCallSite>(...) { ... }new IntFunction<CallSite[]>(...) { ... }new CallSite[]createCallSite(...)createCallCurrentSite(...)getArray(...).ownercreateCallStaticSite(...)createCallConstructorSite(...)replaceCallSite(...)new PogoInterceptableSite(...)// otherwise or if method doesn't exist we make call via POJO meta class// for MetaClassImpl we try to pick meta method,getTheCachedClass(...).classInfohasPerInstanceMetaClasses(...)new PerInstancePojoMetaClassSite(...)createPogoSite(...)createPojoSite(...)getArray(...).array// force <clinit>Class<> callClassboolean useInterfaceint invokeMethodCodeOpcodes.INVOKEVIRTUALClass<?>[] parametersLabel catchStartOpcodes.ALOADOpcodes.IFEQOpcodes.INVOKESTATICOpcodes.INVOKEINTERFACEOpcodes.AALOADOpcodes.ACONST_NULLOpcodes.ARETURNOpcodes.ATHROWStringBuilder pdescbint pcgetParamsCount(...)writeMethod(...)Opcodes.INVOKESPECIALOpcodes.PUTSTATICOpcodes.RETURNclassHeader(...)genConstructor(...)genCallXxxWithArray(...)genCallWithFixedParams(...)makeClassWriter(...)CachedClass declClassCallSiteClassLoader callSiteLoadergetCallSiteLoader(...)genPogoMetaMethodSite(...)defineClassAndGetConstructor(...)genPojoMetaMethodSite(...)genStaticMetaMethodSite(...)containsOnlyValidChars(...)publicParams(...)method.cachedClassClass<> nativeParamTypeString encoded// call for checking if method is still valid// valid method branch// prepare call// unpack argument from Object[]// cast argument to parameter class, inclusive unboxing// for methods with primitive types// make call// produce result// fall back after method change// exception unwrapping for stackless exceptions// TODO: this might not do enough or too much// But it is a good start without spreading logic everywhereClass<> aClass;int version;this.aClass// metaClass is invalid/** Call site for invoking static methods ... */this.version// meta class match receiver// metaClass still be validcheckCall(...)noWrappers(...)noCoerce(...)new ConstructorSiteNoUnwrap(...)new ConstructorSiteNoUnwrapNoCoerce(...)new ConstructorSite(...)/** Call site where we know there is no need to unwrap arguments *//** Call site where we know there is no need neither unwrap nor coerce arguments */...[] NO_ARGS;CachedField effective;this.effectiveisEffective(...)/** User: applerestore ... */MetaProperty effective;MetaClassImpl metaClass;int metaClassVersion;this.metaClassVersionimport SunClassLoaderSunClassLoader.sunVMnew GroovySunClassLoader(...)ClassReader.SKIP_CODEloadAbstract(...)loadFromRes(...)GroovySunClassLoader.classClassVisitor cvnew ClassVisitor(...) { ... }GroovySunClassLoader$1/** Call site for constructor ... *//** Call site which holds reference to meta class. *//** Call site which caches meta method *//** Plain ordinary object call site ... *//** Call site for GroovyInterceptable */import ClassLoaderForClassArtifactsSet<String> KNOWN_CLASSES;array.owner// in case there's nothing else, invoke the receiver's own invokeMethod()// GROOVY-9387: in rare cases, this form still works/** POGO call site ... */boolean skipVersionCheck;nonParamCheck(...)/** POJO call site ... */CachedMethod.classcreateCachedMethodSite(...)createNonAwareCallSite(...)new PogoMetaMethodSiteNoUnwrap(...)new PogoMetaMethodSiteNoUnwrapNoCoerce(...)new PogoMetaMethodSite(...)// metaClass is still validnew PogoCachedMethodSiteNoUnwrap(...)new PogoCachedMethodSite(...)Method reflect;super.metaMethodcheckPojoMetaClass(...)new PojoCachedMethodSiteNoUnwrap(...)new PojoCachedMethodSite(...)new PojoMetaMethodSiteNoUnwrap(...)new PojoMetaMethodSiteNoUnwrapNoCoerce(...)new PojoMetaMethodSite(...)new StaticMetaMethodSiteNoUnwrap(...)new StaticMetaMethodSite(...)/** Divide two Numbers. ... */createNumberNumber(...)new IntegerFloat(...)new IntegerDouble(...)new LongFloat(...)new LongDouble(...)new FloatInteger(...)new FloatLong(...)new FloatFloat(...)new FloatDouble(...)new DoubleInteger(...)new DoubleLong(...)new DoubleFloat(...)import CallSiteAwareMetaMethodnew DoubleDouble(...)new NumberNumber(...)CachedClass NUMBER_CLASS;...[] NUMBER_CLASS_ARR;NumberMath math;getMath(...)Object firstArgcreateIntegerInteger(...)createIntegerLong(...)createIntegerFloat(...)createIntegerDouble(...)createLongInteger(...)createLongLong(...)createLongFloat(...)createLongDouble(...)createFloatInteger(...)createFloatLong(...)createFloatFloat(...)createFloatDouble(...)createDoubleInteger(...)createDoubleLong(...)createDoubleFloat(...)createDoubleDouble(...)/** Subtraction of two Numbers. ... */divideImpl(...)new IntegerInteger(...)new IntegerLong(...)new LongInteger(...)new LongLong(...)//Note:  This method is NOT called if left AND right are both BigIntegers or BigDecimals because/** Multiply two Numbers. ... */subtractImpl(...)/** Add two numbers and return the result. ... */multiplyImpl(...)CachedClass INTEGER_CLASS;...[] INTEGER_CLASS_ARR;new NumberNumberCallSite(...) { ... }NumberNumberPlus$1addImpl(...)CachedClass ARR_CLASS;boolean[] objectsobjects.lengthnew MyPojoMetaMethodSite(...)...[] PARAM_CLASS_ARR;byte[] objectschar[] objectsgetCharFromSizeOneString(...)double[] objectsfloat[] objectsCharacter chint[] objectslong[] objectsCachedClass OBJECT_ARR_CLASS;Object[] objectsadjustNewValue(...)Class<> arrayComponentClassshort[] objectsObject adjustedNewVal/** An extension module is a class responsible for providing a list of {@link MetaMethod meta methods} to the Groovy ... */String version;String sb/** The extension method registry is responsible for collecting methods (or static methods) which are added to existing ... */new LinkedList<ExtensionModule>(...)/** A module extension scanner is responsible for searching classpath modules, ... */String LEGACY_MODULE_META_INF_FILE;String MODULE_META_INF_FILE;ExtensionModuleListener listener;scanClasspathModulesFrom(...)Enumeration<URL> resourcesscanExtensionModuleFromMetaInf(...)Properties propertiesInputStream inStreamscanExtensionModuleFromProperties(...)StandardPropertiesModuleFactory factorynew StandardPropertiesModuleFactory(...)ExtensionModule modulenewModule(...)onModule(...)// DO NOTHING/** A {@link SimpleExtensionModule} implementation which reads extension classes ... */MetaInfExtensionModule.classList<ExtensionModule> modules;String MODULE_INSTANCE_CLASSES_KEY;String MODULE_STATIC_CLASSES_KEY;List<Class<>> instanceExtensionClasses;List<Class<>> staticExtensionClasses;new ArrayList<ExtensionModule>(...)this.instanceExtensionClassesthis.staticExtensionClassesPropertiesModuleFactory.MODULE_NAME_KEYString versionPropertiesModuleFactory.MODULE_VERSION_KEYString[] extensionClassesString[] staticExtensionClassesList<Class<>> instanceClassesextensionClasses.length/** This is the base class for classes responsible for creating modules ... */String MODULE_NAME_KEY;String MODULE_VERSION_KEY;List<Class<>> staticClassesstaticExtensionClasses.lengthList<String> errors/** An extension module which provides extension methods using a {@link org.codehaus.groovy.runtime.DefaultGroovyMethods}-like implementation, that ... */SimpleExtensionModule.classnew LinkedList<MetaMethod>(...)loadExtensionClass(...)new MetaInfExtensionModule(...)String extensionClassList<Class<>> extensionClassesgetInstanceMethodsExtensionClasses(...)Class<> extensionClasscreateMetaMethods(...)getStaticMethodsExtensionClasses(...)// an extension method is found/** This is the standard Groovy module factory. This factory will build a module ... */String MODULE_FACTORY_KEY;String factoryNameClass<? extends PropertiesModuleFactory> factoryClassPropertiesModuleFactory delegate/** Represents a simple key-value cache, which is NOT thread safe and backed by a {@link java.util.Map} instance ... *//** The default load factor *//** The default initial capacity */Map<K,V> map;/** Constructs a cache with unlimited size *//** Represents a simple key-value cache, which is thread safe and backed by a {@link java.util.Map} instance ... */ReentrantReadWriteLock.ReadLock readLock;ReentrantReadWriteLock.WriteLock writeLock;CommonCache<K,V> commonCache;new CommonCache<K,V>(...)/** Constructs a cache with limited size ... *//** Constructs a LRU cache with the specified initial capacity and max size. ... *//** Constructs a LRU cache with the default initial capacity(16) ... *//** Constructs a cache backed by the specified {@link java.util.Map} instance ... */doWithReadLock(...)new Action<K,V,V>(...) { ... }new LinkedHashMap<K,V>(...) { ... }CommonCache$1doWithWriteLock(...)EvictionStrategy.LRUconvertValue(...)/** Constructs a LRU cache with the default initial capacity ... */provide(...)this.mapnew Action<K,V,Collection<V>>(...) { ... }new Action<K,V,Set<Entry<K,V>>>(...) { ... }new Action<K,V,Set<K>>(...) { ... }keys(...)new Action<K,V,Boolean>(...) { ... }new Action<K,V,Integer>(...) { ... }new Action<K,V,Object>(...) { ... }List<K> keysnew LinkedList<K>(...)new Action<K,V,Map<K,V>>(...) { ... }cleanUpNullReferences(...)/** deal with the backed cache guarded by write lock ... */doWith(...)/** deal with the backed cache guarded by read lock ... */// try to find the cached value again/** Represents concurrent cache holding SoftReference instance as value ... *//** Represents an evictable memoize cache with its essential methods ... *//** Remove the cached value by the key ... *//** Clear the cache ... *//** Get all cached values ... *//** Get all keys associated to cached values ... *//** Determines if the cache contains an entry for the specified key. ... *//** Get the size of the cache ... *//** Represents a eviction strategy for the cache with limited size */new EvictionStrategy(...)EvictionStrategy LRU;/** The oldest entry(i.e. the Less Recently Used entry) will be evicted */EvictionStrategy FIFO;/** Entries are evicted in the same order as they come in *//** Represents the action to deal with the cache ... *//** Deal with the cache ... */import ConcurrentLinkedHashMap/** A cache backed by a ConcurrentLinkedHashMap */ConcurrentMap<K,V> map;/** Protects stored resources from eviction from memory following the LRU (Last Recently Used) strategy. ... */int maxSize;this.maxSize/** The eldest entry should be removed when we reached the maximum cache size *//** The touch method can be used to renew an element and move it to the from of the LRU queue. ... *//** Makes sure the retrieved object is moved to the head of the LRU list */ConcurrentLinkedHashMap<>.Builder<K,V>/** Performs a shallow clone ... *//** Try to get the value from cache. ... *//** Remove all entries holding SoftReferences to gc-evicted objects. */Iterator<Entry<K,V>> iteratorimport static Arrays.asListimport static Arrays.copyOf/** Implements memoize for Closures. ... */new MemoizeNullValue(...)MemoizeNullValue MEMOIZE_NULL;/** A place-holder for null values in cache *//** Creates a new closure delegating to the supplied one and memoizing all return values by the arguments. ... */new MemoizeFunction<V>(...)/** Represents a memoize cache with its essential methods ... *//** Associates the specified value with the specified key in the cache. ... *//** Gets a value from the cache ... */ProtectionStorage<> lruProtectionStoragenew LRUProtectionStorage(...)new NullProtectionStorage(...)ReferenceQueue<> queuenew ReferenceQueue<>(...)new SoftReferenceMemoizeFunction<V>(...)/** Invoked when some of the held SoftReferences have been evicted by the garbage collector and so should be removed from the cache. ... *//** Represents a provider used to create value ... *//** Provide the created value *//** Creates a key to use in the memoize cache ... */Object[] copyOfArgs/** A NullObject pattern implementation for ProtectionStorage ... *//** Does nothing ... *//** A place-holder for cached null values */MemoizeCache<Object,Object> cache;Closure<V> closure;this.cachegenerateKey(...)new ValueProvider<Object,Object>(...) { ... }ProtectionStorage<> lruProtectionStorage;ReferenceQueue<> queue;this.lruProtectionStoragethis.queuenew SoftReference<Object>(...)touch(...)/** After the garbage collector has done its job, we need to clean the cache from references to all the evicted memoized values. ... */// Nothing should be done when no elements need protection against eviction//noinspection GroovyConditionalCanBeElvis// if something has been evicted, do a clean-up//empty the reference queueimport StampedLock/** A cache backed by a ConcurrentHashMap *//** Represents a simple key-value cache, which is thread safe and backed by a {@link Map} instance. ... */ConcurrentHashMap<K,V> map;new StampedLock(...)StampedLock sl;/** Constructs a cache backed by the specified {@link Map} instance ... */long optimisticReadStamptryOptimisticRead(...)long stamplong wstryConvertToWriteLock(...)unlockRead(...)/** Constructs a cache with unlimited size and set its initial capacity ... *//** Constructs a cache and initialize the cache with the specified map ... */unlockWrite(...)R result// try optimistic read first, which is non-blocking// if stale, read again// the new local variable `ws` is necessary here!// Failed to convert read lock to write lock// try to read again/** To support caches whose values are convertable, e.g. SoftReference, WeakReference ... *//** convert the original value to the target value ... */import ProxyMetaClassboolean removed/** A meta class for closures generated by the Groovy compiler. These classes ... */new HashMap<String,CachedField>(...)/** Replying on the ConcurrentHashMap thread-safe iteration implementation the method will remove all entries holding ... */Object entryValboolean initialized, ...;FastArray closureMethods;Map<String,CachedField> attributes;MethodChooser chooser;MetaClassImpl classMetaClass;MetaClassImpl CLOSURE_METACLASS;String CLOSURE_CALL_METHOD;String CLOSURE_DO_CALL_METHOD;MetaClassImpl tempClosureMetaClass.classMetaMethod doCall0;MetaMethod doCall1;FastArray methods;chooseMostGeneralMethodWith1NullParam(...)List<> matchingMethodsMetaMethod interceptMethodClosureMetaClass$1makeArguments(...)boolean shouldDeferisInternalMethod(...)Object callObjectboolean invokeOnDelegateboolean invokeOnOwnerboolean ownerFirstpickClosureMethod(...)Class<?>[] newArgClassesgetDelegateMethod(...)invokeOnDelegationObjects(...)Closure<?> clMissingMethodException firstCachedField[] fieldArrayCachedField aFieldArrayCachedMethod[] methodArrayassignMethodChooser(...)MetaMethod doCallCachedClass[] cc.lengthnew MethodChooser(...) { ... }boolean allObjectint minimumLengthMetaMethod m0MetaMethod m1new StandardClosureChooser(...)new NormalMethodChooser(...)List<MetaMethod> answerMetaClassHelper.EMPTY_CLASS_ARRAYgetStaticMetaClass(...)initAttributes(...)loadMetaInfo(...)// GROOVY-3015: must route calls through GroovyObject#invokeMethod(String,Object)// Closure.OWNER_FIRST:// no method was found; try to find a closure defined as a field of the class and run it// This test ensures that value != this If you ever change this ensure that value != this// patch needed here too, but we need a test case to trip it first// just a dummy for later// no arg method// Object fits all, so simple dispatch rule here// <2, because foo() is same as foo(null)// all arguments are object, so test only if argument number is correct// all arguments are Object but last, which is a vargs argument, that// will fit all, so just test if the number of argument is equal or// more than the parameters we have.// general case for single method// standard closure (2 methods because "it" is with default null)// standard chooser for cases if it is not a single method and if it is// not the standard closure.import ClosureInvokingMethod/** This class represents a MetaMethod that is a closure that pretends to be a static method. ... */Closure<> callable;/** A MetaMethod that accepts a closure in the constructor which is invoked when the MetaMethod is called. ... */CachedMethod doCall;this.callableClosure<> cloned/** Retrieves the closure that is invoked by this MetaMethod ... */this.doCall/** A hash table that supports mostly-concurrent reading, but ... */new BarrierLock(...)/** A Serializable class for barrier lock * *//* The basic strategy is an optimistic-style scheme based on ... */BarrierLock barrierLock;/** Lock used only for its memory effects. */Object lastWrite;/** field written to only to guarantee lock ordering. *//** Force a memory synchronization that will cause ... *//** Get ref to table; the reference and the cells it ... *//** The default initial number of table slots for this table (32). ... */int MINIMUM_CAPACITY;/** The minimum capacity, used if a lower value is implicitly specified ... *//** The maximum capacity, used if a higher value is implicitly specified ... *//** The default load factor for this table (1.0). ... *//** The hash table data. *//** The total number of mappings in the hash table. *//** The table is rehashed when its size exceeds this threshold.  (The ... *//** The load factor for the hash table. ... *//** Returns the appropriate capacity (power of two) for the specified ... *//** Return hash code for Object x. Since we are using power-of-two ... *//** Check for equality of non-null references x and y. *//** Constructs a new, empty map with the specified initial ... */p2capacity(...)this.loadFactornew Entry[]/** Constructs a new, empty map with a default initial capacity ... *//** Constructs a new map with the same mappings as the given map.  The ... */MethodClosure methodClosurenew MethodClosureMetaMethod(...)/** Returns the number of key-value mappings in this map. ... */adjustParamTypesForStdMethods(...)/** Returns the value to which the specified key is mapped in this table. ... */new ClosureMetaMethod(...)Entry[] tabEntry firstEntry[] rereadgetTableForReading(...)new AnonymousMetaMethod(...)Class<>[] nativeParamTypese.keye.valuenativeParamTypes.length/** Maps the specified <code>key</code> to the specified ... */getDoCall(...)Class<> declaringClass;Entry newEntrynew Entry(...)recordModification(...)sput(...)/** Continuation of put(), called only when sync lock is ... */// for methodMissing, first parameter should be String type - to allow overriding of this method without// type String explicitly specified for first parameter (missing method name) - GROOVY-2951/** Rehashes the contents of this map into a new table ... */Entry[] oldTableint newCapacityEntry[] newTableEntry nextEntry lastRunEntry last/** WARNING: This class is for internal use only! ... */Entry pp.keyp.value/** Removes the key (and its corresponding value) from this ... */new ConstantMetaClassVersioning(...)boolean origBoolean;// if original boolean meta class//---------------------------------------------//                  booleanboolean origBooleanRes;// if origBoolean and withoutCustomHandle/** sets if the original boolean meta class is used */boolean origByte;// if original Byte meta class//                  byteboolean origByteRes;// if origByte and withoutCustomHandle/** sets if the original byte meta class is used */boolean origChar;// if original char meta class//                  charboolean origCharRes;// if origChar and withoutCustomHandle/** sets if the original char meta class is used */boolean origShort;// if original short meta class//                  shortboolean origShortRes;// if origShort and withoutCustomHandle/** sets if the original short meta class is used */Entry headboolean origInt;// if original Integer meta class//                  intboolean origIntRes;// if origInt and withoutCustomHandlesremove(...)/** Continuation of remove(), called only when sync lock is ... *//** sets if the original int meta class is used */boolean origIntArray;// if original Integer[] meta class//                  int[]boolean origIntArrayWCH;/** sets if the original int array meta class is used */boolean origLong;// if original long meta class//                  longboolean origLongRes;// if origLong and withoutCustomHandle/** sets if the original long meta class is used */boolean origFloat;// if original float meta class//                  floatboolean origFloatRes;// if origFloat and withoutCustomHandle/** sets if the original float meta class is used */boolean origDouble;// if original double meta class//                  doubleboolean origDoubleRes;/** sets if the original double meta class is used */boolean withoutCustomHandle;// if a custom meta class creation handle is set//     custom meta class creation handle/** sets if the system uses a custom meta class creation handle */changeFlags(...)boolean categoryUsed;//              category handle/** Tests if some key maps into the specified value in this table. ... */boolean disabledStandardMC;/** Removes all mappings from this map. */setOrigByte(...)setOrigChar(...)setOrigShort(...)/** Returns a shallow copy of this ... */ConcurrentReaderHashMap tsetOrigInt(...)Entry[] ttabt.tablet.keySett.entrySett.valuesnew InternalError(...)Set<> keySet;// ViewsSet<> entrySet;Collection<> values;/** Returns a set view of the keys contained in this map.  The set is ... */Set<> ksConcurrentReaderHashMap.thissetOrigIntArray(...)setOrigLong(...)setOrigFloat(...)setOrigDouble(...)//         GlobalMetaClassVersioningboolean valid;ConstantMetaClassVersioning constantMetaClassVersioning;Object constantMetaClassVersioningLock;constantMetaClassVersioning.valid/** Returns a collection view of the values contained in this map.  The ... */Collection<> vsimport MetaClassRegistryChangeEventimport MetaClassRegistryChangeEventListenerimport DefaultGroovyStaticMethodsimport ExtensionModuleimport ExtensionModuleRegistryimport ExtensionModuleScanner/** Returns a collection view of the mappings contained in this map.  Each ... */Set<> esnew HashIterator(...)/** A registry of MetaClass instances which caches introspection and ... */new LinkedList<MetaClassRegistryChangeEventListener>(...)findAndRemoveEntry(...)/** Helper method for entrySet.remove *//** ConcurrentReaderHashMap collision list entry. *//* The use of volatile for value field ensures that ... */Entry next;// Map.Entry Ops /** Get the value.  Note: In an entrySet or entrySet.iterator, ... *//** Set the value of this entry.  Note: In an entrySet or ... */...[] tab;// snapshot of tableEntry entry;// current slot Object currentKey;// current node of slotObject currentValue;// key for current nodeEntry lastReturned;// value for current node// last node returned by nextentry.valueentry.keyentry.nextreturnValueOfNext(...)lastReturned.key/** Save the state of the <tt>ConcurrentReaderHashMap</tt> ... */table.length/** Reconstitute the <tt>ConcurrentReaderHashMap</tt> ... */int numBucketsnew ManagedConcurrentLinkedQueue<MetaClass>(...)new ExtensionModuleRegistry(...)// Compute the appropriate capacity// Multiply by 127 (quickly, via shifts), and mix in some high// bits to help guard against bunching of codes that are// consecutive or equally spaced.// throw null pointer exception if key null/* Start off at the apparently correct bin.  If entry is found, we ... */// If key apparently not there, check to// make sure this was a valid read// Wrong list -- must restart traversal at new first// Entry was invalidated during deletion. But it could// have been re-inserted, so we must re-traverse.// To avoid useless contention, get lock to wait out modifications// before re-traversing.//  make sure we are adding to correct list//  Add to front of list// retry if wrong list or lost race against concurrent remove// avoid re-triggering// proceed. So we cannot yet null out each bin.// Reuse trailing consecutive sequence of all same bit/* Find the entry, then ... */// Wrong list or interferencenew MetaClass[]new MetaClassRegistryChangeEventListener[]...[] EMPTY_METACLASS_ARRAY;...[] EMPTY_METACLASSREGISTRYCHANGEEVENTLISTENER_ARRAY;String EXTENSION_DISABLE_PROPERTY;boolean useAccessible;// Expand enough to hold at least n elements without resizing.FastArray instanceMethods;// We can only resize table by factor of two at a time.FastArray staticMethods;// It is faster to rehash with fewer elements, so do it now.LinkedList<MetaClassRegistryChangeEventListener> changeListenerList;LinkedList<MetaClassRegistryChangeEventListener> nonRemoveableChangeListenerList;// must invalidate all to force concurrent get's to wait and then retryManagedConcurrentLinkedQueue<MetaClass> metaClassInfo;ExtensionModuleRegistry moduleRegistry;String disabledString;boolean disabling;Set<String> disabledNames;// this shouldn't happen, since we are Cloneableint LOAD_DEFAULT;int DONT_LOAD_DEFAULT;MetaClassRegistry instanceInclude;MetaClassRegistry instanceExclude;MetaClass emcMetaClassthis.useAccessibleMap<CachedClass,List<MetaMethod>> mapnew HashMap<CachedClass,List<MetaMethod>>(...)/* currentKey and currentValue are set here to ensure that next() ... */// Write out the threshold, loadfactor, and any hidden stuff// Write out number of buckets// Write out size (number of Mappings)// Write out keys and values (alternating)// Read in the threshold, loadfactor, and any hidden stuff// Read in number of buckets and allocate the bucket array;// Read in size (number of Mappings)new LinkedHashMap<Class<>,Header>(...)Class<>[] additionalsDefaultGroovyMethods.ADDITIONAL_CLASSESClass<>[] pluginDGMsgetPluginDefaultGroovyMethods(...)Class<>[] staticPluginDGMsgetPluginStaticGroovyMethods(...)ExtensionModuleScanner scannernew ExtensionModuleScanner(...)new DefaultModuleListener(...)registerMethods(...)additionals.lengthcreateMetaMethodFromClass(...)Class<> pluginDefaultGroovyStaticMethods.classscanClasspathModules(...)refreshMopMethods(...)installMetaClassCreationHandle(...)addNonRemovableMetaClassRegistryChangeEventListener(...)new MetaClassRegistryChangeEventListener(...) { ... }getClassToUpdate(...)getNewMetaClass(...)getNewConstantMetaClassVersioning(...)setPrimitiveMeta(...)Map<Class<>,Header> methodHeaders;Entry head;Class<> cls;Class<> subclass;int clsHashCode31;this.clsthis.subclassthis.clsHashCode31MetaMethod method;Entry nextHashEntry, ...;Object methods, ...;CacheEntry cachedMethod, ...;Entry<CachedClass,List<MetaMethod>> eMap<>.Entry<CachedClass,List<MetaMethod>>setNewMopMethods(...)/** Looks for a class called 'groovy.runtime.metaclass.CustomMetaClassCreationHandle' and if it exists uses it as the MetaClassCreationHandle ... */Class<> customMetaClassHandleConstructor<> customMetaClassHandleConstructorthis.metaClassCreationHandleCachedClass lastList<DgmMethodRecord> recordsloadDgmInfo(...)GeneratedMetaMethod.DgmMethodRecordnew Header(...)new Proxy(...)int DEFAULT_CAPACITY;new Function<CachedClass,List<MetaMethod>>(...) { ... }Object[] tabe.nextHashEntrynew EntryIterator(...) { ... }MetaMethodIndex$1Entry[] tEntry n// next entry to returne.clsheader.clsheader.clsHashCode31entry.nextHashEntryentry.hashentry.nameentry.clsentry.nextClassEntryresize(...)new Function<Class<>,Header>(...) { ... }NewStaticMetaMethod metaMethodfrom.headcopyAllMethodsToSuper(...)/** if oldMc is null, newMc will replace whatever meta class was used before. ... */copyNonPrivateMethodsFromSuper(...)Object oldListOrMethodfrom.methodsFastArray oldListfireConstantMetaClassUpdate(...)/** Registers a new MetaClass in the registry to customize the type ... */from.nameMetaClass oldMCsetPerInstanceMetaClass(...)MetaClassCreationHandle metaClassCreationHandle;/** Gets a handle internally used to create MetaClass implementations ... *//** Sets a handle internally used to create MetaClass implementations. ... */setDisableCustomMetaClassLookup(...)isDisableCustomMetaClassLookup(...)/** Adds a listener for constant meta classes. ... *//** Adds a listener for constant meta classes. This listener cannot be removed! ... *//** Removes a constant meta class listener. ... *//** Causes the execution of all registered listeners. This method is used mostly ... */MetaClassRegistryChangeEventListener[] listenergetMetaClassRegistryChangeEventListeners(...)MetaClassRegistryChangeEvent cmcunew MetaClassRegistryChangeEvent(...)MetaClassRegistryChangeEventListener metaClassRegistryChangeEventListenerupdateConstantMetaClass(...)/** Gets an array of all registered ConstantMetaClassListener instances. */ArrayList<MetaClassRegistryChangeEventListener> retnew ArrayList<MetaClassRegistryChangeEventListener>(...)/** Singleton of MetaClassRegistry. ... *//** Returns an iterator to iterate over all constant meta classes. ... */MetaClass[] refsMetaClassRegistryImpl$1MetaMethod inIndexisMatchingMethod(...)isOverridden(...)FastArray index// index in the ref arrayfindMatchingMethod(...)MetaClass currentMeta;// the current meta classboolean hasNextCalled;// used to ensure that hasNext has been called// the cached hasNext call valuerefs.length/** TODO ... */CachedClass inIndexDCensureNext(...)CachedClass toIndexDCExtensionModuleScanner.ExtensionModuleListenerMap<CachedClass,List<MetaMethod>> map;isNonRealMethod(...)hasModule(...)ExtensionModule loadedModuleClosureMetaMethod.AnonymousMetaMethod// let's register the default methods// The calls to DefaultMetaClassInfo.setPrimitiveMeta and sdyn.setBoolean need to be// ordered. Even though metaClassInfo is thread-safe, it is included in the block// so the meta classes are added to the queue in the same order.// Here we instantiate objects representing MetaMethods for DGM methods.// Calls for such meta methods done without reflection, so more effectively.// we print the error, but we don't stop with an exception here// since it is more comfortable this way for development// we ensure that hasNext has been called before// next is called// already registered// register MetaMethodscopyAllMethods(...)// current slot// advance to first entry// do not overwrite private methods// interface vs instance method; be careful...// GROOVY-9815// GROOVY-3493// this is the old logic created for GROOVY-2391 and GROOVY-7879, which was labeled as "do not overwrite interface methods with instance methods"// prefer most-specific or most-recent for type disjunction/** Some reflection helper methods *//** Wrapper for a method for a property get or set. ... *//** Wrapper for a method realizing the property get. ... *//** Wrapper for a method realizing the property getter. ... */MetaClassImpl.EMPTY_ARGUMENTS/** This exception is thrown if the runtime is unable to select ... *//** Creates a new MethodSelectionException. ... */appendClassNames(...)appendMethods(...)/** A stack less exception used to indicate, that the execution of a missingMethod ... */Throwable cause;Object methodOrConstructorWeakReference<> owner;/** MetaMethod for mixed in classes */MixinInMetaClass mixinInMetaClass;this.mixinInMetaClassnew WeakReference<>(...)getInstanceClass(...)// make sure parameterTypes gets set/** MetaProperty for mixed in classes */createGetter(...)createSetter(...)/** This class represents a property with multiple setters. Unlike a MetaBeanProperty you cannot get the setter ... */new MetaMethod(...) { ... }MixinInstanceMetaProperty$1MixinInstanceMetaProperty$2boolean mfboolean mgMultipleSetterProperty newMsp/** Base class for NewInstanceMetaMethod and NewStaticMetaMethod */...[] bytecodeParameterTypes;/** A MetaMethod implementation where the underlying method is really a static ... */bytecodeParameterTypes.lengthCachedClass[] logicalParameterTypesgetBytecodeParameterTypes(...)// lets clear the static bit// we need to cheat using the typegetOwnerMetaClass(...)CachedMethod method;import Reflector/** Reflector creation helper. This class is used to define the Reflector classes. ... */Reflector.class/** A temporary implementation of MethodKey used to perform a fast lookup ... */...[] parameterValues;this.parameterValuesboolean inDefine;Map<> loadedClasses;parameterValues.lengthClassLoader delegatationLoader;String REFLECTOR;/** Tries to find a Groovy class. ... *//** Loads a class per name. Unlike a normal loadClass this version ... *//** helper method to define Reflector classes. ... */bytecode.length/** creates a ReflectorLoader. ... *//** try to load one of the defined Reflector classes by name. ... */String componentName/** A MetaMethod implementation useful for implementing coercion based invocations */// no coerceArgumentsToClasses/** Creates a string representation of an assertion and its recorded values. */new ArrayList<StringBuilder>(...)new ArrayList<Integer>(...)ValueRecorder recorder;List<StringBuilder> lines;List<Integer> startColumns;// startColumns.get(i) is the first non-empty column of lines.get(i)this.recorder/** Creates a string representation of an assertion and its recorded values. ... */render(...)new AssertionRenderer(...)renderText(...)sortValues(...)renderValues(...)linesToString(...)new Comparator<Value>(...) { ... }List<Value> valuesint valuesSizeValue valueint startColumnValue nextvalueToString(...)String[] strsint endColumnstrs.lengthplaceString(...)StringBuilder newLineStringBuilder firstLine/** Returns a string representation of the given value, or <tt>null</tt> if ... */String toStringjavaLangObjectToString(...)hasStringLikeType(...)StringBuffer.class/** This MetaBeanProperty will create a pseudo property whose value is bound to an object ... */new ConcurrentHashMap<String,ManagedIdentityConcurrentMap<>>(...)// empty line// it's important to use a stable sort here, otherwise// renderValues() will skip the wrong values// skip values with unknown source position// if multiple values are associated with the same column, only// render the value which was recorded last (i.e. the value// corresponding to the outermost expression)// null signals the value shouldn't be rendered// exclusive// multi-line strings are always placed on new lines// make sure that no values are ever placed on empty line// + 1: no whitespace required between end of value and "|"// value could not be placed on existing lines, so place it on new line(s)/** Indicates that a power assertion has failed. */ConcurrentHashMap<String,ManagedIdentityConcurrentMap<>> PROPNAME_TO_MAP;ManagedIdentityConcurrentMap<> instance2Prop;ThreadBoundGetter getter;ThreadBoundSetter setter;Object initialValue;Closure<> initialValueCreator;ReferenceBundle SOFT_BUNDLE;/** Retrieves the initial value of the ThreadBound property ... */getInitialValue(...)/** Closure responsible for creating the initial value of thread-managed bean properties ... */this.initialValueCreator/** Constructs a new ThreadManagedBeanProperty for the given arguments ... */new ThreadBoundGetter(...)new ThreadBoundSetter(...)getInstance2PropName(...)ManagedIdentityConcurrentMap<> resManagedIdentityConcurrentMap<> ores/** Provides the source text for an assertion statement and translates ... *//** Accesses the ThreadBound state of the property as a getter *//** Sets the ThreadBound state of the property like a setter */int firstLine;String normalizedText;List<Integer> lineOffsets;List<Integer> textOffsets;/** Constructs a <tt>SourceText</tt> by reading the given assertion's source ... */StringBuilder normalizedTextBufferhasPlausibleSourcePosition(...)new SourceTextNotAvailableException(...)String lineTextcountLeadingWhitespace(...)/** Returns the assertion's source text after removing line breaks. ... *//** Returns the column in <tt>getNormalizedText()</tt> corresponding ... */int deltaLineint deltaColumn/** Indicates that the source text for an assertion statement is not available. */// only accepts AssertStatementS so that better error messages can be produced// wrong line information// wrong column information/** A value recorded during evaluation of an assertion, along with the column it ... *//** Records values produced during evaluation of an assertion statement's truth ... */new ArrayList<Value>(...)import MathContext/** BigDecimal NumberMath operations */new BigDecimalMath(...)int DIVISION_EXTRA_PRECISION;// for typical user math when a non-terminating result would otherwise occur.// This is an arbitrary value, picked as a reasonable choice for a precisionint DIVISION_MIN_SCALE;//for typical user math.//This is an arbitrary value, picked as a reasonable choice for a rounding pointBigDecimalMath INSTANCE;List<Value> values;new Value(...)BigDecimal bigLeftBigDecimal bigRightArithmeticException eint precisionprecision(...)BigDecimal resultnew MathContext(...)int scalescale(...)// set a DEFAULT precision if otherwise non-terminating/** BigInteger NumberMath operations */new BigIntegerMath(...)BigIntegerMath INSTANCE;BigDecimalMath.INSTANCEimport StreamGroovyMethodsimport static ReflectionCache.isArrayshiftLeft(...)shiftRight(...)/** Class providing various type conversions, coercions and boxing/unboxing operations. */BigInteger ONE_NEG;//                  unboxing methodsNumber ncastToNumber(...)castToChar(...)/** FloatingPoint (Double and Float) NumberMath operations *///                  boxing methodsnew FloatingPointMath(...)FloatingPointMath INSTANCE;String c/** Method used for coercing an object to a boolean value, ... */InvokerHelper.EMPTY_ARGSNumber valuecastToEnum(...)continueCastOnCollection(...)String classToCastFromObject msgObjectcastToClass(...)castToPrimitive(...)continueCastOnNumber(...)Supplier<Collection<>> newCollectionnew Supplier<Collection<>>(...) { ... }Class<> nclsLinkedHashSet<>.class/** Integer NumberMath operations */new IntegerMath(...)IntegerMath INSTANCE;int leftValint rightVal/** Long NumberMath operations */new LongMath(...)LongMath INSTANCE;long leftVallong rightValDouble.NEGATIVE_INFINITYDouble.POSITIVE_INFINITY/** Stateless objects used to perform math on the various Number subclasses. ... */absImpl(...)continueCastOnSAM(...)compareToImpl(...)booleanUnbox(...)orImpl(...)byteUnbox(...)charUnbox(...)andImpl(...)shortUnbox(...)xorImpl(...)longUnbox(...)intdivImpl(...)floatUnbox(...)doubleUnbox(...)modImpl(...)/** For this operation, consider the operands independently.  Throw an exception if the right operand ... */isFloatingPoint(...)Exception nestedException suppressedClass<?> elementTypeCollection<?> collectionleftShiftImpl(...)asLongStream(...)rightShiftImpl(...)asDoubleStream(...)rightShiftUnsignedImpl(...)bitwiseNegateImpl(...)unaryMinusImpl(...)unaryPlusImpl(...)BigDecimal bd/** Determine which NumberMath instance to use, given the supplied operands.  This method implements ... */NumberMath leftMathNumberMath rightMathFloatingPointMath.INSTANCEBigIntegerMath.INSTANCELongMath.INSTANCEIntegerMath.INSTANCEisLong(...)isBigInteger(...)isByte(...)isInteger(...)isShort(...)//Subclasses implement according to the type promotion hierarchy rulescreateUnsupportedException(...)new IntFunction<Integer[]>(...) { ... }// FloatingPointMath wins according to promotion Matrix// also for custom Number implementationsnew IntFunction<Long[]>(...) { ... }new IntFunction<Double[]>(...) { ... }new Function<?,Set<Object>>(...) { ... }new Supplier<Set<Object>>(...) { ... }MethodClosure methodIteratorClosureAdapter<?> adapternew IteratorClosureAdapter<Object>(...)new NumberMathModificationInfo(...)NumberMathModificationInfo instance;HashSet<String> NAMES;NewInstanceMetaMethod.class...[...].isNumbercheckNumberOps(...)doCheckNumberOps(...)new Consumer<Class<>>(...) { ... }/** Determines whether the value object is a Class object representing a ... */Class<> superclass/** Allows conversion of arrays into a mutable List ... *//** Compares the two objects handling nulls gracefully and performing numeric type coercion if required */compareToWithEqualityCheck(...)Exception causeisValidCharacterString(...)Class<> leftClassClass<> rightClassboolean byte_plus;boolean short_plus;boolean int_plus;boolean long_plus;boolean float_plus;boolean double_plus;boolean byte_minus;boolean short_minus;boolean int_minus;boolean long_minus;boolean float_minus;boolean double_minus;boolean byte_multiply;boolean short_multiply;boolean int_multiply;boolean long_multiply;boolean float_multiply;boolean double_multiply;boolean byte_div;boolean short_div;boolean int_div;boolean long_div;boolean float_div;boolean double_div;boolean byte_or;boolean short_or;boolean int_or;compareArrayEqual(...)boolean long_or;boolean float_or;boolean double_or;boolean byte_and;boolean short_and;boolean int_and;boolean long_and;boolean float_and;boolean double_and;boolean byte_xor;boolean short_xor;boolean int_xor;boolean long_xor;boolean float_xor;boolean double_xor;boolean byte_intdiv;boolean short_intdiv;boolean int_intdiv;boolean long_intdiv;boolean float_intdiv;boolean double_intdiv;boolean byte_mod;boolean short_mod;boolean int_mod;boolean long_mod;boolean float_mod;boolean double_mod;boolean byte_leftShift;boolean short_leftShift;boolean int_leftShift;boolean long_leftShift;boolean float_leftShift;boolean double_leftShift;boolean byte_rightShift;boolean short_rightShift;boolean int_rightShift;boolean long_rightShift;boolean float_rightShift;boolean double_rightShift;boolean byte_rightShiftUnsigned;boolean short_rightShiftUnsigned;boolean int_rightShiftUnsigned;boolean long_rightShiftUnsigned;boolean float_rightShiftUnsigned;boolean double_rightShiftUnsigned;Object k1instance.byte_plusplusSlow(...)Object v1Object lint[] ansinstance.short_plusObject[] iaboolean[] ansbyte[] ansinstance.int_plusshort[] ansnew short[]char[] anslong[] ansinstance.long_plusfloat[] ansnew float[]double[] ansnew double[]convertToBooleanArray(...)instance.float_plusconvertToShortArray(...)convertToCharArray(...)convertToIntArray(...)convertToLongArray(...)convertToFloatArray(...)convertToDoubleArray(...)Class<?> componentTypeorigin.lengthObject newArrayObject convertedValueinstance.double_plus// default to Number class in exception details, else use the specified Number subtype.// null is always false// equality check is enough and faster than instanceof check, no need to check superclasses since Boolean is final// if the object is not null and no Boolean, try to call an asBoolean() method on the object// we cannot just wrap in a List as we support primitive type arrays//throw a runtime exception if conversion would be out-of-range for the type.//nothing else possible// let's try invoke the constructor with the list as arguments// such as for creating a Dimension, Point, Color etc.// emulate named params constructor// let's ignore exception and return the original object// as the caller has more context to be able to throw a more// meaningful exception (but stash to get message later)// keep the original exception as suppressed exception to allow easier failure analysis// GROOVY-10223// let's assume it's a collection of 1//GROOVY-4046// GROOVY-7954// GROOVY-7876: when comparing for equality we try to only call compareTo when an assignable// relationship holds but with a container/holder class and because of erasure, we might still end// up with the prospect of a ClassCastException which we want to ignore but only if testing equality// GROOVY-9711: don't rely on Java method selection// anything other than 0// handle arrays on both sides as special case for efficiency// conservative codinginstance.byte_minusminusSlow(...)instance.short_minus/** Class providing various short paths for type conversions. Read the comments ... */instance.int_minusinstance.long_minusinstance.float_minus/** this class requires that the supplied enum is not fitting a ... */instance.double_minusinstance.byte_multiplymultiplySlow(...)instance.short_multiplyinstance.int_multiplyinstance.long_multiplyinstance.float_multiplyinstance.double_multiplyGroovyObject wrapped;instance.byte_divdivSlow(...)instance.short_divObject wrapped;instance.int_divClass<> constrainedType;this.constrainedTypegetDelegatedMetaClass(...)instance.long_divinstance.float_div/** A common base class of AST helper methods which can be shared across the classic and new parsers */instance.double_divinstance.byte_ororSlow(...)SourceUnit controller;/** The SourceUnit controlling us *//** Our ClassLoader, which provides information on external types */ModuleNode output;/** The package name in which the module sits */Map<> resolutions;// TODO should this really be static???// cleared on build(), to be safeinstance.short_orinstance.int_orinstance.long_orinstance.byte_andandSlow(...)instance.short_andinstance.int_andinstance.long_andinstance.byte_xorxorSlow(...)instance.short_xorinstance.int_xorinstance.long_xorinstance.byte_intdivintdivSlow(...)instance.short_intdiv/** Returns our class loader (as supplied on construction). */instance.int_intdiv/** A synonym for <code>dot( base, "" )</code>. */dot(...)instance.long_intdivinstance.byte_modmodSlow(...)instance.short_mod/** An abstract base class for nodes in the concrete syntax tree that is ... *//** Returns the meaning of this node.  If the node isEmpty(), returns ... */// NODE IDENTIFICATION AND MEANINGgetMeaning(...)getRoot(...)/** Sets the meaning for this node (and its root Token).  Not ... */setMeaning(...)/** Returns the actual type of the node.  If the node isEmpty(), returns ... *//** Returns true if the node can be coerced to the specified type. */canMean(...)/** Returns true if the node's meaning matches the specified type. */ofType(...)/** Returns true if the node's meaning matches any of the specified types. */int meaning/** Returns true if the node's meaning matches all of the specified types. *//** Returns the first matching meaning of the specified types. ... */Types.UNKNOWNinstance.int_mod/** Returns true if the node matches the specified type.  Effectively ... */// TYPE SUGAR/** Returns true if the node and its first child match the specified ... *//** Returns true if the node and its first and second child match the ... *//** Returns true if the node and its first three children match the ... *//** Returns true if the node an its first four children match the ... *//** Returns true if the node is completely empty (no root, even). */// MEMBER ACCESS/** Returns the number of elements in the node (including root). *//** Returns true if the node has any non-root elements. *//** Returns the number of non-root elements in the node. *//** Returns the specified element, or null. *//** Returns the specified element, or Token.NULL if ... */instance.long_modCSTNode elementToken.NULL/** Returns the root of the node.  By convention, all nodes have ... *//** Returns the root of the node, the Token that indicates its ... */Token root/** Returns the text of the root.  Uses <code>getRoot(true)</code> ... *//** Returns a description of the node. *//** Returns the starting line of the node.  Returns -1 ... *//** Returns the starting column of the node.  Returns -1 ... *//** Marks the node a complete expression.  Not all nodes support this operation! *//** Returns true if the node is a complete expression. */Types.SIMPLE_EXPRESSION/** Adds an element to the node.  Returns the element for convenience. ... */// OPERATIONS/** Adds all children of the specified node to this one.  Not all ... *//** Sets an element node in at the specified index.  Returns the element ... *//** Creates a <code>Reduction</code> from this node.  Returns self if the ... *//** Formats the node as a <code>String</code> and returns it. */// STRING CONVERSIONWriter stringinstance.byte_leftShift/** Formats the node and writes it to the specified <code>Writer</code>. */leftShiftSlow(...)/** Formats the node and writes it to the specified <code>Writer</code>. ... */instance.short_leftShiftString indent1String indent2instance.int_leftShift// Display our type, text, and (optional) meaning// Recurse to display the children.instance.long_leftShiftinstance.byte_rightShiftrightShiftSlow(...)instance.short_rightShiftinstance.int_rightShift/** Helper class for processing Groovy numeric literals. */Double.MAX_VALUEFloat.MAX_VALUEinstance.long_rightShift/** Returns true if the specified character is a base-10 digit. */// LEXING SUPPORT/** Returns true if the specific character is a base-8 digit. *//** Returns true if the specified character is a base-16 digit. *//** Returns true if the specified character is a valid type specifier ... */BigInteger MAX_LONG;// PARSING SUPPORTBigInteger MIN_LONG;BigInteger MAX_INTEGER;BigInteger MIN_INTEGER;BigDecimal MAX_DOUBLE;BigDecimal MIN_DOUBLE;BigDecimal MAX_FLOAT;BigDecimal MIN_FLOAT;/** Builds a Number from the given integer descriptor.  Creates the narrowest ... */String text1boolean negativeint radixinstance.byte_rightShiftUnsignedchar typerightShiftUnsignedSlow(...)BigInteger valueisNumericTypeSpecifier(...)instance.short_rightShiftUnsignedinstance.int_rightShiftUnsigned/** Builds a Number from the given decimal descriptor.  Uses BigDecimal, ... */BigDecimal valueparseFloat(...)instance.long_rightShiftUnsignedparseDouble(...)// remove place holder underscore before starting// Strip off the sign, if present// Determine radix (default is 10).// Strip off any type specifier and convert it to lower// case, if present.// pick best fit// Add the sign back, if necessary// Build the specified type or, if no type was specified, the// smallest type in which the number will fit.// If not specified, we will return the narrowest possible// of Integer, Long, and BigInteger.// Build the specified type or default to BigDecimalimport GroovyException/** Encapsulates non-specific i/o exceptions. */IOException cause;/** A helper class to allow parser exceptions to be thrown anywhere in the code. ... *//** A syntax reduction, produced by the <code>Parser</code>. ... */new Reduction(...)Reduction EMPTY;List<> elements;// INITIALIZATION AND SUCHboolean marked;// The set of child nodes/** Initializes the <code>Reduction</code> with the specified root. */// Used for completion marking by some parts of the parser/** Base exception indicating a syntax error. */int startLine;/** Line upon which the error occurred. */int endLine;int startColumn;/** Column upon which the error occurred. */int endColumn;String sourceLocator;this.startLinethis.startColumnthis.endLinethis.endColumn// Propertiesthis.sourceLocator/** Retrieve the line upon which the error occurred. ... *//** Retrieve the column upon which the error occurred. ... *//** Initializes the <code>Reduction</code> to empty. *//** Creates a new <code>Reduction</code> with <code>Token.NULL</code> ... *//** Returns the number of elements in the node. *//** Marks the node a complete expression. */Types.COMPLEX_EXPRESSION/** Adds an element to the node. *//** Sets an element in at the specified index. *//** A <code>CSTNode</code> produced by the <code>Lexer</code>. ... */Types.EOFToken EOF;Token NULL;int type;/** the actual type identified by the lexer */int meaning;/** an interpretation applied to the token after the fact *//** the text of the token *//** the source line on which the token begins *//** Removes a node from the <code>Reduction</code>.  You cannot remove ... *//** the source column on which the token begins *//** Initializes the Token with the specified information. */this.meaning/** Returns a copy of this Token. */// It's not the greatest of design that the interface allows this, but it// is a tradeoff with convenience, and the convenience is more important.// Fill slots with nulls, if necessary.// Then set in the element./** Returns the text of the root node.  Uses <code>getRoot(true)</code> ... *//** Returns the text of the token.  Equivalent to ... *//** Not advisable, but if you need to adjust the token's text, this ... *//** Creates a <code>Reduction</code> from this token.  Returns self if the ... *//** Creates a <code>Reduction</code> from this token, adding the supplied ... */Reduction createdasReduction(...)/** Creates a token that represents a keyword.  Returns null if the ... */// TOKEN FACTORIESlookupKeyword(...)/** Creates a token that represents a double-quoted string. */Types.STRING/** Creates a token that represents an identifier. */Types.IDENTIFIER/** Creates a token that represents an integer. */Types.INTEGER_NUMBER/** Creates a token that represents a decimal number. */Types.DECIMAL_NUMBER/** Creates a token that represents a symbol, using a library for the text. *//** Creates a token that represents a symbol, using a library for the type. */lookupSymbol(...)/** Creates a token with the specified meaning. */Token unexpectedToken;int expectedType;this.unexpectedTokenthis.expectedType/** Utility methods for working with Tokens. */Types.PLUS_PLUSTypes.PREFIX_PLUS_PLUSTypes.POSTFIX_PLUS_PLUSTypes.PLUS_EQUALTypes.MINUS_MINUSTypes.PREFIX_MINUS_MINUSTypes.POSTFIX_MINUS_MINUSTypes.MINUS_EQUAL/** Typing information for the CST system.  The types here are those ... *//** Removes the assignment portion of a given token.  If the given token ... */Types.MINUSTypes.MULTIPLY_EQUALTypes.MULTIPLYTypes.LEFT_SHIFT_EQUALTypes.LEFT_SHIFTTypes.RIGHT_SHIFT_EQUALTypes.RIGHT_SHIFTTypes.RIGHT_SHIFT_UNSIGNED_EQUALTypes.RIGHT_SHIFT_UNSIGNEDTypes.MOD_EQUALTypes.MODTypes.INTDIV_EQUALTypes.INTDIVTypes.BITWISE_OR_EQUALTypes.BITWISE_ORTypes.BITWISE_AND_EQUALTypes.BITWISE_ANDTypes.BITWISE_XOR_EQUALTypes.BITWISE_XOR/** A convenience front end for getting standard compilations done. ... */new Compiler(...)Compiler DEFAULT;// TODO: delete this constant?/** Initializes the Compiler with default configuration. */// Optional configuration data/** Initializes the Compiler with the specified configuration. *//** Compiles a single File. *//** Compiles a series of Files. */addSources(...)/** Compiles a series of Files from file names. *//** Compiles a string of code. */String targetDirectoryboolean infoList<CachedMethod> cachedMethodsListCachedMethod[] cachedMethodsnew HashMap<String,Integer>(...)int curDefaultGroovyMethods.DGM_LIKE_CLASSESClass<> returnTypeFile targetFilegetCanonicalFile(...)createInvokeMethod(...)createDoMethodInvokeMethod(...)createIsValidMethodMethod(...)FileOutputStream fileOutputStreamsaveDgmInfo(...)addTranslation(...)addKeyword(...)loadParameters(...)// 1 param meta methodEntry<String,Integer> entryaddDescription(...)/** Provides services for reporting compilation errors to the ... */Throwable base;// The exception on which to reportObject output;// If true, stack traces are always output/** Configures a new Reporter.  Default mode is not to report a stack trace unless ... */// The stream/writer to which to outputthis.base/** Configures a new Reporter. ... *//** Writes the error to the specified <code>PrintStream</code>. */// SPECIAL TOKENS// TYPES: NOTE THAT ORDERING AND VALUES ARE IMPORTANT TO LOCAL ROUTINES!int UNKNOWN;// end of fileint NEWLINE;dispatch(...)// RELEVANT WHITESPACE// the unknown tokenint LEFT_CURLY_BRACE;// OPERATORS AND OTHER MARKERS// \nint RIGHT_CURLY_BRACE;/** Writes the error to the specified <code>PrintWriter</code>. */int LEFT_SQUARE_BRACKET;int RIGHT_SQUARE_BRACKET;// [int LEFT_PARENTHESIS;// ]int RIGHT_PARENTHESIS;// (int DOT;// )int DOT_DOT;// .int DOT_DOT_DOT;// ..int NAVIGATE;int FIND_REGEX;// ->int MATCH_REGEX;// =~int REGEX_PATTERN;// ==~int EQUAL;// ~int EQUALS;// =int ASSIGN;/** Runs the report once all initialization is complete. */int COMPARE_NOT_EQUAL;int COMPARE_IDENTICAL;// !=int COMPARE_NOT_IDENTICAL;// ===int COMPARE_EQUAL;// !==int COMPARE_LESS_THAN;report(...)int COMPARE_LESS_THAN_EQUAL;// <int COMPARE_GREATER_THAN;// <=int COMPARE_GREATER_THAN_EQUAL;// >int COMPARE_TO;// >=int COMPARE_NOT_IN;// <=>int COMPARE_NOT_INSTANCEOF;// !inint NOT;// !instanceofint LOGICAL_OR;// !int LOGICAL_AND;// ||int LOGICAL_OR_EQUAL;// &&int LOGICAL_AND_EQUAL;// ||=int PLUS;// &&=int MINUS;// +int MULTIPLY;// -int DIVIDE;// *int INTDIV;// /int MOD;/** For CompilationFailedException. */// \int STAR_STAR;// REPORTING ROUTINES// %int POWER;// **int PLUS_EQUAL;int MINUS_EQUAL;// +=int MULTIPLY_EQUAL;// -=int DIVIDE_EQUAL;// *=int INTDIV_EQUAL;stacktrace(...)// /=int MOD_EQUAL;// \=int POWER_EQUAL;/** For GroovyException. */// %=int ELVIS_EQUAL;/** For Exception. *//** For everything else. */// **=int PLUS_PLUS;// ?=int PREFIX_PLUS_PLUS;// ++int POSTFIX_PLUS_PLUS;int PREFIX_PLUS;int MINUS_MINUS;int PREFIX_MINUS_MINUS;// --int POSTFIX_MINUS_MINUS;int PREFIX_MINUS;int LEFT_SHIFT;// - (negation)int RIGHT_SHIFT;// <<int RIGHT_SHIFT_UNSIGNED;// >>int LEFT_SHIFT_EQUAL;// >>>int RIGHT_SHIFT_EQUAL;// <<=int RIGHT_SHIFT_UNSIGNED_EQUAL;// >>=int STAR;// >>>=int COMMA;int COLON;int SEMICOLON;// :int QUESTION;/** Prints a line to the underlying <code>PrintStream</code> */// GENERAL SUPPORT ROUTINES// ;int PIPE;// TODO refactor PIPE to be BITWISE_OR// ?int DOUBLE_PIPE;// |int BITWISE_OR;int BITWISE_AND;int BITWISE_XOR;// &int BITWISE_OR_EQUAL;/** Displays an exception's stack trace, if <code>debug</code> or ... */// ^int BITWISE_AND_EQUAL;// |=int BITWISE_XOR_EQUAL;// &=int BITWISE_NEGATION;// ^=int STRING;// LITERALSint IDENTIFIER;// any bare string dataint INTEGER_NUMBER;// anything text and not a keywordint DECIMAL_NUMBER;// integerint KEYWORD_PRIVATE;// KEYWORDS: (PRIMARILY) CLASS/METHOD DECLARATION MODIFIERS// decimalint KEYWORD_PROTECTED;// declaration visibilityint KEYWORD_PUBLIC;int KEYWORD_ABSTRACT;int KEYWORD_FINAL;// method body missingint KEYWORD_NATIVE;// declaration cannot be overriddenint KEYWORD_TRANSIENT;// a native code entry pointint KEYWORD_VOLATILE;// property should not be persistedint KEYWORD_SYNCHRONIZED;// compiler should never cache propertyint KEYWORD_STATIC;// modifier and block typeint KEYWORD_DEF;// KEYWORDS: TYPE SYSTEMint KEYWORD_DEFMACRO;// identifies a function declarationint KEYWORD_CLASS;// XXX br identifies a macro declarationint KEYWORD_INTERFACE;// identifies a class declarationint KEYWORD_MIXIN;// identifies an interface declarationint KEYWORD_IMPLEMENTS;// identifies a mixin declarationint KEYWORD_EXTENDS;// specifies the interfaces implemented by a classint KEYWORD_THIS;// specifies the base class/interface for a new oneint KEYWORD_SUPER;// method variable points to the current instanceint KEYWORD_INSTANCEOF;// method variable points to the base instanceint KEYWORD_PROPERTY;// type comparatorint KEYWORD_NEW;// deprecated; identifies a propertyint KEYWORD_PACKAGE;// used to create a new instance of a classint KEYWORD_IMPORT;// declares the package scopeint KEYWORD_AS;// declares an external classint KEYWORD_RETURN;// KEYWORDS: CONTROL STRUCTURES// used in import statements to create an aliasint KEYWORD_IF;// returns from a closure or methodint KEYWORD_ELSE;// ifint KEYWORD_DO;// elseint KEYWORD_WHILE;// do loopint KEYWORD_FOR;// while loopint KEYWORD_IN;// for loopint KEYWORD_BREAK;// for (each) loop separatorint KEYWORD_CONTINUE;// exits a loop or blockint KEYWORD_SWITCH;// restarts a loop on the next iterationint KEYWORD_CASE;// switch blockint KEYWORD_DEFAULT;// item in a switch blockint KEYWORD_TRY;// catch-all item in a switch blockint KEYWORD_CATCH;// block to monitor for exceptionsint KEYWORD_FINALLY;// catch block for a particular exceptionint KEYWORD_THROW;// block to always execute on exit of the tryint KEYWORD_THROWS;// statement to throw an exceptionint KEYWORD_ASSERT;// method modifier to declare thrown transactionsint KEYWORD_VOID;// KEYWORDS: PRIMITIVE TYPES// alternate throw for code invariantsint KEYWORD_BOOLEAN;// voidint KEYWORD_BYTE;// booleanint KEYWORD_SHORT;// 1 byte integerint KEYWORD_INT;// 2 byte integerint KEYWORD_LONG;// 4 byte integerint KEYWORD_FLOAT;// 8 byte integerint KEYWORD_DOUBLE;// 32 bit floating point numberint KEYWORD_CHAR;// 64 bit floating point numberint KEYWORD_TRUE;// KEYWORDS: SPECIAL VALUES// unicode character codeint KEYWORD_FALSE;// boolean truthint KEYWORD_NULL;// boolean falseint KEYWORD_CONST;// KEYWORDS: RESERVED// missing instanceint KEYWORD_GOTO;// reserved in java and groovyint SYNTH_COMPILATION_UNIT;// SPECIAL (CALCULATED) MEANINGSint SYNTH_CLASS;// reserved: a synthetic root for a CSTint SYNTH_INTERFACE;// applied to class namesint SYNTH_MIXIN;// applied to interface namesint SYNTH_METHOD;// applied to mixin namesint SYNTH_PROPERTY;// applied to method namesint SYNTH_PARAMETER_DECLARATION;// applied to property namesint SYNTH_LIST;// applied to method/closure parameter namesint SYNTH_MAP;// applied to "[" that marks a listint SYNTH_GSTRING;// applied to "[" that marks a mapint SYNTH_METHOD_CALL;// a complete GStringint SYNTH_CAST;// applied to the optional "(" that marks a call to a methodint SYNTH_BLOCK;// applied to "(" that marks a type castint SYNTH_CLOSURE;// applied to "{" that marks a blockint SYNTH_LABEL;// applied to "{" that marks a closureint SYNTH_TERNARY;// applied to a statement labelint SYNTH_TUPLE;// applied to "?" that marks a ternary expressionint SYNTH_VARIABLE_DECLARATION;// applied to "{" that marks an array initializerint GSTRING_START;// GSTRING TOKENS// the type of a variable declaration// applied to an identifier that specifiesint GSTRING_END;// any marker tha begins a GStringint GSTRING_EXPRESSION_START;// any matching marker that ends a GStringint GSTRING_EXPRESSION_END;// the ${ marker that starts a GString expressionint ANY;// TYPE CLASSES// the } marker that ends a GString expressionint NOT_EOF;// anythingint GENERAL_END_OF_STATEMENT;// anything but EOFint ANY_END_OF_STATEMENT;// ";", "\n", EOFint ASSIGNMENT_OPERATOR;// ";", "\n", EOF, "}"int COMPARISON_OPERATOR;// =, +=, etc.int MATH_OPERATOR;// ==, ===, >, <, etc.int LOGICAL_OPERATOR;// +, -, / *, %, plus the LOGICAL_OPERATORSint RANGE_OPERATOR;// ||, &&, !int REGEX_COMPARISON_OPERATOR;// .., ...int DEREFERENCE_OPERATOR;// =~, etc.int BITWISE_OPERATOR;// ., ->int INSTANCEOF_OPERATOR;// |, &, <<, >>, >>>, ^, ~int PREFIX_OPERATOR;// instanceof, !instanceofint POSTFIX_OPERATOR;// ++, !, etc.int INFIX_OPERATOR;// ++, etc.int PREFIX_OR_INFIX_OPERATOR;// +, -, =, etc.int PURE_PREFIX_OPERATOR;// +, -int KEYWORD;// prefix +, prefix -int SYMBOL;// any keywordint LITERAL;// any symbolint NUMBER;// strings, numbers, identifiersint SIGN;// integers and decimalsint NAMED_VALUE;// "+", "-"int TRUTH_VALUE;// true, false, nullint PRIMITIVE_TYPE;// true, falseint CREATABLE_PRIMITIVE_TYPE;// void, byte, short, int, etc.int LOOP;// any PRIMITIVE_TYPE except voidint RESERVED_KEYWORD;// do, while, etc.int KEYWORD_IDENTIFIER;// const, goto, etc.int SYNTHETIC;// keywords that can appear as identifiersint TYPE_DECLARATION;// any of the SYNTH typesint DECLARATION_MODIFIER;// class, interface, mixinint TYPE_NAME;// public, private, abstract, etc.int CREATABLE_TYPE_NAME;// identifiers, primitive typesint MATCHED_CONTAINER;// identifiers, primitive types except voidint LEFT_OF_MATCHED_CONTAINER;// (, ), [, ], {, }int RIGHT_OF_MATCHED_CONTAINER;// (, [, {int EXPRESSION;// ), ], }int OPERATOR_EXPRESSION;// all of the below 1900 seriesint SYNTH_EXPRESSION;// "."-"<<"int KEYWORD_EXPRESSION;// cast, ternary, and closure expressionint LITERAL_EXPRESSION;// new, this, super, instanceof, true, false, nullint ARRAY_EXPRESSION;// LITERALint SIMPLE_EXPRESSION;// "["int COMPLEX_EXPRESSION;// LITERAL, this, true, false, nullint PARAMETER_TERMINATORS;// TYPE GROUPS (OPERATIONS SUPPORT)// SIMPLE_EXPRESSION, and various moleculesint ARRAY_ITEM_TERMINATORS;// ")", ","int TYPE_LIST_TERMINATORS;// "]", ","int OPTIONAL_DATATYPE_FOLLOWERS;// "implements", "throws", "{", ","int SWITCH_BLOCK_TERMINATORS;// identifier, "[", "."int SWITCH_ENTRIES;// "case", "default", "}"int METHOD_CALL_STARTERS;// "case", "default"int UNSAFE_OVER_NEWLINES;// LITERAL, "(", "{"int PRECLUDES_CAST_OPERATOR;// things the expression parser should cross lines for in it doesn't have to// TYPE HIERARCHIES// anything that prevents (X) from being a cast/** Given two types, returns true if the second describes the first. */import ConfigurationExceptionimport JavaAwareCompilationUnitimport Parametersimport static GroovyMain.buildConfigScriptTextimport static GroovyMain.processConfigScriptTextimport static GroovyMain.processConfigScripts/** Command-line compiler (aka. <tt>groovyc</tt>). */boolean displayStackTraceOnError;new JavaAwareCompilationUnit(...)/** Prints the usage help message for {@link CompilationOptions} to stderr. ... */displayHelp(...)/** Prints the usage help message for the {@link CompilationOptions} to the specified PrintWriter. ... */configureParser(...)new CompilationOptions(...)/** Prints version information to stderr. ... */displayVersion(...)/** Prints version information to the specified PrintWriter. ... */new VersionProvider(...)int errorscheckFiles(...)/** Same as main(args) except that exceptions are thrown out instead of causing ... */commandLineCompile(...)CompilationOptions optionsParseResult parseResulttoCompilerConfiguration(...)String[] filenamesgenerateFileNames(...)boolean fileNameErrorsoptions.printStackfilenames.lengthvalidateFiles(...)doCompilation(...)toggleBooleanFlags(...)expandAtFiles(...)unmatchedOptionsArePositionalParams(...)unmatchedArgumentsAllowed(...)parser(...)getCommandSpec(...)/** Primary entry point for compiling from the command line ... */commandLineCompileWithErrorHandling(...)new ErrorReporter(...)File tmpDirFileSystemCompiler compilernew FileSystemCompiler(...)/** Given two types, returns true if the first can be viewed as the second. ... */// TYPE COERSIONSgetAbsoluteFile(...)compiler.unitdeleteRecursive(...)/** Converts a node from a generic type to a specific prefix type. ... */List<String> fileList/** Converts a node from a generic type to a specific postfix type. ... *//** Returns the precedence of the specified operator.  Non-operator's will ... */// OPERATOR PRECEDENCEMap<Integer,String> TEXTS;// TEXTSMap<String,Integer> LOOKUP;// symbol/keyword type -> textSet<String> KEYWORDS;// text -> symbol/keyword type// valid keywords/** Returns the type for the specified symbol/keyword text.  Returns UNKNOWN ... *//** Returns the type for the specified keyword text.  Returns UNKNOWN ... *//** Returns the type for the specified symbol text.  Returns UNKNOWN ... *//** Returns the text for the specified type.  Returns "" if the ... *//** Adds a element to the TEXTS and LOOKUP. *//** Adds a element to the KEYWORDS, TEXTS and LOOKUP. */Map<Integer,String> DESCRIPTIONS;// DESCRIPTIONS/** Gets the description for the specified type. *//** Adds a description to the set. */boolean errorsString fnString fileFile value/* FALL THROUGH */// SYMBOLS// Keywords// xxx br defmacroMap<String,Object> resultFile sourcepath;File temp;File targetDir;boolean printStack;boolean jointCompilation;Map<String,String> javacOptionsMap;List<String> flags;String configScript;List<String> files;String[] partsparts.lengthMap<String,Object> compilerOptionsjavacFlags(...)javacNamedValues(...)new GroovyClass[]...[] bytes;this.bytesgenerateFileNamesFromOptions(...)/** Helper class to initialize the Groovy runtime. */String confLoaderConfiguration lcnew LoaderConfiguration(...)boolean hadMainboolean hadConfboolean hadCPint argsOffsetString confOverride// Load the file name listString[] newArgsgetLoader(...)// if there are any joint compilation options set stubDir if not set// Setup the configuration data// joint compilation parametersaddClassPath(...)setMainClass(...)getMainClass(...)/** Class used to configure a RootLoader from a stream or by using ... */new ArrayList<URL>(...)Exception e1Exception e3new PrivilegedAction<RootLoader>(...) { ... }new RootLoader(...)rootLoader(...)// evaluate parameters// this allows to override the commandline conf// we need to know the class we want to start// copy arguments for main class // load configuration file// create loader and execute main class/** This ClassLoader should be used as root of class loaders. Any ... */String MAIN_PREFIX, ...;List<URL> classPath;String main;boolean requireMain;char WILDCARD;String ALL_WILDCARD;String MATCH_FILE_NAME;String MATCH_ALL;List<String> grabList;List<String> configScripts;/** creates a new loader configuration */this.requireMain/** configures this loader with a stream ... */int lineNumberString loadPathassignProperties(...)loadFilteredPath(...)String grabParamsString params/* Expands the properties inside the given string to their values. */int propertyIndexStartint propertyIndexEndMap<String,Class<>> customClasses;boolean requirePropertyString ORG_W3C_DOM_NODE;/** constructs a new RootLoader without classpath ... *//** constructs a new RootLoader with a parent loader and an ... */String propertyKeyString propertyValueint i1int i2getSlashyPath(...)correctDoubleSlash(...)/* Load a possibly filtered path. Filters are defined ... */int starIndexboolean recursiveString startDirFile rootaddFile(...)quote(...)findMatchingFiles(...)String fileString/** constructs a new RootLoader with a {@link LoaderConfiguration} ... */getClassPathUrls(...)String groovyHomeFile[] dirFiles// This solution is based on an absolute path// change path representation to something more system independent.List<String> grabUrlsgetGrabUrls(...)String changedPathchooseParent(...)String grabUrl/** Adds a file to the classpath if it exists. ... */Map<String,Object> grabPartsString group/** Adds a classpath to this configuration. It expects a string with ... */String[] pathsString cpPathFile dir/** The classpath as URL[] from this configuration. ... *//** The extra grab configuration. ... *//** Returns the name of the main class for this configuration. ... */String module/** Sets the main class. If there is already a main class ... *//** Determines if a main class is required when calling. ... */File jar/** loads a class using the name of the class */oldFindClass(...)// assume properties contain paths// Check to support wild card classpath/** returns the URL of a resource, or null if it is not found *//** adds an url to the classpath of this classloader */// major hack here...!// TODO M12N eventually defer this until later when we have a full Groovy// environment and use normal Grape.grab()char SPACE, ...;/** Various utility functions for use in the compiler. *//** This method tokenizes a string by space characters, ... */List<> tokenslineSeparator(...)Set<String> INVALID_JAVA_IDENTIFIERS;/** Returns a string made up of repetitions of the specified string. *//** Returns the end-of-line marker. *//** Tells if the given string is a valid Java identifier. */String eol;int firstscanToken(...)skipWhitespace(...)Set<String> current;Map<String,?> precompiledDependencies;StringSetMap cache;scanQuoted(...)this.precompiledDependenciesaddToCache(...)Set<String> oldimport ASTTransformationCollectorCodeVisitorimport static CompilerConfiguration.MEM_STUB/** Compilation Unit capable of compiling Java source files. */Set<String> nameSetnew JavacCompilerFactory(...)JavaStubGenerator stubGenerator;Set<String> javaSources;JavaCompilerFactory compilerFactory;File generationGoal;boolean keepStubs;boolean memStubEnabled;String sourceEncodingStringSetMap deltathis.keepStubsString iString jSet<String> iSetthis.memStubEnabledthis.generationGoalthis.stubGeneratornew JavaStubGenerator(...)Expression ccenew JavaAwareResolveVisitor(...)new ASTTransformationCollectorCodeVisitor(...)// do nothing here, leave it to the normal resolving// GROOVY-10607generateClass(...)FileNotFoundException fnfecreateCompiler(...)addJavaCompilationUnits(...)getJavaStubCompilationUnitSet(...)clean(...)File targetDirString classOutput/** Compilation unit to only generate stubs. */int stubCount;addJavaOrGroovySource(...)addJavaSource(...)this.compilerFactory// compile Java and clean up// add java stubs// GroovyClassLoader should be able to find classes compiled from java sourcesFileNotFoundException ehasAcceptedFileExtension(...)String lowerCasedNameimport ExpressionUtilsimport FinalVariableAnalyzerimport VerifierCodeVisitorimport static ClassHelper.isCachedTypeimport static ClassHelper.isStaticConstantInitializerTypenew JavacJavaCompiler(...)boolean java5;boolean requireSuperResolved;File outputPath;ArrayList<MethodNode> propertyMethods;Map<String,MethodNode> propertyMethodsWithSigs;ArrayList<ConstructorNode> constructors;ModuleNode currentModule;this.outputPaththis.requireSuperResolvedthis.java5generateMemStub(...)generateFileStub(...)generateStubContent(...)createJavaStubFile(...)PrintWriter outnew RawJavaFileObject(...)toUri(...)boolean packageInfoprintAnnotations(...)printImports(...)printClassContents(...)Verifier verifiernew Verifier(...) { ... }JavaStubGenerator$1List<Statement> savedStatementsLocale DEFAULT_LOCALE;List<String> javacParametersmakeParameters(...)StringBuilderWriter javacOutputint javacReturnValueboolean successfuldoCompileWithSystemJavaCompiler(...)addJavacError(...)StandardJavaFileManager fileManagerSet<JavaFileObject> compilationUnitSetgetJavaCompilationUnitSet(...)CompilationTask compilationTaskFile stubDirClassNode traitfindTraits(...)Map<String,ClassNode> genericsPropertyNode traitPropertyClassNode traitPropertyTypedoAddMethod(...)ConstructorNode newCtorExpression[] savedString sigint origNumConstructorsisInterfaceOrTrait(...)boolean isAnnotationDefinitiongetJavaFileObjectsFromFiles(...)printModifiers(...)printGenericsBounds(...)printType(...)printFields(...)printMethods(...)Iterator<InnerClassNode> innerprintConstructors(...)printMethod(...)List<MethodNode> traitMethodsMethodNode traitOrigMethodMethodNode traitMethodMethodNode existingMethodMethodNode propertyMethodboolean sameParamssameParameterTypes(...)isConcreteTraitMethod(...)boolean isSyntheticMethodNode helperMethodfindHelper(...)new Function<String,File>(...) { ... }new Consumer<? extends JavaFileObject>(...) { ... }setLocale(...)getBuilder(...)List<String> paramsFile targetString[] flagsboolean hadClasspathString[] namedValuesList<ConstructorNode> constrsConstructorNode constrprintConstructor(...)int fieldCntList<FieldNode> enumFieldsList<FieldNode> normalFieldsprintEnumFields(...)FieldNode normalFieldprintField(...)String flagnamedValues.lengthList<String> pathsURL uprintValue(...)new PrivilegedAction<CodeSource>(...) { ... }printTypeName(...)ConstructorCallExpression constrCallprintParams(...)printExceptions(...)printSpecialConstructorArgs(...)Map<String,ClassNode> superTypeGenericsParameter[] bestMatchConstructorNode targetParameter[] normalized// any of the options are invalid// print warnings if any// java stubs already added// clear the java stubs in the source set of Java compilation// use sourcepath to specify the root directory of java stubs// add java source files to compile// append classpath if not already defined// add all classpaths that compilation unit seesClassNode normalizedTypenoExceptionToAvoid(...)ClassNode[] superExceptions/** Represents a Java source file in memory to compile ... */String src;ClassNode[] stubExceptions/** Construct a MemJavaFileObject instance with given class node and source code ... *//** Construct a MemJavaFileObject instance with given class name and source code ... */superExceptions.lengthcreateURI(...)Kind.SOURCEthis.srcstubExceptions.lengthClassNode superExcKind.SOURCE.extensionClassNode stubselectAccessibleConstructorFromSuper(...)MemJavaFileObject thatthat.classNameprintDefaultValue(...)import Paths/** Represents a Java source file in file to compile ... */Charset DEFAULT_CHARSET;Path javaFilePath;/** Construct a RawJavaFileObject of the given kind and with the ... */JavaFileObject.Kind.SOURCEthis.javaFilePathreadAllBytes(...)getConstructorArgumentType(...)/** delete the Java source file ... */RawJavaFileObject thatthat.uriisJavaIdentifier(...)isDefaultTraitImpl(...)Statement fsExpression reClassNode rtboolean classReturnimport Preferences/** Container for input/output handles. */String ANSI_RENDER_WRITER;InputStream inputStream;/** Raw input stream. */OutputStream outputStream;/** Raw output stream. */OutputStream errorStream;/** Raw error output stream. */Reader in;/** Preferred input reader. *//** Preferred output writer. */PrintWriter err;/** Preferred error output writer. */boolean ansiSupported;/** Whether ansi support is available *//** Construct a new IO container. */boolean ansiSupportedPrintWriter errprintReturn(...)this.inputStreamthis.outputStreamthis.errorStreamIO.classescapeSpecialChars(...)this.ansiSupportedtryConstructRenderWriter(...)this.err/** Construct a new IO container using system streams. *//** Set the verbosity level. */Preferences.verbosity/** Returns the verbosity level. *//** Check if the verbosity level is set to {@link Verbosity#QUIET}. */getVerbosity(...)Verbosity.QUIET/** Check if the verbosity level is set to {@link Verbosity#INFO}. */Verbosity.INFO/** Check if the verbosity level is set to {@link Verbosity#VERBOSE}. */ClassNode aliasgetImportType(...)Verbosity.VERBOSE/** Check if the verbosity level is set to {@link Verbosity#DEBUG}. ... */Verbosity.DEBUG/** Flush both output streams. *//** Close all streams. *//** Verbosity for simple logging: QUIET, INFO, VERBOSE, DEBUG */new Verbosity(...)Verbosity QUIET;Verbosity INFO;Verbosity VERBOSE;Verbosity DEBUG;QUIET.nameINFO.nameVERBOSE.nameboolean varargDEBUG.name// load via reflection to avoid hard-coded dependency on jansi jarprintAnnotation(...)import IOimport static Attribute.INTENSITY_BOLDimport static Ansi.Colorimport static Color.GREENimport static Color.REDimport static Ansi.ansi/** Provides a very, very basic logging API. */IO io;getAnnotationValue(...)new IO(...)io.ansiSupportedlogWithAnsi(...)logDefault(...)io.outColor colorString valboolean replaceDollarsa(...)fg(...)ansi(...)String DEBUG;// Level helpersObject constValueIO.Verbosity.DEBUGIO.VerbosityisDebugEnabled(...)ImportNode aliasString WARN;String ERROR;// Factory accessnew Logger(...)String memberNameImportNode ssi// Allow the msg to be a Throwable, and handle it properly if no cause is givenImportNode iImportNode siStream<JavaFileObject> javaFileObjectStreamimport MissingResourceExceptionnew Consumer<JavaFileObject>(...) { ... }/** Message source backed up by one or more {@link java.util.ResourceBundle} ... */...[] bundleNames;...[] cachedBundles;this.bundleNamesString[] namesSet<JavaFileObject> javaStubCompilationUnitSet;// when outputPath is null, we generate stubs in memory// Only attempt to render our self if our super-class is resolved, else wait for it// owner should take care for us// don't generate stubs for private classes, as they are only visible in the same file// should just output the package statement for `package-info` class node// if it is an anonymous inner class, don't generate the stub code for it.// GROOVY-9031: replace property type placeholder with resolved type from trait generics// GROOVY-8233 skip static properties for traits since they don't make the interface//GROOVY-4508// not required for stub generation// undo unwanted side-effect of verifier// GROOVY-4004: Clear the methods from the outer class so that they don't get duplicated in inner ones// skip values() method and valueOf(String)// print the methods from traits// GROOVY-9606: replace method return type and parameter type placeholder with resolved type from trait generics// GROOVY-10611: integer/decimal value// printModifiers(out, constructorNode.getModifiers());// temporary hack// only look at things we can actually call// TODO: package-private and types are peers// GROOVY-10407// GROOVY-5859: remove generic type info for raw type// GROOVY-7306: apply type arguments from declaring type to parameter type// fall back for parameterless constructor// if all remaining exceptions are used in the stub we are good// not found// Select a constructor from our class, or super-class which is legal to call,// then write out an invoke w/nulls using casts to avoid ambiguous calls// Otherwise try the older method based on the constructor's call expression// GROOVY-10464// field, property, parameter// GROOVY-10122// check for an alias// assume must be static class field or enum value or class that Java can resolve// annotation closure; replaced with this specific class literal to cover the// case where annotation type uses Class<? extends Closure> for the closure's type// GROOVY-7510// non-static imports required if any unresolved nodes encountered -- Java type(s)?import BackingStoreExceptionimport PreferenceChangeEventimport PreferenceChangeListener/** Container for shell preferences. */node(...)userRoot(...)String tmpIO.Verbosity.INFO.nameIO.Verbosity.INFOclassNames(...)addChangeListener(...)new PreferenceChangeListener(...) { ... }Preferences$1ResourceBundle[] bundlesnew ResourceBundle[]bundleNames.lengthgetNewValue(...)verbosity.namePreferences STORE;IO.Verbosity verbosity;String VERBOSITY_KEY;String SHOW_LAST_RESULT_KEY;String SANITIZE_STACK_TRACE_KEY;String EDITOR_KEY;String PARSER_FLAVOR_KEY;String PARSER_RIGID;String PARSER_RELAXED;createBundles(...)/** Get a raw message from the resource bundles using the given code. */MissingResourceException errorgetBundles(...)getenv(...)ResourceBundle bundlegetString(...)MissingResourceException e// Store Access/** Format a message (based on {@link MessageFormat} using the message ... */String patternaddPreferenceChangeListener(...)// FIXME: For now just save the first error, should really roll a new message with all of the details/** This class is instantiated and invoked when an AST transformation is ... *//** The method is invoked when an AST Transformation is active. For local transformations, it is invoked once ... */import ASTTransformationsContext/** This class handles the invocation of the ASTAnnotationTransformation ... */new PriorityComparator(...)PriorityComparator priorityComparator;ASTTransformationsContext context;List<ASTNode[]> targetNodes;Map<ASTNode,List<ASTTransformation>> transforms;/** Main loop entry. ... */Map<Class<? extends ASTTransformation>,Set<ASTNode>> baseTransformsMap<Class<? extends ASTTransformation>,ASTTransformation> transformInstancesnew HashMap<Class<? extends ASTTransformation>,ASTTransformation>(...)List<Tuple2<ASTTransformation,ASTNode[]>> tuplesnew ArrayList<Tuple2<ASTTransformation,ASTNode[]>>(...)import AnnotationCollectorimport AnnotationCollectorModeimport TraitASTTransformation/** Walks the AST and collects references to annotations that are annotated ... */ClassNode oldClassList<AnnotationNode> nodeAnnotationsMap<Integer,AnnotationCollectorMode> modesnew LinkedHashMap<Integer,AnnotationCollectorMode>(...)Map<Integer,List<AnnotationNode>> existingnew LinkedHashMap<Integer,List<AnnotationNode>>(...)Map<Integer,List<AnnotationNode>> replacementsList<AnnotationNode> mergedListfindCollectedAnnotations(...)Entry<Integer,List<AnnotationNode>> entryMap<>.Entry<Integer,List<AnnotationNode>>Integer replacementIndexmergeCollectedAnnotations(...)Class<? extends ASTTransformation> transformClassnew Consumer<List<AnnotationNode>>(...) { ... }addTransformsToClassNode(...)deleteExisting(...)deleteReplacement(...)AnnotationNode replacementList<AnnotationNode> annotationNodesmergeParameters(...)Iterator<AnnotationNode> nodeIteratorboolean removeAnnotationCollector.classnew HashMap<ASTNode,List<ASTTransformation>>(...)Expression modeExpression processorAnnotationCollectorTransform actAnnotationCollectorMode.DUPLICATEEntry<Class<? extends ASTTransformation>,Set<ASTNode>> entryMap<>.Entry<Class<? extends ASTTransformation>,Set<ASTNode>>new Function<Expression,Object>(...) { ... }List<ASTTransformation> listnew Function<ASTNode,List<ASTTransformation>>(...) { ... }new Function<Object,AnnotationCollectorMode>(...) { ... }new ArrayList<ASTTransformation>(...)Class<?> klassloadTransformClass(...)new LinkedList<ASTNode[]>(...)new AnnotationCollectorTransform(...)List<AnnotationNode> result/** Determines if given annotation specifies an AST transformation and if so, ... */Annotation transformClassAnnotationgetTransformClassAnnotation(...)Method valueMethodString[] transformClassNamesMethod classesMethodClass<?>[] transformClassestransformClassNames.lengthtransformClasses.lengthASTNode[] nodeASTTransformation sntnew Tuple2<ASTTransformation,ASTNode[]>(...)new Function<Class<?>,String>(...) { ... }Tuple2<ASTTransformation,ASTNode[]> tuplegetCompilationUnit(...)new Predicate<Class<?>>(...) { ... }distinctAnnotations(...)new ASTNode[]Tuple3<String,String,String> COMPILEDYNAMIC_AND_COMPILESTATIC_AND_TYPECHECKED;// Priority: CompileDynamic > CompileStatic > TypeChecked// If annotation with higher priority appears, annotation with lower priority will be ignored// `StaticTypeCheckingVisitor` visits multi-times because `node` has duplicated `CompileStatic` and `TypeChecked`// GROOVY-9215new Consumer<Class<?>>(...) { ... }new LinkedList<AnnotationNode>(...)verifyAndAddTransform(...)Annotation aGroovyASTTransformationClass.classGroovyASTTransformation transformationClassCompilePhase specifiedCompilePhaseAnnotationNode resultAnnotationNodeASTTransformation.classASTTransformationsContext contextaddGlobalTransforms(...)ASTTransformationVisitor visitornew ASTTransformationVisitor(...)visitor.source/** Enables transforms for class that was added during current phase. */int phasefromPhaseNumber(...)doAddGlobalTransforms(...)CompilationUnit compilationUnitGroovyClassLoader transformLoaderMap<String,URL> transformNamesnew LinkedHashMap<String,URL>(...)Set<String> disabledGlobalTransformsEntry<String,URL> entryMap<>.Entry<String,URL>getGlobalTransformNames(...)addPhaseOperationsForGlobalTransforms(...)new Predicate<Entry<String,URL>>(...) { ... }Class<?> gTransClassGroovyASTTransformation transformAnnotationCompilePhase.SEMANTIC_ANALYSISTraitASTTransformation.classSealedASTTransformation.classaddTransform(...)// GROOVY-9238: look again for collector annotations// nothing to do// clients are free to choose any GroovyClassLoader for resolving a// ClassNode such as annotationType; we have to compare by name and// cannot cast the return value to our GroovyASTTransformationClassASTTransformation instanceCompilationUnit.ISourceUnitOperationISourceUnitOperation suOpimport MethodNodeUtilsimport static Undefined.isUndefinedimport static GeneralUtils.getInstanceNonPropertyFieldNamesimport static GeneralUtils.getSuperNonPropertyFieldsThrowable effectiveExceptionClassNode RETENTION_CLASSNODE;Integer i1Integer i2priority(...)List<AnnotationNode> copiedAnnotations// only descend if we have annotations to look for//+ " declared by " + annotation.getClassNode().getName(),// invert the map, is now one to many// first pass, collect nodes// second pass, call visit on all of the collected nodes// CompileStatic// `CompileStatic` with "SKIP" `value` is actually `CompileDynamic`// ignore: we'll already have allocated to field or accessor method by now// with transform detection alone these phases are inaccessible, so don't add it//FIXME the warning message will NPE with what I have :(// record the transforms found in the first scan, so that in the 2nd scan, phase operations// can be added for only for new transforms that have come in// phase operations for this transform class have already been added before, so remove from current scan cycleimport LoopingStatement/** Base class for AST Transformations which will automatically throw an {@link InterruptedException} when ... */List<AnnotationNode> notCopiedString CHECK_METHOD_START_MEMBER;String APPLY_TO_ALL_CLASSES;String APPLY_TO_ALL_MEMBERS;String THROWN_EXCEPTION_TYPE;/** If the transform is associated with a single annotation, returns a name suitable for displaying in error messages. ... */boolean checkOnMethodStart;boolean applyToAllClasses;boolean applyToAllMembers;ClassNode thrownExceptionType;/** Subclasses should implement this method to set the condition of the interruption statement *//** Subclasses should implement this method to provide good error resolution. */nodes.lengthgetBooleanAnnotationParameter(...)getClassAnnotationParameter(...)InterruptedException.classModuleNode treeinternalError(...)setupTransform(...)isUndefinedMarkerList(...)getValueStringList(...)Expression itemExprcreateCondition(...)getErrorMessage(...)/** Takes a statement and wraps it into a block statement which first element is the interruption check statement. ... */BlockStatement stmtcreateInterruptStatement(...)visitLoop(...)/** Shortcut method which avoids duplicating code for every type of loop. ... */setLoopBlock(...)wrapBlock(...)// should be limited to the current SourceUnit or propagated to the whole CompilationUnit// guard every class and method defined in this script// only guard this particular class// only guard the script classimport static TraitComposer.COMPILESTATIC_CLASSNODE/** This class is the base for any annotation alias processor. ... */List<AnnotationNode> metagetTargetListFromAnnotations(...)getTargetListFromClass(...)/** Class used by {@link org.codehaus.groovy.control.CompilationUnit} to transform the alias class ... *//** Method to transform the given ClassNode, if it is annotated with ... */List<ClassNode> listboolean legacySerializationClassNode helpergetMeta(...)List<Expression> outergetTypeList(...)deemedInternalName(...)ArrayExpression aeString descriptorNoReturnList<ClassNode> remainingMap<> updatedGenericsSpecExpression serializedListIterator<AnnotationNode> itboolean annotationConstantList<Expression> newListClassExpression typeMapExpression mapMethodNode correctedMethodNodeString mdExpression val/** Adds a new syntax error to the source unit and then continues. ... */Expression memberValueListExpression memberListExpList<Expression> memberListList<String> pNamesList<String> fNamesgetInstanceNonPropertyFieldNames(...)List<FieldNode> superNonPropertyFieldsString pNameAnnotationNode toAddAnnotationNode newAncopyMembers(...)import AutoCloneimport AutoCloneStylegetSerializeClass(...)import ByteArrayInputStreamObject[][] dataimport static GeneralUtils.callSuperXimport static GeneralUtils.getInstanceNonPropertyFieldsimport static StaticCompilationVisitor.COMPILESTATIC_CLASSNODE/** Handles generation of code for the @AutoClone annotation. */AutoClone.classByteArrayOutputStream.classByteArrayInputStream.classObjectOutputStream.classObjectInputStream.classnew NoSuchMethodException(...)makeListOfAnnotations(...)Class<> MY_CLASS;ClassNode MY_TYPE;String MY_TYPE_NAME;ClassNode BAOS_TYPE;ClassNode BAIS_TYPE;ClassNode OOS_TYPE;ClassNode OIS_TYPE;// 2.5.3 and above gets from annotation attribute otherwise selfList<AnnotationNode> collectorsAnnotationNode collectorNodeExpression serializeClassClassNode serializeClassTypeboolean includeFieldsAutoCloneStyle stylegetStyle(...)Object[] innerList<FieldNode> listClass<?> annocheckNotInterface(...)Map<String,Object> memberMap<String,Expression> generatednew HashMap<String,Expression>(...)AutoCloneStyle.CLONEcreateCloneCopyConstructor(...)createCloneSerialization(...)createSimpleClone(...)createClone(...)Expression baosMethodCallExpression writeObjectClosureExpression writeClosExpression baisMethodCallExpression readObjectClosureExpression readClosExpression classLoadermakeExpression(...)CloneNotSupportedException.classboolean hasThisCons/** Returns a list of AnnotationNodes for the value attribute of the given ... */List<AnnotationNode> storedgetStoredTargetList(...)List<AnnotationNode> targetListgetTargetListFromValue(...)/** Implementation method of the alias annotation processor. This method will ... */getTargetAnnotationList(...)Set<String> unusedNamesBlockStatement noArgBodyBlockStatement initBodyExpression otherboolean hasParentExpression directExpression toStatement assignDirectStatement assignClonedcallCloneDirectX(...)Statement assignClonedDynamiccallCloneDynamicX(...)// force final class, remove interface, annotation, enum and abstract modifiers// force Object super class// force no interfaces implemented// add static value():Object[][] method// remove annotations//TODO: value as Annotation here!isCloneableType(...)possiblyCloneable(...)ConstructorCallExpression initaddSimpleCloneHelperMethod(...)MethodNode consParameter methodParamimport AutoFinal/** Handles generation of code for the {@link AutoFinal} annotation. */AutoFinal.classClass<?> MY_CLASS;AnnotatedNode target;Statement doClonecreateVisitor(...)Statement doCloneDynamicprocessClass(...)processField(...)processConstructorOrMethod(...)processLocalVariable(...)PropertyExpression propExpression oeisEnabled(...)// def baos = new ByteArrayOutputStream()// baos.withObjectOutputStream{ it.writeObject(this) }// def bais = new ByteArrayInputStream(baos.toByteArray())// return bais.withObjectInputStream(getClass().classLoader){ (<type>) it.readObject() }// add no-arg constructor// constructor may not be added yet which confuses type checking, so add manually// def _result = super.clone() as cNode// return _resulthasNoExplicitAutoFinal(...)Iterator<? extends ClassNode> itimport AutoImplementimport static ClassNodeUtils.isSubtypeModifier.FINAL/** Generates code for the {@code @AutoImplement} annotation. */AutoImplement.classnew ClassCodeVisitorSupport(...) { ... }AutoFinalASTTransformation$1Expression codeisUndefinedException(...)createMethods(...)MethodNode candidategetAllCorrectedMethodsMap(...)createMethodBody(...)ClassHelper.OVERRIDE_TYPE/** Returns all methods including abstract super/interface methods but only ... */// GROOVY-10585// any explicit false for enabled disables processing// this allows, for example, config script to set all// classes to true and one class to be explicitly disabledMap<String,ClassNode> updatedGenericsSpecMethodNode correctedMethodClassNode correctedClassString tdisWeakerCandidate(...)ClassNode origInterfaceClassNode correctedInterfaceisSubtype(...)MethodNode nameMatch// visibility only// GROOVY-10552// delegate to existing accessor to reduce the surprise// ignore java.lang.Object; also methods added by Verifier for GroovyObject are already good enough// GROOVY-9816: remove entries for to-be-generated property access and mutate methods// getter generated only if no explicit isser and vice versa// GROOVY-10472: prefer covariant method with more concrete typeimport Builderimport DefaultStrategyimport IntrospectionExceptionimport static GeneralUtils.getSuperPropertyFields/** Handles generation of code for the {@link Builder} annotation. */Builder.class...[] NO_EXCEPTIONS;...[] NO_PARAMS;GroovyClassLoader classLoaderBuilderStrategy strategycreateBuilderStrategy(...)checkStatic(...)getPropertyInfoFromClassNode(...)new ArrayList<PropertyInfo>(...)List<PropertyInfo> resultBeanInfo beanInfoPropertyDescriptor descriptorisHidden(...)IntrospectionException ignoreObject memberValueList<String> directExcludesList<String> directIncludesList<String> includesToCheckTupleConstructorASTTransformation.MY_TYPEList<String> tupleExcludesList<String> tupleIncludescheckIncludeExcludeUndefinedAware(...)boolean includeSuperPropertiesList<String> seengetPropertyInfoFromBeanInfo(...)ClassNode strategyClassDefaultStrategy.classimport BaseScript/** Handles transformation for the @BaseScript annotation. */BaseScript.classClass<BaseScript> MY_CLASS;...[] CONTEXT_CTOR_PARAMETERS;changeBaseScriptTypeFromDeclaration(...)changeBaseScriptTypeFromPackageOrImport(...)changeBaseScriptTypeFromClass(...)BuilderStrategy.classchangeBaseScriptType(...)ClassNode baseScriptTypeMethodNode runScriptMethodisCustomScriptBodyMethod(...)MethodNode defaultMethod// skip hidden and read-only propsConstructorNode orphanedConstructorremoveConstructor(...)//        Expression value = node.getMember("value");//        if (!(value instanceof ClassExpression)) {//            addError("Annotation " + MY_TYPE_NAME + " member 'value' should be a class literal.", value);//            return;// Method in base script that will contain the script body code.// If they want to use a name other than than "run", then make the change.// GROOVY-6706: Sometimes an NPE is thrown here.// The reason is that our transform is getting called more than once sometimes.  // The AST node metadata has the flag that indicates that this method is a script body.// It may also be carrying data for other AST transforms.// If the new script base class does not have a contextual constructor (g.l.Binding), then we won't either.// We have to do things this way (and rely on just default constructors) because the logic that generates// the constructors for our script class have already run.import TypeCheckingModeTypeCheckingMode.classClassNode COMPILESTATIC_NODE;ClassNode TYPECHECKINGMODE_NODE;import Delegateimport Lazyimport static ClassHelper.DEPRECATED_TYPEimport static GeneralUtils.getAllMethodsimport static GenericsUtils.nonGeneric/** Handles generation of code for the <code>@Delegate</code> annotation */Delegate.classLazy.classClassNode LAZY_TYPE;String MEMBER_DEPRECATED;String MEMBER_INTERFACES;String MEMBER_INCLUDES;String MEMBER_EXCLUDES;String MEMBER_INCLUDE_TYPES;String MEMBER_EXCLUDE_TYPES;String MEMBER_PARAMETER_ANNOTATIONS;String MEMBER_METHOD_ANNOTATIONS;String MEMBER_ALL_NAMES;DelegateDescription delegatenew DelegateDescription(...)delegate.delegatedelegate.annotationdelegate.namedelegate.typedelegate.ownerdelegate.getOpdelegate.originboolean skipInterfacesboolean includeDeprecatedIterable<MethodNode> ownerMethodsgetAllMethods(...)Iterable<MethodNode> delegateMethodscollectMethods(...)Set<ClassNode> addedInterfacesdelegate.excludesdelegate.includesdelegate.excludeTypesgetMemberClassList(...)delegate.includeTypescheckPropertyOrMethodList(...)addDelegateMethod(...)PropertyNode propaddGetterIfNeeded(...)addSetterIfNeeded(...)boolean skipLengthSet<ClassNode> ownerInterfacesfaces.lengthListIterator<MethodNode> itMethodNode nextSet<String> groovyObjectMethodsnew Function<MethodNode,String>(...) { ... }Set<String> javaObjectMethodsSet<String> ownClassMethodsSet<String> pNamesSet<String> mNamesgetPredicateName(...)shouldSkipPropertyMethod(...)boolean isPrimBoolboolean willHaveGetAccessorboolean willHaveIsAccessorReference<Boolean> ownerWillHaveGetAccessornew Reference<Boolean>(...)Reference<Boolean> ownerWillHaveIsAccessorextractAccessorInfo(...)boolean hasGetAccessorboolean hasIsAccessorMethodNode existingNodeboolean checkReturnshouldSkipOnDescriptorUndefinedAware(...)List<String> currentMethodGenPlaceholdersgetGenericPlaceholderNames(...)boolean alsoLazyClassNode newParamTypeParameter newParamgetParamName(...)GenericsType[] candidateGenericsTypesclashesWithOtherParams(...)AnnotatedNode delegate;Expression getOp;String origin;List<String> includes;List<String> excludes;List<ClassNode> includeTypes;List<ClassNode> excludeTypes;// GROOVY-7288 and JDK16+// GROOVY-4320, GROOVY-4516// from Verifier#addDefaultParameters// add getter/setters since Groovy compiler hasn't added property accessors yet// do a little bit of pre-work since Groovy compiler hasn't added property accessors yet// give precedence to methods of self (but not abstract or static superclass methods)// also allows abstract or static self methods to be selected for overriding but they are ignored later// addMethod will ignore attempts to override abstract or static methods with same signature on self// use propX when lazy, because lazy is only allowed on fields/properties// GROOVY-9938// GROOVY-6542import EqualsAndHashCodeimport HashCodeHelperimport static GeneralUtils.andXimport static GeneralUtils.findDeclaredMethodimport static GeneralUtils.getterThisXimport static GeneralUtils.getterXimport static GeneralUtils.hasClassXimport static GeneralUtils.hasDeclaredMethodimport static GeneralUtils.hasEqualFieldXimport static GeneralUtils.hasEqualPropertyXimport static GeneralUtils.hasSameFieldXimport static GeneralUtils.hasSamePropertyXimport static GeneralUtils.isZeroXimport static GeneralUtils.notIdenticalXimport static GeneralUtils.orXimport static GeneralUtils.sameXimport static GenericsUtils.makeClassSafeEqualsAndHashCode.classHashCodeHelper.classObjects.classmakeClassSafe(...)import static Collections.addAll/** Handles generation of code for the @Category annotation. ... */ClassNode sourceClassClassNode HASHUTIL_TYPE;ClassNode OBJECTS_TYPE;ClassNode OBJECT_TYPE;String HASH_CODE;String UNDER_HASH_CODE;String UPDATE_HASH;String EQUALS;String UNDER_EQUALS;String CAN_EQUAL;String UNDER_CAN_EQUAL;ensureNoInstanceFieldOrProperty(...)transformReferencesToThis(...)boolean callSuperboolean cacheHashCodeObject pojoMemberboolean useCanEqualaddUnsupportedInstanceMemberError(...)Reference<Parameter> selfParameternew Reference<Parameter>(...)LinkedList<Set<String>> varStacknew LinkedList<Set<String>>(...)createEquals(...)boolean hasExistingHashCodehasDeclaredMethod(...)MethodNode hashCodeFieldNode hashFieldExpression hashisZeroX(...)calculateHashStatements(...)calculateHashStatementsPOJO(...)calculateHashStatementsDefault(...)Set<String> namesClassCodeExpressionTransformer transformerCategoryASTTransformation$1// GROOVY-6510: track closure containmentExpression thisExpressioncreateThisExpression(...)boolean closureaddVariablesToStack(...)Expression getterExpression currentnotIdenticalX(...)Parameter loopParamExpression calcHashParameter[] oldParamsboolean hasExistingCanEqualVariableExpression otherMethodNode canEqual// the declared type of "self"// TODO: ClassHelper.make((Class<?>)groovy.lang.Category.class.getMethod("value").getDefaultValue());// if < 1, probably an AST transform or internal code (like generated metaclass field, ...)// GROOVY-6510: preserve implicit-this semantics// GROOVY-3543: visit the declaration expressions so that declaration variables get added on the varStackmarkAsProcessed(...)boolean hasExistingEquals/** An AST transform with the ability to report errors. ... */VariableExpression otherTypedCastExpression castExpressionMethodNode equalcreateCanEqual(...)MethodNode equalsfindDeclaredMethod(...)Expression classesEqualhasClassX(...)boolean canBeSelfExpression propsEqualhasEqualPropertyX(...)import ExternalizeMethodsimport ExternalizablehasSamePropertyX(...)import ObjectInputimport ObjectOutputdifferentSelfRecursivePropertyX(...)bothSelfRecursivePropertyX(...)Expression fieldsEqualhasEqualFieldX(...)/** Handles generation of code for the @ExternalizeMethods annotation. */ExternalizeMethods.classhasSameFieldX(...)differentSelfRecursiveFieldX(...)Externalizable.classbothSelfRecursiveFieldX(...)ObjectOutput.classObjectInput.classClassNode EXTERNALIZABLE_TYPE;ClassNode OBJECTOUTPUT_TYPE;ClassNode OBJECTINPUT_TYPE;Expression selfGetterExpression otherGetterorX(...)andX(...)Expression otherExpr// Look for @POJO annotation by default but annotation attribute overrides// make a public method if none exists otherwise try a private method with leading underscore// no point in the private method if one with that name already exists// an existing generated method also takes precedence// TODO use pList and fList// def _result = HashCodeHelper.initHash()// _result = HashCodeHelper.updateHash(_result, getProperty()) // plus self-reference checking// _result = HashCodeHelper.updateHash(_result, field) // plus self-reference checking// _result = HashCodeHelper.updateHash(_result, super.hashCode())// $hash$code = _result// don't null check this: prefer false to IllegalArgumentException// some short circuit cases for efficiency// defaultcreateWriteExternal(...)createReadExternal(...)Parameter outIOException.classsuffixForField(...)import ExternalizeVerifierimport static ClassNodeUtils.hasNoArgConstructorExternalizeVerifier.classClassNode SERIALIZABLE_TYPE;Parameter oinString suffixboolean checkPropertyTypeshasNoArgConstructor(...)implementsExternalizable(...)// use primitives for efficiency//        currently char isn't found due to a bug, so go with Object//        if (isPrimitiveChar(fNode.getType())) return "Character";checkProps(...)ClassNode propType/** Handles transformation for the @Field annotation. */Field.classOption.classClassNode ASTTRANSFORMCLASS_TYPE;ClassNode OPTION_TYPE;DeclarationExpression candidate;boolean insideScriptBody;String variableName;FieldNode fieldNode;ClosureExpression currentClosure;ConstructorCallExpression currentAIC;implementsSerializable(...)import Final/** Handles generation of code for the {@link Final} annotation. */Final.classAnnotatedNode candidatecheckModifiers(...)// includes constructorsnotTransform(...)acceptableTransform(...)adjustToClassVar(...)/** This is an annotation on a class, currently just {@link ASTTransformation}. ... */Expression skipList<Expression> origArgListmatchesCandidate(...)adjustConstructorAndFields(...)adjustedArgList(...)/** This is an annotation on some item that indicates that ... */List<Expression> newArgs// in the future the target will be wider than annotations, but for now it is just on annotationsimport ImmutableBaseimport static ClassNodeUtils.hasExplicitConstructorimport static ImmutablePropertyUtils.builtinOrMarkedImmutableClassimport static ImmutablePropertyUtils.createErrorMessageimport static GeneralUtils.getInstancePropertiesimport static GeneralUtils.neXExpression origArg/** Handles generation of code for the @Immutable annotation. */ImmutableBase.classClass<? extends Annotation> MY_CLASS;String IMMUTABLE_BREADCRUMB;PropertyHandler handlercreatePropertyHandler(...)doMakeImmutable(...)List<PropertyNode> newPropertiesremoveField(...)VariableScope variableScopeIterator<Variable> iteratorVariable nextClosureExpression oldConstructorCallExpression oldExpression newArgsboolean oldInsideScriptBody// GROOVY-4548: temp fix to stop CCE until proper support is added// set owner null here, it will be updated by addField// provide setter for CLI Builder purposes unless final// GROOVY-6337: in case newly created field is @Lazy// GROOVY-4833: copy annotations that are not Groovy transforms; GROOVY-6112: also copy acceptable Groovy transforms// GROOVY-5207: So that Closures can see newly added fields// (not super efficient for a very large class with many @Fields but we chose simplicity// and understandability of this solution over more complex but efficient alternatives)// TODO also check for phase after sourceUnit.getPhase()? but will be ignored anyway?// TODO we should only copy those annotations with FIELD_TARGET but haven't visited annotations// and gathered target info at this phase, so we can't do this:// return annotation.isTargetAllowed(AnnotationNode.FIELD_TARGET);// instead just don't copy ourselves for now// TODO make EmptyExpression work// partially works but not if only thing in script// return EmptyExpression.INSTANCE;// if a match is found, the compiler will have already set up aic constructor to hav// an argument which isn't needed since we'll be accessing the field; we must undo it// code doesn't mention the removed param at this point, okay to leave as is// we only need to check the variable name because the Groovy compiler// already fails if a variable with the same name already exists in the scope.// this means that a closure cannot shadow a class variableimport IndexedPropertyimport static ImmutableASTTransformation.IMMUTABLE_BREADCRUMBString cNamegetInstanceProperties(...)/** Handles generation of code for the {@code @}IndexedProperty annotation. */adjustPropertyForImmutability(...)IndexedProperty.classensureNotPublic(...)AnnotationNode tupleConsClassNode LIST_TYPE;boolean immutableaddArraySetter(...)addArrayGetter(...)addListSetter(...)addListGetter(...)unsupportedTupleAttribute(...)addGetter(...)getComponentTypeForList(...)addSetter(...)hasExplicitConstructor(...)createCopyWith(...)String tnameTupleConstructorASTTransformation.MY_TYPE_NAMEmakeName(...)Parameter[] theParamsString fName// TODO consider looking for an initial value expression that is a call to asUnmodifiable() or an// explicit call to Collections.unmodifiableList(). But currently that is processed one stage too early.FieldNode newfnimport InheritConstructors/** Handles generation of code for the {@code @}InheritConstructors annotation. */AnnotationNode annoImmutableInheritConstructors.classClassNode INHERIT_CONSTRUCTORS_TYPE;String ANNOTATION;createPropGetter(...)boolean copyConstructorAnnotationsboolean copyParameterAnnotationsClassNode sNodeneX(...)List<AnnotationNode> superAnnotationsClassNode clonedNodecreateCheckForProperty(...)/** This method exists to be binary compatible with 1.7 - 1.8.6 compiled code. */addConstructorUnlessAlreadyExisting(...)List<Expression> theArgsbuildParams(...)isExisting(...)ConstructorNode addedasImmutable(...)getAnnotationByName(...)Annotation anorigParams.length/** For compatibility with pre 2.5 compiled classes */boolean isImmutableClassNode newTypeField declaredFieldClass<?> fieldType// We need @InheritConstructors from parent classes processed first// so force that order here. The transformation is benign on an already// processed node so processing twice in any order won't matter bar// a very small time penalty.// cast argument to parameter type in case the value is null/** Handles generation of code for the @Lazy annotation */SoftReference<>.classClassNode SOFT_REF;Expression softgetInitExpr(...)String backingFieldNamecreateSoft(...)addHolderClassIdiomBody(...)addDoubleCheckedLockingBody(...)addNonThreadSafeBody(...)// TODO: Make this a method to be called from TupleConstructor xform, add check for 'defaults'?//if (unsupportedTupleAttribute(tupleCons, "useSetters")) return;// TODO: Do we need to lock down things like: $ownClass?// find longhand since the annotation from earlier versions is now a meta annotation// potentially allow Collection coercion for a constructorInnerClassNode holderClassString innerFieldNameString initializeMethodNameExpression innerFieldVariableExpression localVarsyncTarget(...)import static VisibilityUtils.getVisibility/** This class provides an AST Transformation to add a log field to a class. */addGeneratedMethodOrError(...)String DEFAULT_CATEGORY_NAME;/** This is just a dummy value used because String annotations values can not be null. ... */String DEFAULT_ACCESS_MODIFIER;AnnotatedNode targetClassAnnotationNode logAnnotationLoggingStrategy loggingStrategycreateLoggingStrategy(...)String logFieldNamelookupLogFieldName(...)String categoryNamelookupCategoryName(...)int logFieldModifierslookupLogFieldModifiers(...)LogASTTransformation$1FieldNode logNode;createSoftGetter(...)createSoftSetter(...)Expression resExprFieldNode logFieldMethodCallExpression callExpressionLoggingStrategyV2 loggingStrategyV2addLoggerFieldToClass(...)Statement mainIfExpression modifiedCalladdGuard(...)isLoggingMethod(...)usesSimpleMethodArgumentsOnly(...)Expression paramExprwrapLoggingMethodCall(...)isSimpleExpression(...)// @Lazy not meaningful with primitive so convert to wrapper if needed// we have two options:// (1) embed initExpr within holder class but redirect field access/method calls to declaring class members// (2) keep initExpr within a declaring class method that is only called by the holder class// currently we have gone with (2) for simplicity with only a slight memory footprint increase in the declaring class// expect no setterClass<?> annotationClassMethod annotationMethodimport MapConstructorimport static GeneralUtils.copyStatementsWithSuperAdjustmentLoggingStrategy.class/** Handles generation of code for the @MapConstructor annotation. */MapConstructor.classLinkedHashMap<>.classClassNode LHMAP_TYPE;boolean includePropertiesClass<? extends LoggingStrategyV2> strategyClassboolean includeSuperFieldsAbstractLoggingStrategy.classboolean includeStaticboolean noArgboolean specialNamedArgHandlingExpression preExpression postcreateConstructors(...)List<PropertyNode> superListList<PropertyNode> listParameter mapClass<? extends LoggingStrategy> strategyClassmakeMapTypedArgsTransformer(...)BlockStatement innerboolean specialNamedArgCaseisSpecialNamedArgCase(...)/** A LoggingStrategy defines how to wire a new logger instance into an existing class. ... *//** In this method, you are given a ClassNode, a field name and a category name, and you must add a new Field ... */ClosureExpression transformedcopyStatementsWithSuperAdjustment(...)processProps(...)// support the old style but they won't be as configurabledoAddConstructor(...)// only add guard to methods of the form: logVar.logMethod(params)// also don't bother with guard if we have "simple" method args// since there is no saving// GROOVY-6373: references to 'log' field are normally already FieldNodes by now, so revisit scoping// try configurable logging strategy// try legacy logging strategycreateNoArgConstructor(...)Parameter argsParamParameter argClassCodeVisitorSupport variableExpressionFixMapConstructorASTTransformation$1Statement propInitcreatePropInit(...)Statement bodyMapConstructorASTTransformation$2import MemoizedVariableExpression newVe/** Handles generation of code for the {@link Memoized} annotation. */Memoized.class// HACK: JavaStubGenerator could have snuck in a constructor we don't want/* && !specialNamedArgCase */// GROOVY-5814: Immutable is not compatible with @CompileStaticString CLOSURE_CALL_METHOD_NAME;Class<Memoized> MY_CLASS;String PROTECTED_CACHE_SIZE_NAME;String MAX_CACHE_SIZE_NAME;String CLOSURE_LABEL;String METHOD_LABEL;ClassNode OVERRIDE_CLASSNODE;ClassNode ownerClassNodeMethodNode delegatingMethodbuildDelegatingMethod(...)int protectedCacheSizegetMemberIntValue(...)int maxCacheSizeMethodCallExpression memoizeClosureCallExpressionbuildMemoizeClosureCallExpression(...)String memoizedClosureFieldNamebuildUniqueName(...)FieldNode memoizedClosureFieldimport NamedDelegateimport NamedVariantMethodCallExpression closureCallExpressionVariableScopeVisitor visitorimport static GeneralUtils.asXimport static GeneralUtils.boolXimport static GeneralUtils.elvisXimport static GeneralUtils.plusXgetOuterMostClass(...)int accessfilterAnnotations(...)NamedVariant.classNamedParam.classNamedDelegate.classClassNode NAMED_VARIANT_TYPE;String NAMED_VARIANT;ClassNode NAMED_PARAM_TYPE;ClassNode NAMED_DELEGATE_TYPE;ClassNode ILLEGAL_ARGUMENT;Parameter[] fromParamsboolean autoDelegateboolean coerceParameter mapParamList<Parameter> genParamsString MEMOIZE_METHOD_NAME;String MEMOIZE_AT_MOST_METHOD_NAME;String MEMOIZE_AT_LEAST_METHOD_NAME;String MEMOIZE_BETWEEN_METHOD_NAME;Parameter[] srcParamsList<String> propNamesClosureExpression expressionsrcParams.lengthStringBuilder nameBuilderbuildTypeName(...)boolean annoFoundfromParams.lengthParameter fromParamprocessDelegateParam(...)Map<Parameter,Expression> seennew HashMap<Parameter,Expression>(...)import Newifyimport PatternSyntaxException/** Handles generation of code for the {@code @Newify} AST transform. */Newify.classnew ConcurrentHashMap<String,ClassNode>(...)processImplicitNamedParam(...)processExplicitNamedParam(...)Expression argOrDefaultelvisX(...)hasDuplicates(...)createMapVariant(...)// for backwards compatibilityboolean requiredAnnotationNode namedParamExpression defValueearlierParamIfSeen(...)namedParamValue(...)plusX(...)List<PropertyNode> propsExpression[] subMapArgsClass<> globalClassString MY_NAME;String BASE_BAD_PARAM_ERROR;ListExpression classesToNewify;boolean auto;Pattern classNamePattern;Map<String,ClassNode> nameToGlobalClassesNodesMap;Map<String,NewifyClassData> nameToInnerClassesNodesMap;...[] globalClasses;// ClassHelper.classes minus interfaces, abstract classes, and classes with private ctorsPattern extractNamePattern;boolean autoFlagdetermineAutoFlag(...)Expression classNamesPattern cnPatterndetermineClassNamePattern(...)newifyClass(...)determineClasses(...)new Function<String,ConstantExpression>(...) { ... }newifyMethodOrField(...)newifyDeclaration(...)Expression delegateMapListExpression oldClassesToNewifyboolean oldAutoPattern oldCnPatterncheckClassLevelClashes(...)checkAutoClash(...)Parameter namedArgKeyParameter[] genParamsArrayConstantExpression constExprPatternSyntaxException e/** allow non-strict mode in scripts because parsing not complete at that point */ClassNode fromSourceUnitgetSourceUnitClass(...)asX(...)// first pass, just check for annotations of interest// the first param is the delegate// handle earlier param with or without cast// TODO: Check attribute type is assignable to declared param type?// create annotation @NamedParam(value='name', type=PropertyType)// TODO account for default params giving multiple signatures// TODO: "map.get(name)"// required for use before super ctor call/* castX( */checkDuplicateNameClashes(...)MethodCallExpression transformedisNewifyCandidate(...)transformMethodCall(...)/** Handles generation of code for the @Sealed annotation. */Class<?> NON_SEALED_CLASS;ClassNode NON_SEALED_TYPE;shouldTransform(...)DeclarationExpression newDeclhasClassesToNewify(...)Set<String> seenList<ClassExpression> classesfindClassWithMatchingBasename(...)isNewMethodStyle(...)Expression objExpression methfindMatchingCandidateClass(...)Expression argsToUseArgumentListExpression argsListExpList<Expression> argExpListVariableExpression thisVarExpList<Expression> expressionsWithThisimport NullCheckimport ConstructorNodeUtils/** Handles generation of code for the @NullCheck annotation. */CompilePhase.INSTRUCTION_SELECTIONNullCheck.classClassNode NULL_CHECK_TYPE;String NULL_CHECK_NAME;ConstructorNode EXCEPTION_STRING_CTOR;String NULL_CHECK_IS_PROCESSED;boolean includeGeneratedisIncludeGenerated(...)adjustMethod(...)NewifyClassData innerTypeClassDataClassNode importedTypeClassNode globalTypeList<ClassNode> innerClassNodesnew HashMap<String,NewifyClassData>(...)boolean generatedint startingIndexisMarkedAsProcessed(...)ConstructorCallExpression newException/** Mark a method as already processed. ... */// handles constructor case too// some transform has been here already and we assume it knows what it is doing// ignore any constructors calling this(...) or super(...)// skip over this/super() call// GROOVY-10178String pureClassNameextractName(...)NewifyClassData classDatanew NewifyClassData(...)addAdditionalType(...)innerTypeClassData.typesinnerTypeClassData.typeimport PackageScopeimport PackageScopeTargetList<ClassNode> types;/** Handles transformation for the @PackageScope annotation. ... */PackageScope.classPackageScopeTarget.classString LEGACY_TYPE_NAME;Class<> TARGET_CLASS;String TARGET_CLASS_NAME;boolean legacyModeList<PackageScopeTarget> targetsPackageScopeTarget.FIELDSPackageScopeTarget.CLASSdetermineTargets(...)visitClassNode(...)visitMethodNode(...)visitFieldNode(...)revertVisibility(...)// Void.TYPE,// Closure.class,// GString.class,// List.class,// Map.class,// Range.class,//Pattern.class,// Script.class,// Shall we allow this ? Using Boolean ctors is usually not what user wants...//Number.class,//Void.class,//Class.class,//MetaClass.class,//Iterator.class,//GeneratedClosure.class,//GeneratedLambda.class,//GroovyObjectSupport.class// set the args as they might have gotten Newify transformed GROOVY-3491// For performance reasons test against classNamePattern first// One-time-fill inner classes lookup map// If class name is looked up below, additional types will be used in error message// Inner classes// Imported classes// Global classesPackageScopeTarget.METHODSList<MethodNode> mListPackageScopeTarget.CONSTRUCTORSList<ConstructorNode> cListimport WithReadLockimport WithWriteLockList<PropertyNode> foundProps/** Handles generation of code for the {@code @}WithReadLock and {@code @}WithWriteLock annotation.<br> ... */WithReadLock.classWithWriteLock.classReentrantReadWriteLock.classClassNode READ_LOCK_TYPE;ClassNode WRITE_LOCK_TYPE;ClassNode LOCK_TYPE;String DEFAULT_STATIC_LOCKNAME;String DEFAULT_INSTANCE_LOCKNAME;boolean isWriteLockString myTypeNameFieldNode lockExprdetermineLock(...)MethodCallExpression lockTypeMethodCallExpression acquireLockMethodCallExpression releaseLockStatement originalCodeFieldNode existingLockFieldList<String> foundNamescreateLockObject(...)// get lock typePropertyNode foundPropimport RecordBase/** Handles completion of code for the @RecordType annotation. */FieldNode oldFieldRecordBase.classMethodNode copyWithadjustCopyWith(...)// when the record classnode was processed, the tuple constructor hadn't been added yet, so manually adjust hereList<Parameter> paramsgetFieldIndex(...)List<PackageScopeTarget> listnew ArrayList<PackageScopeTarget>(...)extractTarget(...)ListExpression expressionListExpression prop// now check for split propertyimport RecordOptionsimport RecordTypeModeimport SealedModeimport SealedOptionsimport static GeneralUtils.caseSimport static GeneralUtils.mapEntryXimport static GeneralUtils.mapXimport static GeneralUtils.switchS/** Handles generation of code for the @RecordType annotation. */RecordOptions.classClassNode ARRAYLIST_TYPE;String COMPONENTS;String COPY_WITH;String GET_AT;String NAMED_ARGS;int PUBLIC_FINAL;String RECORD_CLASS_NAME;ClassNode RECORD_OPTIONS_TYPE;String SIZE;String TO_LIST;String TO_MAP;SealedOptions.classClass<?> SEALED_CLASS;String SEALED_NAME;ClassNode SEALED_TYPE;ClassNode SEALED_OPTIONS_TYPE;String SEALED_ALWAYS_ANNOTATE_KEY;String SEALED_ALWAYS_ANNOTATE;boolean isPostJDK17AnnotationNode optionsdoProcessRecordType(...)RecordTypeMode modegetMode(...)SealedMode modeboolean isPostJDK16boolean doNotAnnotateboolean isNativeRecordTypeMode.EMULATESealedMode.EMULATEList<ClassNode> newSubclassesString targetBytecodeisPostJDK16(...)isPostJDK17(...)String sNameSealedMode.classSealedMode.NATIVEOpcodes.ACC_RECORDnew Consumer<ClassNode>(...) { ... }/** Reports true if native sealed class information should be written into the bytecode. ... *//** Reports true if the {@code Sealed} annotation should not be ... */new ArrayList<RecordComponentNode>(...)/** Handles sealed class permitted subclass detection. */Class<Sealed> SEALED_CLASS;addDetectedSealedClasses(...)List<Expression> namesRecordComponentNode recRecordTypeMode.NATIVEmakeClassFinal(...)makeInnerRecordStatic(...)adjustPropertyForShallowImmutability(...)ToStringASTTransformation.MY_TYPEcreateRecordToString(...)createToString(...)EqualsAndHashCodeASTTransformation.MY_TYPEcreateRecordEquals(...)createRecordHashCode(...)createGetAt(...)createToList(...)createToMap(...)createComponents(...)/** Indicates that the given classnode is a native JVM record class. ... */ClassNode tupleClassList<GenericsType> gtypesClassNode possibleSubclass/** Handles generation of code for the @Singleton annotation */boolean isLazyboolean isStrictcreateField(...)lazyBody(...)nonLazyBody(...)Expression instanceExpressionList<ConstructorNode> cNodesConstructorNode foundNoArgConstructorNode cNodemapX(...)mapEntryX(...)Expression iSwitchStatement bodyswitchS(...)addCase(...)caseS(...)Expression mapArgString namesRuntimeException.classnew Function<RecordComponentNode,String>(...) { ... }List<Object> argsnew Consumer<RecordComponentNode>(...) { ... }createFieldHandle(...)Opcodes.H_GETFIELD// guarantee shallow immutability but property handler may do defensive copyingboolean isGetterDefinedisGetterCandidate(...)setGetterName(...)// don't expect any parent to be set at this point but we only check at grammar// level when using the record keyword so do a few more sanity checks here// 0L serialVersionUID by default// Groovy currently only goes to Tuple16import SourceURI/** Handles transformation for the @SourceURI annotation. */SourceURI.classURI.classClass<SourceURI> MY_CLASS;ClassNode URI_TYPE;setScriptURIOnDeclaration(...)setScriptURIOnField(...)getSourceURI(...)isAbsolute(...)URI baseURI// Set the RHS to '= URI.create("string for this URI")'.// That may throw an IllegalArgumentExpression wrapping the URISyntaxException.// FIXME:  What should we use as the base URI?// It is unlikely we get to this point with a relative URI since making a URL// from will make it absolute I think.  But lets handle the simple case of// using file paths and turning that into an absolute file URI.// So we will use the current working directory as the base.import GroovyTypeCheckingExtensionSupport/** Handles the implementation of the {@link groovy.transform.TypeChecked} transformation. */String STATIC_ERROR_PREFIX;AnnotationNode annotationInformationExpression extensionsStaticTypeCheckingVisitor visitornewVisitor(...)addTypeCheckingExtensions(...)setMethodsToBeVisited(...)performSecondPass(...)addTypeCheckingExtension(...)new GroovyTypeCheckingExtensionSupport(...)Expression ext/** Allows subclasses to provide their own visitor. This is useful for example for transformations relying ... */new StaticTypeCheckingVisitor(...)import Synchronized/** Handles generation of code for the {@code @Synchronized} annotation. */Synchronized.classString lockExprStatement origCodeStatement newCodezeroLengthObjectArray(...)import ToStringimport static MethodCallUtils.maybeNullToStringXimport Sortableimport AbstractComparatorimport static GeneralUtils.cmpX/** Handles generation of code for the @ToString annotation. */ToString.classFormatHelper.class/** Injects a set of Comparators and sort methods. */ClassNode FORMAT_TYPE;String TO_STRING;String UNDER_TO_STRING;Sortable.classComparator<>.classClassNode COMPARABLE_TYPE;ClassNode COMPARATOR_TYPE;String OTHER;String THIS_HASH;String OTHER_HASH;String ARG0;String ARG1;createSortable(...)boolean includeSuperboolean reversedboolean cacheToStringString leftDelimList<PropertyNode> propertiesfindProperties(...)String rightDelimimplementComparable(...)String nameValueSepString fieldSepcreateCompareToMethodBody(...)boolean includeNamesPropertyNode propertycreateComparatorFor(...)boolean ignoreNullsboolean includePackageString[] delimscompareExpr(...)boolean hasExistingToStringExpression tempToStringdelims.lengthMethodNode toStringFieldNode cacheFieldExpression savedToStringcalculateToStringStatements(...)this.canBeSelfExpression value;boolean canBeSelf;List<ToStringElement> elementsnew ArrayList<ToStringElement>(...)VariableExpression firstnew ToStringElement(...)canBeSelf(...)Comparator<ToStringElement> includeComparatorcomparingInt(...)new ToIntFunction<ToStringElement>(...) { ... }tse.nameToStringElement elappendValue(...)el.valueel.nameel.canBeSelfAbstractComparator<>.classInnerClassNode cmpClassBlockStatement thenBlockFieldNode cmpFieldStatement appendValuecreateCompareMethodBody(...)maybeNullToStringX(...)appendCommaIfNotFirst(...)appendPrefix(...)ConstantExpression.FALSEtoStringPropertyName(...)// def _result = new StringBuilder()// def $toStringFirst = true// <class_name>(// it's really just a field// append super if needed// not through MOP to avoid infinite recursion// wrap up// if ($toStringFirst) $toStringFirst = false else result.append(", ")/** AST transforms may optionally implement this interface and return a priority value. ... */checkComparable(...)Comparator<PropertyNode> includeComparatornew ToIntFunction<PropertyNode>(...) { ... }import DefaultsModeimport static DefaultsMode.AUTOimport static DefaultsMode.OFFimport static DefaultsMode.ON/** Helper method used to build a binary expression that compares two values ... */cmpX(...)import static ImmutableASTTransformation.makeImmutableimport static NamedVariantASTTransformation.processImplicitNamedParam// if (this.is(other)) return 0;// perhaps overkill but let compareTo be based on hashes for commutativity// return this.hashCode() <=> other.hashCode()// int value = 0;// value = this.prop <=> other.prop;// if (value != 0) return value;// objects are equal// if (arg0 == arg1) return 0;// if (arg0 != null && arg1 == null) return -1;// if (arg0 == null && arg1 != null) return 1;// return arg0.prop <=> arg1.prop;/** Handles generation of code for the @TupleConstructor annotation. */// private final Comparator this$<property>Comparator = new <type>$<property>Comparator();/** This class is used internally by the compiler to transform expressions ... */DefaultsMode defaultsModemaybeDefaultsMode(...)boolean namedVariantboolean makeImmutablemakeImmutable(...)new ListOfExpressionsExpression(...)/** Static compilation AST node metadata keys. */new StaticCompilationMetadataKeys(...)StaticCompilationMetadataKeys STATIC_COMPILE_NODE;StaticCompilationMetadataKeys BINARY_EXP_TARGET;// used to mark a section of code as to be statically compiledStaticCompilationMetadataKeys PRIVATE_BRIDGE_METHODS;// use to tell which method should be used in a binary expressionStaticCompilationMetadataKeys PRIVATE_FIELDS_ACCESSORS;// private bridge methods are methods used by an outer class to access an inner class methodStaticCompilationMetadataKeys PRIVATE_FIELDS_MUTATORS;// private fields accessors are methods used by an inner class to access an outer class fieldStaticCompilationMetadataKeys DYNAMIC_OUTER_NODE_CALLBACK;// private fields mutators are methods used by an inner class to set an outer class fieldStaticCompilationMetadataKeys PROPERTY_OWNER;// callback for dynamic classes that contain statically compiled inner classes or methodsStaticCompilationMetadataKeys COMPONENT_TYPE;// the type of the class which owns the propertyStaticCompilationMetadataKeys RECEIVER_OF_DYNAMIC_PROPERTY;// for list.property expressions, we need the inferred component type// if a receiver is the receiver of a dynamic property (for mixed mode compilation)import TypeCheckedimport StaticCompilationMopWriterimport StaticTypesTypeChooserimport IPrimaryClassNodeOperationimport static ClassHelper.isWrapperCharacterimport static GenericsUtils.applyGenericsContextToPlaceHoldersimport static Verifier.DEFAULT_PARAMETER_GENERATEDimport static StaticCompilationMetadataKeys.BINARY_EXP_TARGETimport static StaticCompilationMetadataKeys.COMPONENT_TYPEimport static StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODSimport static StaticCompilationMetadataKeys.PRIVATE_FIELDS_ACCESSORSimport static StaticCompilationMetadataKeys.RECEIVER_OF_DYNAMIC_PROPERTYimport static StaticCompilationMetadataKeys.STATIC_COMPILE_NODEimport static StaticTypesMarker.DYNAMIC_RESOLUTIONimport static StaticTypesMarker.INITIAL_EXPRESSIONimport static StaticTypesMarker.PV_FIELDS_ACCESSimport static StaticTypesMarker.PV_FIELDS_MUTATIONimport static StaticTypesMarker.PV_METHODS_ACCESS/** This visitor is responsible for amending the AST with static compilation metadata or transform the AST so that ... */List<Expression> superParamsTypeChecked.classClassNode TYPECHECKED_CLASSNODE;ClassNode COMPILESTATIC_CLASSNODE;ClassNode ARRAYLIST_CLASSNODE;MethodNode ARRAYLIST_ADD_METHOD;MethodNode ARRAYLIST_CONSTRUCTOR;addPrivateBridgeMethods(...)addPrivateFieldsAccessors(...)addPrivateFieldAndMethodAccessors(...)addDynamicOuterClassAccessorsCallback(...)BlockStatement preBodyboolean superInPreshouldSkipClassNode(...)ClassNode previousClassNodeList<PropertyNode> tempListanyMethodSkip(...)StaticCompilationMopWriter.FACTORYforEachRemaining(...)boolean innerStaticCompileisSkippedInnerClass(...)isSkipMode(...)boolean isSkippedboolean isSCboolean hasMapConsMapConstructorASTTransformation.MY_TYPEboolean defaultscreateParam(...)Parameter nextParamComparator<Parameter> includeComparatornew ToIntFunction<Parameter>(...) { ... }addStaticTypeError(...)/** Adds special accessors and mutators for private fields so that inner classes can get/set them. */Map<String,MethodNode> privateFieldAccessorsMap<String,MethodNode> privateFieldMutatorsSet<ASTNode> accessedFieldsSet<ASTNode> mutatedFieldsint accnew HashSet<ASTNode>(...)new Supplier<Set<ASTNode>>(...) { ... }VariableScopeVisitor scopeVisitorprovidedOrDefaultInitialValue(...)illegalArgumentBlock(...)processArgsBlock(...)boolean generateAccessorboolean generateMutatorMethodNode accessorMethodCallExpression containsPropertyParameter valueMethodNode mutator/** Adds "bridge" methods for private methods of an inner/outer class so that ... */Set<ASTNode> accessedMethods// no processing if existing constructors found unless forced or ImmutableBase in play// GROOVY-8868 don't want an empty body to cause the constructor to be deleted later// If the first param is def or a Map, named args might not work as expected so we add a hard-coded map constructor in this case// we don't do it for LinkedHashMap for now (would lead to duplicate signature)// or if there is only one Map property (for backwards compatibility)// or if there is already a @MapConstructor annotation// GROOVY-10238// potentially add a no-arg constructor too// if (namedArgs.containsKey(propertyName)) propertyNode= namedArgs.propertyName;import StaticTypesWriterControllerFactoryImplimport StaticTypesTransformationimport StaticCompilationTransformer/** Handles the implementation of the {@link groovy.transform.CompileStatic} transformation. */new StaticTypesWriterControllerFactoryImpl(...)StaticTypesWriterControllerFactoryImpl factory;Map<MethodNode,MethodNode> privateBridgeMethodsnew HashMap<MethodNode,MethodNode>(...)StaticCompilationTransformer transformernew StaticCompilationTransformer(...)StaticTypeCheckingVisitor.classList<String> methodSpecificGenericsmethodSpecificGenerics(...)Parameter[] methodParametersmethodParameters.lengthGenericsType[] origGenericsTypesParameter orig/** A front-end class for {@link org.codehaus.groovy.classgen.asm.ExpressionAsVariableSlot} which ... */new ExpressionAsVariableSlot[]...[] variable;result.variableWriterController controllerClassNode thatTypeExpressionStatement bodyimport StaticPropertyAccessHelperapplyGenericsContextToPlaceHolders(...)List<String> genericTypeNamesClassHelper.COMPARABLE_TYPEMethodNode COMPARE_TO_METHOD;ConstantExpression CONSTANT_MINUS_ONE;ConstantExpression CONSTANT_ZERO;ConstantExpression CONSTANT_ONE;int tmpVarCounter;StaticCompilationTransformer staticCompilationTransformer;this.staticCompilationTransformermemorizeInitialExpressions(...)boolean equalStaticCompilationMetadataKeys.BINARY_EXP_TARGETClassNode declarationTypeCharacter ctryCharConstant(...)ClassNode anonTypetransformCharacterInitialization(...)transformNumericalInitialization(...)transformAssignmentToSetterCall(...)optimizeArrayCollectionAssignment(...)transformMultipleAssignment(...)Types.KEYWORD_INTypes.COMPARE_NOT_INtransformInOperation(...)Types.COMPARE_IDENTICALtransformEqualityComparison(...)transformRelationComparison(...)findMethodOrFail(...)transformToTargetMethodCall(...)superTransform(...)Expression ceClassNode forLoopVariableTypeconvertConstant(...)/** Adds "?.toArray(new T[0])" to "T[] array = collectionOfT" assignments. */findType(...)ClassHelper.COLLECTION_TYPEArrayExpression emptyArrayReference<ClassNode> rTypenew Reference<ClassNode>(...)MethodNode directMCT/** Adapter for {@link StaticPropertyAccessHelper#transformToSetterCall}. */ClassCodeVisitorSupport receiverMemoizerStaticCompilationVisitor$1Expression posExpression safenew CompareToNullExpression(...)List<MethodNode> propertiestransformRepeatedReference(...)classgenCallback(...)Expression ctnboolean existsexistsProperty(...)inferComponentType(...)Expression cidnew CompareIdentityExpression(...)Expression leftAndRight// GROOVY-6851, GROOVY-9151, GROOVY-10104// GROOVY-9328: apply to outer classes// @CompileDynamic// In a constructor that is statically compiled within a class that is// not, it may happen that init code from object initializers, fields or// properties is added into the constructor code. The backend assumes a// purely static constructor, so it may fail if it encounters dynamic// code here. Thus we make this kind of code fail.// already added// GROOVY-9385: mutation includes access in case of compound assignment or pre/post-increment/decrement// increment acc if it hasn't been incremented in the current iteration// private bridge methods already added// create constructor with a nested class as the first parameter, creating one if necessary// add node metadata for default parameters because they are erased by the Verifier// try to find a target// we allow auto-coercion here// it's no real property but a property of the componentListOfExpressionsExpression listList<Expression> leftExpressionsList<Expression> rightExpressionsIterator<Expression> leftItStaticCompilationTransformer transformer;this.transformerExpression optnew OptimizingBooleanExpression(...)Iterator<Expression> rightItList<Expression> tmpAssignmentsLabel asBooleanLabel unboxreplaceAsBooleanWithCompareToNull(...)/** Inline an "expr != null" check instead of boolean conversion iff: ... */isEffectivelyFinal(...)List<Expression> finalAssignmentsList<MethodNode> asBooleanVariableExpression tmpVarExpression tmpAssignmentExpression finalAssignmenttryOptimizeCharComparison(...)MethodNode adapterStaticCompilationTransformer.BYTECODE_BINARY_ADAPTERSMethodNode theAsBooleanExpression sbaStaticCompilationTransformer.BYTECODE_ADAPTER_CLASSisCompareToBoolean(...)isExtended(...)Character cLeftCharacter cRightExpression oLeftExpression oRighthasCharType(...)// undo arbitrary nesting of (Boolean|Not)Expressions// we must use the redirect node, otherwise InnerClassNode would not have the "correct" type// TODO: maybe: os.castToBool(mark, true);// check for null// GROOVY-6270// null => false// value => true// GROOVY-10711StaticTypesMarker.INFERRED_RETURN_TYPEClassHelper.Character_TYPEnew Consumer<WriterController>(...) { ... }ClassNode exprInferredTypeClassNode castType// for "char x = 'c'" change 'c' from String to char// for "int|long|short|byte|char|float|double|BigDecimal|BigInteger x = n" change n's type// GROOVY-10029//fallthrough// transform "a.x = val" into "def tmp = val; a.setX(tmp); tmp"// "a"// "setX"// "val"// "x"// transform "x = val" into "def tmp = val; this.setX(tmp); tmp"// expression that will transfer assignment and name positions// spreadSafe// TODO: replace with a proper test whether a return value is required or not// transform "left [!]in right" into "right.is[Not]Case(left)"// GROOVY-7473: no null test for simple cases// GROOVY-6137, GROOVY-7473: null safety and one-time evaluation// same-type primitive compare// transform "a <=> b" into "[Integer|Long|Short|Byte|Double|Float|...].compare(a,b)"// GROOVY-5644, GROOVY-6137, GROOVY-7473, GROOVY-10394: null safety and one-time evaluation// right == null ? 1 : left.compareTo(right)// left == null ? -1 : (right == null ? 1 : left.compareTo(right))// left === right ? 0 : (left == null ? -1 : (right == null ? 1 : left.compareTo(right)))isOptimizable(...)// pop temporary variables// (next, result) = [ result, next+result ]// -->CastExpression trn// def tmp1 = result// def tmp2 = next+result// next = tmp1// result = tmp2// replace the binary expression with a method call to ScriptBytecodeAdapter or something else// +=, -=, /=, ...// call handles the operation, so we must add the assignment now// GROOVY-5746: one execution of receiver and subscript//TODO:findType(e);// coerce is not neededimport static Opcodes.IF_ACMPEQimport static Opcodes.IF_ACMPNE/** Compares two objects using identity comparison. ... */isEq(...)Label noLabel yesboolean equalsNull;this.equalsNullStaticTypeCheckingVisitor.GENERATED_EMPTY_STATEMENTtransformArrayConstructor(...)transformRegularConstructor(...)ArrayExpression aextransformArguments(...)List<Expression> transformedArgsMapStyleConstructorCall resultnew MapStyleConstructorCall(...)MapExpression map;ConstructorCallExpression originalCall;boolean innerClassCall;List<Expression> originalExpressionsthis.originalCallthis.innerClassCallint tmpObjInnerClassNode icnMapEntryExpression entryExpression// 2 is for inner class case// 2 = inner class case// check that the node doesn't belong to the list of declared constructors// replace call to <init>(Map) or <init>(this, Map)// with a call to <init>() or <init>(this) + appropriate setters// for example, foo(x:1, y:2) is replaced with:// { def tmp = new Foo(); tmp.x = 1; tmp.y = 2; return tmp }()// create a temporary variable to store the constructed object// store it into tmp variable// load every field// consume argument// load object// cleanup stack// can be replaced with a direct constructor callClassNode DGM_CLASSNODE;Expression trntryTransformIsToCompareIdentity(...)ClassNode superCallReceivertransformToMopSuperCall(...)isCallOnClosure(...)StaticCompilationTransformer scTransformer;this.scTransformerMethodNode dmct// TODO: all obj exp// NOTE: BinaryExpressionTransformer handles the setter/** This transformer focuses on ranges to produce optimized bytecode. */IntRange.classClassNode INTRANGE_TYPE;MethodNode INTRANGE_CTOR;Expression inclLeftExpression inclRightClassNode indexTypeExpression objExprBinaryExpression arrayGetMethodNode direct/** Some expressions use symbols as aliases to method calls (&lt;&lt;, +=, ...). In static compilation, ... */new StaticMethodCallExpressionTransformer(...)new MethodCallExpressionTransformer(...)new ConstructorCallTransformer(...)new PropertyExpressionTransformer(...)new VariableExpressionTransformer(...)new ClosureExpressionTransformer(...)new BooleanExpressionTransformer(...)new BinaryExpressionTransformer(...)StaticTypeCheckingVisitor.CLOSURE_CALL_NO_ARGStaticTypeCheckingVisitor.CLOSURE_CALL_ONE_ARGnew RangeExpressionTransformer(...)/** Identifies a method call expression on {@link DefaultGroovyMethods#is(Object, Object)} and if recognized, transforms it into a {@link CompareIdentityExpression}. ... */new ListExpressionTransformer(...)new CastExpressionOptimizer(...)List<Expression> exprsCompareIdentityExpression cid// workaround for generated code in enums which use .next() returning a NumberClassNode BYTECODE_ADAPTER_CLASS;Map<Integer,MethodNode> BYTECODE_BINARY_ADAPTERS;SourceUnit unit;StaticTypeCheckingVisitor staticCompilationVisitor;StaticMethodCallExpressionTransformer staticMethodCallExpressionTransformer;// various helpers in order to avoid a potential very big classMethodCallExpressionTransformer methodCallExpressionTransformer;ConstructorCallTransformer constructorCallTransformer;PropertyExpressionTransformer propertyExpressionTransformer;VariableExpressionTransformer variableExpressionTransformer;ClosureExpressionTransformer closureExpressionTransformer;BooleanExpressionTransformer booleanExpressionTransformer;BinaryExpressionTransformer binaryExpressionTransformer;RangeExpressionTransformer rangeExpressionTransformer;ListExpressionTransformer listExpressionTransformer;CastExpressionOptimizer castExpressionTransformer;Expression xetryTransformImplicitReceiver(...)tryTransformPrivateFieldAccess(...)this.staticCompilationVisitortryTransformDirectMethodTarget(...)transformStaticMethodCallExpression(...)transformConstructorCall(...)transformBooleanExpression(...)transformRangeExpression(...)transformListExpression(...)StaticTypesMarker.PV_FIELDS_ACCESStransformCastExpression(...)/** Called by helpers when super.transform() is needed. */ClassNode prevStaticTypesMarker.PV_FIELDS_MUTATION// method has already been visited by a static type checking visitor// we need to transform variable expressions that go to a delegate// to a property expression, as ACG would lose the information in// processClassVariable before it reaches any makeCall, that could handle it// TODO: handle the owner and delegate cases better for nested scenarios and potentially remove the need for the implicit this case// GROOVY-9136: object expression should not overlap source range of property; property stands in for original variable expression// access to a private field from a section of code that normally doesn't have access to it, like a closure block or an inner class// store the declaring class so that the class writer knows that it will have to call a bridge method// GROOVY-10637: return type might be parameterizedimport MetaInfExtensionModulenew StampedCommonCache<ClassLoader,Map<String,List<MethodNode>>>(...)getDisablePropertyName(...)EvictableCache<ClassLoader,Map<String,List<MethodNode>>> cache;new ValueProvider<ClassLoader,Map<String,List<MethodNode>>>(...) { ... }getMethodsFromClassLoader(...)List<ExtensionModule> modulesnew ExtensionModuleListener(...) { ... }ExtensionModule extensionModulemakeMethodsUnmodifiable(...)/** Returns a map which contains, as the key, the name of a class. The value ... */Set<Class<>> instanceExtClassesSet<Class<>> staticExtClassesMap<String,List<MethodNode>> methodsnew HashMap<String,List<MethodNode>>(...)MetaInfExtensionModule extensionModuleaddAdditionalClassesToScan(...)scan(...)new BiFunction<String,List<MethodNode>,List<MethodNode>>(...) { ... }import MethodCallPredicate<MethodNode> methodFiltergetMethodFilter(...)Function<MethodNode,String> methodMappergetMethodMapper(...)Class<> dgmLikeClass/** <p>Custom type checking extensions may extend this method in order to benefit from a lot ... */new LinkedHashSet<MethodNode>(...)accumulate(...)Parameter[] typesExtensionMethodNode nodenew ExtensionMethodNode(...)new Function<String,List<MethodNode>>(...) { ... }new LinkedList<TypeCheckingScope>(...)/** The default type checking handler is used by the standard type checker and doesn't handle ... */new LinkedList<TypeCheckingExtension>(...)GroovyTypeCheckingExtensionSupport.classTypeCheckingContext context;Set<MethodNode> generatedMethods;LinkedList<TypeCheckingScope> scopeData;boolean handled;// this boolean is used through setHandled(boolean)typeCheckingVisitor.typeCheckingContextthis.handledTypeCheckingScope scopenew TypeCheckingScope(...)Closure<> callbackList<TypeCheckingExtension> handlers;rehydrate(...)TypeCheckingExtension handlerhandleUnresolvedVariableExpression(...)handleUnresolvedProperty(...)handleUnresolvedAttribute(...)handleIncompatibleAssignment(...)handleIncompatibleReturnType(...)Iterator<TypeCheckingExtension> itClosure<> copyscopeExit(...)newMethod(...)new MethodNode(...) { ... }AbstractTypeCheckingExtension$1handleAmbiguousMethods(...)delegatesTo(...)Closure<>.OWNER_FIRSTtypeCheckingVisitor.typeCheckingContext.delegationMetadatanew DelegationMetadata(...)isAnnotatedBy(...)Exception errList<MethodNode> handlerResultmatchWithOrWithoutBoxing(...)handleMissingMethod(...)afterVisitMethod(...)beforeVisitMethod(...)afterVisitClass(...)ClassNode[] argumentTypesbeforeVisitClass(...)argTypesMatches(...)afterMethodCall(...)beforeMethodCall(...)onMethodSelection(...)ArrayList<TypeCheckingExtension> copynew ArrayList<TypeCheckingExtension>(...)firstArgTypesMatches(...)argTypeMatches(...)setup(...)Closure<R> clonefinish(...)// we're using a copy here because new extensions can be added during the "setup" phase/** Used to instruct the type checker that the call is a dynamic method call. ... */makeDynamic(...)TypeCheckingContext.EnclosingClosureEnclosingClosure enclosingClosuregetEnclosingClosure(...)getClosureExpression(...)setHandled(...)info(...)/** Delegation metadata is used to store the delegation strategy and delegate type of ... */DelegationMetadata parent;prettyPrintType(...)int strategy;this.strategy/** Instructs the type checker that a property access is dynamic, returning an instance of an Object. ... *//** Instructs the type checker that a property access is dynamic. ... */storeType(...)/** Instructs the type checker that an unresolved variable is a dynamic variable of type Object. ... *//** Instructs the type checker that an unresolved variable is a dynamic variable. ... */getEnclosingBinaryExpression(...)pushEnclosingBinaryExpression(...)pushEnclosingClosureExpression(...)getEnclosingMethodCall(...)popEnclosingMethodCall(...)popEnclosingMethod(...)getEnclosingClassNode(...)getEnclosingMethods(...)popTemporaryTypeInfo(...)pushEnclosingClassNode(...)popEnclosingBinaryExpression(...)getEnclosingClassNodes(...)getEnclosingClosureStack(...)popEnclosingClassNode(...)pushEnclosingMethod(...)getEnclosingBinaryExpressionStack(...)getEnclosingMethodCalls(...)pushEnclosingMethodCall(...)popEnclosingClosure(...)pushTemporaryTypeInfo(...)/** A type checking extension that will take care of handling errors which are specific to enums. In particular, it will ... */getEnclosingSwitchStatement(...)this.typeCheckingVisitor.typeCheckingContextthis.typeCheckingVisitorStaticTypesMarker.TYPEAbstractTypeCheckingExtension.TypeCheckingScope parent;AbstractTypeCheckingExtension.TypeCheckingScope/** Represents method nodes which are used by the static type checker to virtually add methods ... */MethodNode extensionMethodNode;boolean isStaticExtension;// true if it's a static methodthis.extensionMethodNodethis.isStaticExtensionimport static MetaClassRegistryImpl.EXTENSION_DISABLE_PROPERTY/** This class is used to make extension methods lookup faster. Basically, it will only ... */new ExtensionMethodCache(...)ExtensionMethodCache INSTANCE;/** Base class for type checking extensions written in Groovy. Compared to its superclass, {@link TypeCheckingExtension}, ... */new HashMap<String,List<Closure<>>>(...)StaticTypeCheckingSupport.ObjectArrayStaticTypesHelper.classStaticTypeCheckingSupport.ObjectArrayStaticTypesHelperStaticTypeCheckingSupport.BooleanArrayStaticTypesHelper.classStaticTypeCheckingSupport.BooleanArrayStaticTypesHelperStaticTypeCheckingSupport.CharArrayStaticTypesHelper.classStaticTypeCheckingSupport.CharArrayStaticTypesHelperStaticTypeCheckingSupport.ByteArrayStaticTypesHelper.classStaticTypeCheckingSupport.ByteArrayStaticTypesHelperStaticTypeCheckingSupport.ShortArrayStaticTypesHelper.classStaticTypeCheckingSupport.ShortArrayStaticTypesHelperStaticTypeCheckingSupport.IntArrayStaticTypesHelper.classStaticTypeCheckingSupport.IntArrayStaticTypesHelperStaticTypeCheckingSupport.LongArrayStaticTypesHelper.classStaticTypeCheckingSupport.LongArrayStaticTypesHelperStaticTypeCheckingSupport.FloatArrayStaticTypesHelper.classStaticTypeCheckingSupport.FloatArrayStaticTypesHelperStaticTypeCheckingSupport.DoubleArrayStaticTypesHelper.classStaticTypeCheckingSupport.DoubleArrayStaticTypesHelperStaticTypeCheckingSupport.Deprecated_TYPEnew HashMap<String,String>(...) { ... }GroovyTypeCheckingExtensionSupport$1/** A visitor used as a callback to {@link org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor#existsProperty(org.codehaus.groovy.ast.expr.PropertyExpression, boolean, org.codehaus.groovy.ast.ClassCodeVisitorSupport)} ... */AtomicReference<ClassNode> result;this.resultT data;new Receiver<T>(...)/** An utility class used to wrap an expression with additional metadata used by the type checker. ... */SecondPassExpression<> thatthat.datathat.expressionMap<String,String> METHOD_ALIASES;// method name to DSL nameMap<String,List<Closure<>>> eventHandlers;// the following fields are closures executed in event-based methodsString scriptPath;/** Builds a type checking extension relying on a Groovy script (type checking DSL). ... */this.scriptPath/** A visitor which collects the list of variable expressions which are closure shared. */new LinkedHashSet<VariableExpression>(...)ImportCustomizer icTypeCheckingDSL scriptTypeCheckingDSL.classSet<VariableExpression> closureSharedExpressions;boolean visited;// we should not visit embedded closures recursively/** A signature codec is responsible for encoding and decoding of inferred returned types ... */TypeCheckingExtension.class/** First implementation of an inferred type signature codec. */Constructor<?> declaredConstructorTypeCheckingExtension extensionaddLoadingError(...)List<Closure<>> listscript.extensionsafeCall(...)UnionTypeClassNode unionClassNode[] delegatesgetDelegates(...)delegates.lengthClassNode delegatedoEncode(...)getLubName(...)List<Closure<>> onMethodSelectionwriteBoolean(...)ClassNode lbByteArrayOutputStream baosDataOutputStream dosWriter wrtString classNodeTypeboolean makeArrayreadBoolean(...)String typedescchar typeCodeUnionTypeClassNode.classdoDecode(...)new UnionTypeClassNode(...)WideningCategories.LowestUpperBoundClassNode.classboolean lowint upcClassNode[] upsnew ByteArrayInputStream(...)// object type// primitive typeIterator<Closure<>> iteratorimport UUIDimport static ClassHelper.BigInteger_TYPEimport static ClassHelper.Byte_TYPEimport static ClassHelper.COLLECTION_TYPEimport static ClassHelper.Character_TYPEimport static ClassHelper.Double_TYPEimport static ClassHelper.Enum_Typeimport static ClassHelper.Float_TYPEimport static ClassHelper.GSTRING_TYPEimport static ClassHelper.Integer_TYPEimport static ClassHelper.Long_TYPEimport static ClassHelper.Short_TYPEimport static ClassHelper.isNumberTypeimport static ClassHelper.isSAMTypeimport static ClassHelper.void_WRAPPER_TYPEimport static WideningCategories.implementsInterfaceOrSubclassOfimport static WideningCategories.lowestUpperBound// --------------------------------------------// end of delegate to the type checking context// -------------------------------------// delegate to the type checking contextGroovyTypeCheckingExtensionSupport extension;(...).lengthObject target/** Support methods for {@link StaticTypeCheckingVisitor}. */Matcher.classClass<> typeClassBaseStream<>.classnew Comparator<MethodNode>(...) { ... }Object[] argsArrayList<Closure<>> closuresextension.eventHandlersnew Function<String,List<Closure<>>>(...) { ... }Parameter[] pa1Parameter[] pa2pa1.lengthpa2.lengthboolean allEqualStaticTypeCheckingSupport.DGM_METHOD_NODE_COMPARATORExtensionMethodCache.INSTANCEClassNode Matcher_TYPE;ClassNode ArrayList_TYPE;ClassNode BaseStream_TYPE;ClassNode Collection_TYPE;ClassNode Deprecated_TYPE;// TODO: deprecate?ClassNode LinkedHashMap_TYPE;ClassNode LinkedHashSet_TYPE;Map<ClassNode,Integer> NUMBER_TYPES;Map<String,Integer> NUMBER_OPS;ClassNode GSTRING_STRING_CLASSNODE;ClassNode UNKNOWN_PARAMETER_TYPE;/** This is for internal use only. When an argument method is null, we cannot determine its type, so ... */Comparator<MethodNode> DGM_METHOD_NODE_COMPARATOR;/** This comparator is used when we return the list of methods from DGM which name correspond to a given ... */ExtensionMethodCache EXTENSION_METHOD_CACHE;EXTENSION_METHOD_CACHE.cache// since Groovy 2.2, it is possible to use FQCN for type checking extension scripts// since 2.4, we can also register precompiled type checking extensions which are not scripts// silent// cast to prevent incorrect @since 1.7 warning// fallback to the source unit classloader// fallback to the compiler classloader// if the input stream is still null, we've not found the extension/** Returns true for expressions of the form x[...] ... */isArrayOp(...)/** Called on method call checks in order to determine if a method call corresponds to the ... */import ClosureSignatureConflictResolverimport ClosureSignatureHintimport ReturnAdderimport static Collectors.toMapimport static ClassHelper.AUTOCLOSEABLE_TYPEimport static ClassHelper.PATTERN_TYPEimport static ClassHelper.RANGE_TYPEimport static ClassHelper.SET_TYPEimport static ClassHelper.STREAM_TYPEimport static ClassHelper.dynamicTypeimport static ClassHelper.isDynamicTypedimport static ClassHelper.isWrapperByteimport static ClassHelper.isWrapperDoubleimport static ClassHelper.isWrapperFloatimport static ClassHelper.isWrapperShortimport static ClosureUtils.getResolveStrategyNameimport static GenericsUtils.makeClassSafe0import static WideningCategories.isBigIntCategoryimport static WideningCategories.isDoubleimport static WideningCategories.isFloatimport static DefaultGroovyMethods.initimport static StaticTypeCheckingSupport.ArrayList_TYPEimport static StaticTypeCheckingSupport.Collection_TYPEimport static StaticTypeCheckingSupport.LinkedHashMap_TYPEimport static StaticTypeCheckingSupport.LinkedHashSet_TYPEimport static StaticTypeCheckingSupport.Matcher_TYPEimport static StaticTypeCheckingSupport.NUMBER_OPSimport static StaticTypeCheckingSupport.UNKNOWN_PARAMETER_TYPEimport static StaticTypeCheckingSupport.allParametersAndArgumentsMatchWithDefaultParamsimport static StaticTypeCheckingSupport.applyGenericsConnectionsimport static StaticTypeCheckingSupport.applyGenericsContextimport static StaticTypeCheckingSupport.boundUnboundedWildcardsimport static StaticTypeCheckingSupport.checkCompatibleAssignmentTypesimport static StaticTypeCheckingSupport.checkPossibleLossOfPrecisionimport static StaticTypeCheckingSupport.extractGenericsConnectionsimport static StaticTypeCheckingSupport.extractGenericsParameterMapOfThisimport static StaticTypeCheckingSupport.findSettersimport static StaticTypeCheckingSupport.findTargetVariableimport static StaticTypeCheckingSupport.fullyResolveimport static StaticTypeCheckingSupport.fullyResolveTypeimport static StaticTypeCheckingSupport.getCombinedBoundTypeimport static StaticTypeCheckingSupport.getCombinedGenericsTypeimport static StaticTypeCheckingSupport.getGenericsWithoutArrayimport static StaticTypeCheckingSupport.getOperationNameimport static StaticTypeCheckingSupport.isArrayOpimport static StaticTypeCheckingSupport.isBeingCompiledimport static StaticTypeCheckingSupport.isBitOperatorimport static StaticTypeCheckingSupport.isBoolIntrinsicOp/** Given a variable expression, returns the ultimately accessed variable. ... */import static StaticTypeCheckingSupport.isCompareToBooleanimport static StaticTypeCheckingSupport.isGStringOrGStringStringLUBimport static StaticTypeCheckingSupport.isOperationInGroupimport static StaticTypeCheckingSupport.isParameterizedWithGStringOrGStringStringimport static StaticTypeCheckingSupport.isParameterizedWithStringimport static StaticTypeCheckingSupport.isPowerOperatorimport static StaticTypeCheckingSupport.isShiftOperationimport static StaticTypeCheckingSupport.isTraitSelfVariable accessedVariableimport static StaticTypeCheckingSupport.isUsingGenericsOrIsArrayUsingGenericsimport static StaticTypeCheckingSupport.isVargsimport static StaticTypeCheckingSupport.isWildcardLeftHandSideimport static StaticTypeCheckingSupport.lastArgMatchesVargimport static StaticTypeCheckingSupport.missesGenericsTypesimport static StaticTypeCheckingSupport.prettyPrintTypeimport static StaticTypeCheckingSupport.prettyPrintTypeNameimport static StaticTypeCheckingSupport.resolveClassNodeGenericsimport static StaticTypeCheckingSupport.toMethodParametersStringimport static StaticTypeCheckingSupport.typeCheckMethodArgumentWithGenericsimport static StaticTypeCheckingSupport.typeCheckMethodsWithGenericsimport static StaticTypesMarker.CLOSURE_ARGUMENTSimport static StaticTypesMarker.CONSTRUCTED_LAMBDA_EXPRESSIONimport static StaticTypesMarker.DECLARATION_INFERRED_TYPEimport static StaticTypesMarker.DELEGATION_METADATAimport static StaticTypesMarker.IMPLICIT_RECEIVERfindTargetVariable(...)import static StaticTypesMarker.READONLY_PROPERTYimport static StaticTypesMarker.SUPER_MOP_METHOD_REQUIREDimport static StaticTypesMarker.TYPEMetaClassRegistryImpl.classTreeSet<MethodNode> accumulatornew TreeSet<MethodNode>(...)/** The main class code visitor responsible for static type checking. It will perform various inspections like checking ... */this.typeCheckingContextaddClosureReturnType(...)ErrorCollector.classTypeChecked.TypeCheckingInfo.classTypeChecked.TypeCheckingInfoDelegatesTo.classClosureParams.classClassHelper.ITERABLE_TYPEList<MethodNode> fromDGMClassNode componentClass/** Checks that arguments and parameter types match. ... */int distgetDistance(...)/** Checks that arguments and parameter types match, expecting that the number of parameters is strictly greater ... */ClassNode ptypeClassNode argClassHelper.TUPLE_CLASSESnew Function<Class<>,ClassNode>(...) { ... }/** Checks that excess arguments match the vararg signature parameter. ... */ClassNode vargsBaseboolean DEBUG_GENERATED_CODE;AtomicLong UNIQUE_LONG;Object ERROR_COLLECTOR;List<MethodNode> EMPTY_METHODNODE_LIST;...[] TYPECHECKING_ANNOTATIONS;getClassDistance(...)/** Checks if the last argument matches the vararg type. ... */ClassNode argumentType/** Checks if a class node is assignable to another. This is used for example in ... */ClassNode sourceComponentClassNode targetComponent/** Returns true for operations that are of the class, that given a common type class for left and right, the ... *//** Returns true or false depending on whether the right classnode can be assigned to the left classnode. This method ... */checkCompatibleAssignmentTypes(...)/** Everything that can be done by {@code castToType} should be allowed for assignment. ... */ClassNode leftRedirectClassNode rightRedirectClassNode leftComponentClassNode rightComponentGenericsType elementTypeisCovariant(...)extractType(...)isGStringOrGStringStringLUB(...)isWildcardLeftHandSide(...)isGroovyConstructorCompatible(...)/** Tells if a class is one of the "accept all" classes as the left hand side of an ... */checkPossibleLossOfPrecision(...)int leftIndexint rightIndexNumber numberbyte valshort vallong valfloat valStringJoiner joinerClassNode parameter/** Returns string representation of type with generics. Arrays are indicated ... *//** Returns string representation of type *no* generics. Arrays are indicated ... */prettyPrintTypeName(...)ClassNode TYPECHECKING_INFO_NODE;int CURRENT_SIGNATURE_PROTOCOL_VERSION;LowestUpperBoundClassNode cnExpression CURRENT_SIGNATURE_PROTOCOL;MethodNode GET_DELEGATE;MethodNode GET_OWNER;MethodNode GET_THISOBJECT;ClassNode DELEGATES_TO;ClassNode DELEGATES_TO_TARGET;ClassNode CLOSUREPARAMS_CLASSNODE;ClassNode NAMED_PARAMS_CLASSNODE;ClassNode NAMED_PARAM_CLASSNODE;ClassNode LINKEDHASHMAP_CLASSNODE;ClassNode ENUMERATION_TYPE;ClassNode MAP_ENTRY_TYPE;ClassNode ITERABLE_TYPE;List<ClassNode> TUPLE_TYPES;MethodNode CLOSURE_CALL_NO_ARG;MethodNode CLOSURE_CALL_ONE_ARG;MethodNode CLOSURE_CALL_VARGS;Statement GENERATED_EMPTY_STATEMENT;ReturnAdder.ReturnStatementListener returnListener;ReturnAdder.ReturnStatementListenerReturnAdder returnAdder;PropertyNode currentProperty;DefaultTypeCheckingExtension extension;TypeCheckingContext typeCheckingContext;isBeingCompiled(...)new TypeCheckingContext(...)ClassNode unwrapReceiverpushErrorCollector(...)ClassNode unwrapComparethis.typeCheckingContext.sourcethis.extensionnew DefaultTypeCheckingExtension(...)addHandler(...)new EnumTypeCheckingExtension(...)new TraitTypeCheckingExtension(...)/** Returns the current type checking context. The context is used internally by the type ... */Object typeSet<MethodNode> oldSettypeCheckingContext.alreadyVisitedMethodsInteger closureParamCountpopErrorCollector(...)new Consumer<MethodNode>(...) { ... }new Consumer<ConstructorNode>(...) { ... }/** Returns array of type checking annotations. Subclasses may override this ... */ClassNode tcagetTypeCheckingAnnotations(...)/** Returns true if the provided class node, when considered as a receiver of a message or as a parameter, ... *//** Returns the method(s) which best fit the argument types. ... */int bestDistTypeCheckingMode.SKIPList<MethodNode> bestChoicesboolean duckTypeboolean noCullingIterable<MethodNode> candidatesremoveCovariantsAndInterfaceEquivalents(...)MethodNode safeNodeClassNode[] safeArgsboolean isExtensionMethodClassNode actualReceiver/** Tests if a node is an inner class node, and if it is, then checks if the enclosing method is skipped. ... */Map<GenericsType,GenericsType> specmakeRawTypes(...)measureParametersAndArgumentsDistance(...)GenericsType[] methodGenericsmethodGenerics.lengthIterator<GenericsType> itnew Function<Object,LinkedHashSet<Object>>(...) { ... }getExtensionDistance(...)List<MethodNode> onlyExtensionMethodsMethodNode choiceint allMatchallParametersAndArgumentsMatch(...)int endMatchfirstParametersAndArgumentsMatch(...)lastArgMatchesVarg(...)getVarargsDistance(...)/** Checks for private field access from inner or outer class. */int excessArgumentsDistanceexcessArgumentsMatchesVargsParameter(...)getOutermost(...)StaticTypesMarker accessKindParameter[] firstParamsaddPrivateFieldOrMethodAccess(...)/** Checks for private method call from inner or outer class. */firstParams.lengthClassNode enclosingClassNodeboolean sameModulestoreTypeForSuper(...)storeTypeForThis(...)DelegationMetadata dmgetDelegationMetadata(...)Optional<GenericsType> valuetryVariableExpressionAsProperty(...)getInferredTypeFromTempInfo(...)checkOrMarkPrivateAccess(...)isTargetOfEnclosingAssignment(...)BinaryExpression enclosingBinaryExpressionSetterInfo setterInforemoveSetterInfo(...)ensureValidSetter(...)Parameter prmnew ParameterVariableExpression(...)VariableExpression.SUPER_EXPRESSIONmakeSuper(...)makeThis(...)String receiverBoolean dynamicnew Supplier<ClassNode>(...) { ... }findCurrentInstanceOfClass(...)makeRawType(...)ClassNode fromTypeClassNode toTypeClassNode rangeTypeClassNode rawList<MethodNode> listClassNode lTypeboolean isEmptyDeclarationgetOriginalDeclarationType(...)applyTargetType(...)BinaryExpression reverseExpressiongetResultType(...)storeTargetMethod(...)Expression fullExpressionExpression enclosingExpressionRHSClassNode[] argumentstypeCheckMethodsWithGenericsOrFail(...)addNoMatchingMethodError(...)inferDiamondType(...)adjustForTargetType(...)typeCheckAssignment(...)wrapTypeIfNecessary(...)List<MethodNode> toBeRemovedMethodNode oneMap<GenericsTypeName,GenericsType> enclosingextractGenericsParameterMapOfThis(...)MethodNode twofullyResolveType(...)ClassNode oneDCClassNode twoDCClassNode oneRTClassNode twoRTnew Supplier<Map<GenericsTypeName,GenericsType>>(...) { ... }typeCheckingContext.ifElseForWhileAssignmentTracker/** Given a receiver and a method node, parameterize the method arguments using ... */Map<GenericsTypeName,GenericsType> genericFromReceiverMap<GenericsTypeName,GenericsType> contextPlaceholdersParameter methodParameterbuildParameter(...)/** Given a parameter, builds a new parameter for which the known generics placeholders are resolved. ... */Variable targetVariableClassNode resolvedresolveClassNodeGenerics(...)pushInstanceOfTypeInfo(...)validateResourceInARM(...)typeCheckingContext.secondPassExpressionsParameter subMethodParameterParameter component/** Returns true if a class makes use of generic types. If node represents an ... */isUsingGenericsOrIsArrayUsingGenerics(...)new SecondPassExpression<Object>(...)/** Given a generics type representing SomeClass&lt;T,V&gt; and a resolved placeholder map, returns a new generics type ... */GenericsType fromMapisResource(...)ClassNode[] copyinferParameterAndReturnTypesOfClosureOnRHS(...)int upperBoundsLengthLambdaExpression lambdaExpressionconstructLambdaExpressionForMethodReference(...)gts.lengthisClosureWithType(...)GenericsType returnTypestoreInferredReturnType(...)getCombinedBoundType(...)fullyResolve(...)/** Checks that the parameterized generics of an argument are compatible with the generics of the parameter. ... */Tuple2<ClassNode[],ClassNode> typeInfoparameterizeSAM(...)Parameter[] closureParametersClassNode[] samParameterTypesboolean samCoerciontypeCheckMethodArgumentWithGenerics(...)ClassNode[] realTypesMethodNode realMethodtypeCheckMethodsWithGenerics(...)boolean failureSet<GenericsTypeName> fixedPlaceHoldersMap<GenericsTypeName,GenericsType> candidateGenericsboolean skipBecauseOfInnerClassNotReceivernew HashSet<GenericsTypeName>(...)closureParameters.lengthsamParameterTypes.lengthcheckParamType(...)toMethodParametersString(...)/** Given a binary expression corresponding to an assignment, will check that ... */VariableExpression receiversetterInfo.receiverTypeFunction<Expression,MethodNode> setterCallnew Function<Expression,MethodNode>(...) { ... }inferenceCheck(...)applyGenericsContext(...)setterInfo.nameextractResolvedPlaceHolders(...)Function<MethodNode,ClassNode> setterTypenew Function<MethodNode,ClassNode>(...) { ... }Set<GenericsTypeName> resultextractPlaceHolders(...)Entry<GenericsTypeName,GenericsType> entryMap<>.Entry<GenericsTypeName,GenericsType>GenericsType valueisCompoundAssignment(...)Map<GenericsTypeName,GenericsType> connectionssetterInfo.settersnew LinkedHashMap<GenericsTypeName,GenericsType>(...)getDeclaredOrInferredType(...)ClassNode firstSetterTypeaddAssignmentError(...)ClassNode resolvedTypeextractGenericsConnections(...)GenericsType candidateGenericsType resolvedhasNonTrivialBounds(...)compatibleConnection(...)new Predicate<GenericsType[]>(...) { ... }applyGenericsConnections(...)addMissingEntries(...)getUpperBounds(...).lengthArgumentListExpression argumentListGenericsType oldValueGenericsType newValuegetCombinedGenericsType(...)ClassNode replacementTypeClassNode suitabilityTypeinferReturnTypeGenerics(...)new Function<GenericsType[],ClassNode>(...) { ... }GenericsType[] lhsGenericsType[] rhslhs.lengthrhs.lengthadjustGenerics(...)ClassNode lower1ClassNode lower2ClassNode[] upper1ClassNode[] upper2equalIncludingGenerics(...)upper1.lengthupper2.length/** Stores information about types when [objectOfInstanceof instanceof typeExpression] is visited. ... */List<ClassNode> potentialTypesGenericsType[] gt1GenericsType[] gt2gt1.lengthgt2.length/** Uses supplied type to make a connection from usage to declaration. ... */storeGenericsConnection(...)extractTemporaryTypeInfoKey(...)typeCheckingContext.temporaryIfBranchTypeInformationnew Function<Object,List<ClassNode>>(...) { ... }ClassNode goalClassNode boundTypeString placeholderNamegetGenericsWithoutArray(...)GenericsType[] newGTsGenericsType specTypeGenericsType newGTListExpression valuesList<Expression> tupleExpressionsList<Expression> valueExpressionsClassNode cn1ClassNode cn2buildListType(...)/** Apply the bounds from the declared type when the using type simply declares a parameter as an unbounded wildcard. ... */boundUnboundedWildcards(...)actual.lengthboundUnboundedWildcard(...)GenericsType newTypeClassNode leftComponentTypeClassNode rightComponentTypeClassNode[] typescheckGroovyStyleConstructor(...)Map<GenericsTypeName,GenericsType> mapClassNode[] argTypesMapExpression mapExpressioncheckGroovyConstructorMap(...)missesGenericsTypes(...)isParameterizedWithString(...)isParameterizedWithGStringOrGStringString(...)/** Filter methods according to visibility ... */boolean isEnclosingInnerClassClassNode rTypeWrappedadjustTypeForSpreading(...)typeCheckMultipleAssignmentAndContinue(...)addedReadOnlyPropertyError(...)StaticTypeCheckingVisitor.EMPTY_METHODNODE_LISTClassNode lTypeRedirectaddPrecisionErrors(...)addListAssignmentConstructorErrors(...)addMapAssignmentConstructorErrors(...)hasGStringStringError(...)isConstructorAbbreviation(...)checkTypeGenerics(...)AtomicReference<ClassNode> pTypenew AtomicReference<ClassNode>(...)new PropertyLookupVisitor(...)boolean replaceType/** Checks that a constructor style expression is valid regarding the number ... */List<MethodNode> constructorList/** Determines if node is a raw type or references any generics placeholders. */GenericsType[] cnGenericsGenericsType[] rnGenericscnGenerics.length/** A helper method that can be used to evaluate expressions as found in annotation ... */randomUUID(...)ClassNode simpleClass/** When instanceof checks are found in the code, we store temporary type ... *//** A helper method which determines which receiver class should be used in error messages when a field or attribute ... */List<ClassNode> nodesgetTemporaryTypesForExpression(...)/** Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the ... */Set<ClassNode> enclosingTypesboolean staticOnlyAccessboolean foundGetterOrSetterString capNameSet<ClassNode> handledNodesList<Receiver<String>> receiversnew ArrayList<Receiver<String>>(...)ClassNode rawType/** Collects all interfaces of a class node, including those defined by the ... */ClassNode found/** Returns true if the class node represents a the class node for the Class class ... */addReceivers(...)makeOwnerList(...)Receiver<String> receiverLinkedList<ClassNode> queueFieldNode lengthTraits.THIS_OBJECTboolean staticOnly/** A DGM-like class which adds support for method calls which are handled ... */getData(...)findGetter(...)List<MethodNode> settersfindSetters(...)allowStaticAccessToMember(...)storeField(...)hasAccessToMember(...)String delegationDatastoreInferredTypeForPropertyExpression(...)SetterInfo infonew SetterInfo(...)FieldNode virtualputSetterInfo(...)storeProperty(...)ClassNode dgmReceiver// we already know there are at least params.length elements in both arraysList<MethodNode> bestMethods// no default value// a default value exists, we can skip this param// we already know parameter length is bigger zero and last is a vargs// the excess arguments are all put in an array for the vargs call// so check against the component type// two cases remain:// the argument is wrapped in the vargs array or// the argument is an array that can be used for the vargs part directly// testing only the wrapping case since the non-wrapping is done already// GROOVY-10720: check primitive to/from non-primitive// perform additional check on generics// GROOVY-10067: unresolved argument like "N extends Number" for parameter like "Integer"// this is only correct in this specific context; normally// we would have to compile against compareTo if available// but since we don't compile here, this one is enoughMethodNode mopMethod// Object[] can accept any collection element type(s)//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ GROOVY-8984: "? super T" is only compatible with an Object[] target// Object[] can accept any stream API element type(s)// byte, char, int, long or short can be assigned any base number/* || rightRedirect == char_TYPE */// float or double can be assigned any base number type or BigDecimal// must precede non-final types// RHS not adaptable// GROOVY-7307, GROOVY-9952, et al.// GROOVY-10067, GROOVY-10342// BigDecimal or Number can be assigned any derivitave of java.lang.Number// BigInteger can be assigned byte, char, int, long, short or BigInteger// Enum types can be assigned String or GString (triggers `valueOf` call)// Object, String, [Bb]oolean or Class can be assigned anything (except null to boolean)// if right is array, map or collection we try invoking the constructor// TODO: in case of the array we could maybe make a partial check// GROOVY-7316, GROOVY-10256: "Type x = m()" given "def <T> T m()"; T adapts to target// identical types// here we must check if the right number is short enough to fit in the left type// byte// short// long// float// double// no possible loss here// possible loss of precision//TODO: !POJO !Trait// Add a penalty against boxing or unboxing, to get a resolution similar to JLS 15.12.2// (http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2).// GROOVY-5114: Object[] vs Object// GROOVY-9881: in case of multiple overloads, give preference to equal parameter count// GROOVY-9852: @FunctionalInterface vs ObjectClassNode propertyTypegetTypeForMapPropertyExpression(...)getTypeForListPropertyExpression(...)getTypeForSpreadExpression(...)// GROOVY-8965: type disjunction// prepend self-type as first argument/* TODO: corner case ... */// none visible// GROOVY-10322: remove hidden type parameters// GROOVY-6849: prefer extension method in case of ambiguity// varargs methods must not be preferred to methods without varargs// for example :// int sum(int x) should be preferred to int sum(int x, int... y)// there are three case for vargs// (1) varg part is left out (there's one less argument than there are parameters)// (2) last argument is put in the vargs array//     that case is handled above already when params and args have the same length// (3) there is more than one argument for the vargs array// check first parameters// ensure exact matches are preferred over vargs// imperfect solution to determining if two methods are// equivalent, for example String#compareTo(Object) and// String#compareTo(String) -- in that case, the Object// version is marked as synthetic// GROOVY-6882, GROOVY-6970: drop overridden or interface equivalent method// GROOVY-10364: skip placeholder from the enclosing contextClassNode itemTypeAtomicReference<ClassNode> propertyType// argument is null// incompatible assignment// verify component type// verify component type, but if we reach that point, the only possibility is that the argument is// the last one of the call, so we're in the cast of a vargs call// (otherwise, we face a type checker bug)// object expression is implicit argument// this is a limitation that must be removed in a future version; we// cannot check generic type arguments if there is default argument!// correct receiver for inner class// we assume the receiver is an instance of the declaring class of the// candidate method, but findMethod() returns also outer class methods// for that receiver; for now we skip receiver-based checks in that case// not in scope// first remove hidden params// GROOVY-8034: non-static method may use class generics// the outside context parts till now define placeholder we are not allowed to// generalize, thus we save that for later use...// extension methods are special, since they set the receiver as// first parameter. While we normally allow generalization for the first// parameter, in case of an extension method we must not.// re-load fixed names for extension// GROOVY-8090: handle generics varargs like "T x = ...; Arrays.asList(x)"// the context we compare with in the end is the one of the callsiteClassNode iteratorType// so far we specified the context of the method declaration only// thus for each argument, we try to find the connected generics first// each new connection must comply with previous connections// GROOVY-5692, GROOVY-10006: multiple witnesses// was "T=Integer" and now is "T=Number" or "T=Object"// combine "T=Integer" and "T=String" to produce "T=? extends Serializable & Comparable<...>"getTypeForMultiValueExpression(...)// incompatible// GROOVY-10337// apply the new information to refine the method level information so// that the information slowly becomes information for the callsite// since it is possible that the callsite uses some generics as well,// we may have to add additional elements here// to finally see if the parameter and the argument fit together,// we use the provided information to transform the parameter// into something that can exist in the callsite context// test compatibility with "? super Type"ClassNode listType// GROOVY-10280, et al.// entry could be T=T, T=T extends U, T=V, T=String, T=? extends String, etc.// T=T or V, not T=String or ? ...// find "V" in T=V// GROOVY-10315, GROOVY-10317// GROOVY-6787: Don't override the original if the replacement doesn't respect the bounds otherwise// the original bounds are lost, which can result in accepting an incompatible type as an argument!// GROOVY-9998: apply upper/lower bound for unknown// discard the placeholderClassNode mapType// "T extends java.util.List<X> -> java.util.List<E>" vs "java.util.List<E>"// GROOVY-9974, GROOVY-10052: Lambda, Closure, Pointer or Reference for SAM-type receiver//GROOVY-10646// GROOVY-9998// di like "? super Collection<T>" and ui like "List<Type>"//connections.merge(new GenericsTypeName(placeholderName), gt, (gt1, gt2) -> getCombinedGenericsType(gt1, gt2));//type.isGenericsPlaceHolder()// GROOVY-10646: non-static inner class + outer class type parameter// convert Type<T> to Type<...>// convert T to Type or Type<...>// convert T to X// TODO: This method should really return some kind of meta ClassNode// representing the combination of all bounds. The code here just picks// something out to be able to proceed and is not actually correct.// GROOVY-10328// GROOVY-9998, GROOVY-10499: unpack "?" that is from "? extends T"// GROOVY-10055, GROOVY-10619: purge self references// GROOVY-9570: find the innermost class or methodGenericsType v// adjust configuration so class can be inspected by this JVM// unlikely to be required by expression/** Filters search result to prevent access to instance members from a static ... */T list/** This enumeration is used by the AST transformations which rely on static type checking, either ... */new StaticTypesMarker(...)StaticTypesMarker INFERRED_TYPE;StaticTypesMarker DECLARATION_INFERRED_TYPE;// used to store type information on class nodesStaticTypesMarker INFERRED_RETURN_TYPE;// in flow analysis, represents the type of the declaration node lhsStaticTypesMarker CLOSURE_ARGUMENTS;// used to store inferred return type for methods and closuresStaticTypesMarker READONLY_PROPERTY;// used to store closure argument types on a variable expressionStaticTypesMarker INITIAL_EXPRESSION;// used to tell that a property expression refers to a readonly propertyStaticTypesMarker DIRECT_METHOD_CALL_TARGET;// used to store the default expression for a parameterStaticTypesMarker DELEGATION_METADATA;// used to store the MethodNode a MethodCallExpression should targetStaticTypesMarker IMPLICIT_RECEIVER;// used to store the delegation strategy and delegate type of a closure when declared with @DelegatesToStaticTypesMarker PV_FIELDS_ACCESS;// if the receiver is implicit but not "this", store the name of the receiver (delegate or owner)StaticTypesMarker PV_FIELDS_MUTATION;// set of private fields that are accessed from closures or inner classesStaticTypesMarker PV_METHODS_ACCESS;// set of private fields that are set from closures or inner classesStaticTypesMarker DYNAMIC_RESOLUTION;// set of private methods that are accessed from closures or inner classesStaticTypesMarker SUPER_MOP_METHOD_REQUIRED;// call recognized by a type checking extension as a dynamic method callStaticTypesMarker PARAMETER_TYPE;// used to store the list of MOP methods that still have to be generatedStaticTypesMarker INFERRED_FUNCTIONAL_INTERFACE_TYPE;// used to store the parameter type information of method invocation on an expressionStaticTypesMarker CONSTRUCTED_LAMBDA_EXPRESSION;// used to store the function interface type information on an expressionStaticTypesMarker SWITCH_CONDITION_EXPRESSION_TYPE;// used to store the constructed lambda expression for method reference and constructor referenceStaticTypesMarker TYPE;// used to store the condition expression type of the switch-case statementnew Function<MethodNode,MethodNode>(...) { ... }// used to store the result of `org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.getType`storeWithResolve(...)MethodNode enclosing/** A type checking extension that will take care of handling errors which are specific to traits. In particular, it will ... */List<MethodNode> NOTFOUND;MethodNode implicitGetterMethodNode implicitSetterString[] decomposeddecomposeSuperCallName(...)convertToDynamicCall(...)ClassNode dynamicTraitASTTransformation.DO_DYNAMICgetReceiver(...)resolveGenericsWithContext(...)isStaticTraitReceiver(...)isThisTraitReceiver(...)Map<GenericsTypeName,GenericsType> placeholdersFromContextList<ClassNode> candidatesboolean osctypeCheckingContext.isInStaticContextvisitInitialExpression(...)BinaryExpression dummyMap<VariableExpression,ClassNode> varOrigTypenew HashMap<VariableExpression,ClassNode>(...)Map<VariableExpression,List<ClassNode>> oldTrackerpushAssignmentTracking(...)new VariableExpressionTypeMemoizer(...)Traits.STATIC_THIS_OBJECTString traitNameLinkedHashSet<ClassNode> traitsAsListcollectAllInterfacesReverseOrder(...)typeCheckingContext.controlStructureVariablesisSecondPassNeededForControlStructure(...)/** Returns the inferred loop element type given a loop collection type. Used, ... */ClassNode[] implementedTraitsClassNode nextTraitClassNode[] newArgsClassNode inferredReturnTypeClassNode colinferTraitMethodReturnType(...)implementedTraits.lengthClassNode implementedTraitList<MethodNode> candidatesEntry<VariableExpression,ClassNode> entryMap<>.Entry<VariableExpression,ClassNode>popAssignmentTracking(...)ClassNode origTypeClassNode typeRe// GROOVY-7322// static method call in trait?// GROOVY-8272 support inherited static methodsnegativeOrPositiveUnary(...)Expression operandint operatorvisitPrefixOrPostifExpression(...)Optional<Token> tokenasAssignment(...)new Consumer<Token>(...) { ... }new LinkedList<ErrorCollector>(...)ClassNode operandTypeboolean isPostfixgetMathWideningClassNode(...)addUnsupportedPreOrPostfixExpressionError(...)getInferredReturnType(...)addReturnType(...)ClassNode receiverMethodNode ctorvisitMethodCallArguments(...)looksLikeNamedArgConstructor(...)typeCheckMapConstructor(...)new Stack<Map<Object,List<ClassNode>>>(...)Map<GenericsTypeName,GenericsType> contextextractGenericsConnectionsFromArguments(...)resolvePlaceholdersFromImplicitTypeHints(...)checkForbiddenSpreadArgument(...)Set<MethodNode> methodstypeCheckingContext.methodsToBeVisitedTupleExpression texpMapExpression argListnew IdentityHashMap<BlockStatement,Map<VariableExpression,List<ClassNode>>>(...)List<ClassNode> tempTypesList<ClassNode> typesMap<VariableExpression,ClassNode> varTypesSharedVariableCollector collectornew SharedVariableCollector(...)Set<VariableExpression> closureSharedVariablesgetClosureSharedExpressions(...)Map<VariableExpression,Map<StaticTypesMarker,Object>> variableMetadataDelegationMetadata dmdnew HashSet<MethodNode>(...)new HashMap<VariableExpression,Map<StaticTypesMarker,Object>>(...)new LinkedHashSet<SecondPassExpression<>>(...)saveVariableExpressionMetadata(...)new HashMap<VariableExpression,List<ClassNode>>(...)typeCheckingContext.delegationMetadatanewDelegationMetadata(...)getStrategy(...)getReturnTypes(...)wrapClosureType(...)restoreVariableExpressionMetadata(...)Expression nameExprString nameTextReceiver<String> currentReceiverfindMethodsWithGenerated(...)new HashMap<Parameter,ClassNode>(...)new ToIntFunction<MethodNode>(...) { ... }new IntBinaryOperator(...) { ... }Map<GenericsTypeName,GenericsType> gtsnew BinaryOperator<ClassNode>(...) { ... }ClassNode closureTypenew TreeSet<Long>(...)new BiConsumer<VariableExpression,Map<StaticTypesMarker,Object>>(...) { ... }StaticTypesMarker markerMap<StaticTypesMarker,Object> metadatanew EnumMap<StaticTypesMarker,Object>(...)StaticTypesMarker.classshouldSkipMethodNode(...)ErrorCollector collectorstartMethodInference(...)isNonStaticHelperMethod(...)readClosureParameterAnnotation(...)visitDefaultParameterArguments(...)Expression optionsgetSignaturesFromHint(...)new Function<ClassNode,Parameter>(...) { ... }StaticTypeCheckingVisitor$1ConstructorNode initClassNode rtypeSignatureCodec codecgetCodec(...)String genericsSignatureencode(...)ConstantExpression signaturenew LinkedList<Receiver<String>>(...)List<MethodNode> mnReceiver<String> chosenReceiverboolean callArgsVisiteddisambiguateMethods(...)new LinkedList<BlockStatement>(...)MethodNode directMethodCallCandidateaddAmbiguousErrorMessage(...)checkClosureMetadata(...)ArgumentListExpression argListClosureExpression closure/** Visits a method call target, to infer the type. Don't report errors right ... */new LinkedList<SwitchStatement>(...)int nExpressionsClosureExpression sourceParameter targetcheckClosureWithDelegatesTo(...)inferClosureParameterTypes(...)checkNamedParamsAnnotation(...)inferMethodReferenceType(...)Map<Object,Expression> entriesnew LinkedHashMap<Object,Expression>(...)new LinkedList<EnclosingClosure>(...)List<String> collectedNamesnew LinkedList<BinaryExpression>(...)this.visitorStaticTypeCheckingVisitor visitor;/* public TypeCheckingContext(final SourceUnit source) { ... */LinkedList<ErrorCollector> errorCollectors;processNamedParam(...)new Function<ErrorCollector,CompilerConfiguration>(...) { ... }new Supplier<CompilerConfiguration>(...) { ... }Stack<Map<Object,List<ClassNode>>> temporaryIfBranchTypeInformation;/** Stores information which is only valid in the "if" branch of an if-then-else statement. This is used when the if ... */Map<Object,List<ClassNode>> potentialTypesnew HashMap<Object,List<ClassNode>>(...)Entry<Object,Expression> entryMap<>.Entry<Object,Expression>ConstantExpression constXClassExpression typeX/** Performs type inference on closure argument types whenever code like this ... */Expression conflictResolverdoInferClosureParameterTypes(...)DelegationMetadata delegationMetadata;/** Whenever a method using a closure as argument (typically, "with") is ... */// TODO: Should these be fields of StaticTypeCheckingVisitor?boolean isInStaticContext;ClassNode lastImplicitItType;/** The type of the last encountered "it" implicit parameter. */Set<MethodNode> methodsToBeVisited;boolean isConstructorMap<VariableExpression,List<ClassNode>> ifElseForWhileAssignmentTracker;boolean hasTypeArguments/** This field is used to track assignments in if/else branches, for loops and ... */IdentityHashMap<BlockStatement,Map<VariableExpression,List<ClassNode>>> blockStatements2Types;/** This field used for type derivation ... */Set<MethodNode> alreadyVisitedMethods;LinkedHashSet<SecondPassExpression<>> secondPassExpressions;extractPlaceHoldersVisibleToDeclaration(...)/** Some expressions need to be visited twice, because type information may be insufficient at some point. For ... */Map<VariableExpression,List<ClassNode>> closureSharedVariablesAssignmentTypes;/** A map used to store every type used in closure shared variable assignments. In a second pass, we will compute the ... */Map<Parameter,ClassNode> controlStructureVariables;Set<Long> reportedErrors;// this map is used to ensure that two errors are not reported on the same line/columnLinkedList<ClassNode> enclosingClassNodes;// TODO: replace with general node stack and filtersLinkedList<MethodNode> enclosingMethods;LinkedList<Expression> enclosingMethodCalls;LinkedList<BlockStatement> enclosingBlocks;LinkedList<SwitchStatement> switchStatements;LinkedList<EnclosingClosure> enclosingClosures;LinkedList<BinaryExpression> enclosingBinaryExpressions;// stores the current binary expression. This is used when assignments are made with a null object, for type inference/** Pushes a binary expression into the binary expression stack. *//** Pops a binary expression from the binary expression stack. *//** Returns the binary expression which is on the top of the stack, or null ... *//** Returns the current stack of enclosing binary expressions. The first ... */ClassNode[] samParamTypesnew Predicate<BinaryExpression>(...) { ... }ClassNode[] paramTypesboolean typeParametersResolvedExpression emc/** Pushes a closure expression into the closure expression stack. */GenericsType[] typeArgumentsnew EnclosingClosure(...)/** Pops a closure expression from the closure expression stack. *//** Returns the closure expression which is on the top of the stack, or null ... *//** Returns the current stack of enclosing closure expressions. The first ... *//** Pushes a class into the classes stack. *//** Pops a class from the enclosing classes stack. *//** Returns the class node which is on the top of the stack, or null ... *//** Returns the current stack of enclosing classes. The first ... *//** Pushes a method into the method stack. */Parameter[] p/** Pops a method from the enclosing methods stack. *//** Returns the method node which is on the top of the stack, or null ... *//** Returns the current stack of enclosing methods. The first ... *//** Pushes a method call into the method call stack. ... *//** Pops a method call from the enclosing method call stack. */Map<GenericsTypeName,GenericsType> gc/** Returns the method call which is on the top of the stack, or null ... *//** Returns the current stack of enclosing method calls. The first ... */Parameter[] q/** Pushes a switch statement into the switch statement stack. */ClassNode[] rextractTypesFromParameters(...)/** Pops a switch statement from the enclosing switch statements stack. */ClassNode[] s/** Returns the switch statement which is on the top of the stack, or null ... *//** Returns the current stack of enclosing switch statements. The first ... */r.length/** Represents the context of an enclosing closure. An enclosing closure wraps ... */ClosureExpression closureExpression;List<ClassNode> returnTypes;new BiConsumer<GenericsTypeName,GenericsType>(...) { ... }this.closureExpressionsamParamTypes.lengthString hintTypeNameClass<? extends ClosureSignatureHint> hintClassList<ClassNode[]> closureSignaturesgetClosureSignatures(...)convertToStringArray(...)/** This interface defines a high-level API for handling type checking errors. As a dynamic language and a platform ... */StaticTypeCheckingVisitor typeCheckingVisitor;/** Subclasses should implement this method whenever they need to perform ... *//** Subclasses should implement this method if they need to perform additional ... *//** This method is called by the type checker when a variable expression cannot ... *//** This method is called by the type checker when a property expression cannot ... *//** This method is called by the type checker when an attribute expression cannot ... *//** This method is called by the type checker when a method call cannot be resolved. Extensions ... *//** This method is called by the type checker when an assignment is not allowed by the type checker. ... *//** This method is called by the type checker before throwing an "ambiguous method" error, giving the chance ... *//** Allows the extension to perform additional tasks before the type checker actually visits a method node. ... *//** Allows the extension to perform additional tasks after the type checker actually visited a method node. ... *//** Allows the extension to perform additional tasks before the type checker actually visits a class node. ... *//** Allows the extension to perform additional tasks after the type checker actually visited a class node. ... *//** Allows the extension to perform additional tasks before the type checker actually visits a method call. ... *//** Allows the extension to perform additional tasks after the type checker actually visits a method call. ... *//** Allows the extension to listen to method selection events. Given an expression, which may be a method ... *//** Allows the extension to catch incompatible return types. This event is called whenever the type ... *//** Returns the inferred type of an expression. Delegates to the type checker implementation. ... */// ------------------------------------------------------------------------------------------// Below, you will find various helper methods aimed at simplifying algorithms for subclasses/** Adds a type checking error, which will be displayed to the user during compilation. ... *//** Stores an inferred type for an expression. Delegates to the type checker. ... *//** Lookup a ClassNode by its name from the source unit ... */parameterizedType(...)int expectedLengthgenerics.lengthgenericsTypeArguments.lengthClassLoader transformLoaderClass<? extends ClosureSignatureConflictResolver> resolverClosureSignatureConflictResolver resolverInstancenew Function<CompilationUnit,GroovyClassLoader>(...) { ... }Parameter[] closureParamsList<ClassNode[]> candidatesnew LinkedList<ClassNode[]>(...)/** Builds a parametrized class node for List, to represent List&lt;X&gt; ... *//** Builds a parametrized class node representing the Map&lt;keyType,valueType&gt; type. ... *//** Given a method call, first checks that it's a static method call, and if it is, returns the ... */Expression objectExpr/** Given a method call, checks if it's a static method call and if it is, tells if the receiver matches ... */ClassNode staticReceiverextractStaticReceiver(...)resolveGenericsFromTypeHint(...)signature.lengthclosureParams.lengthIterator<ClassNode[]> candItClassNode[] inferredParameter closureParamClassNode declaredTypeinferred.lengthClassNode lastInferredresolveWithResolver(...)/** Computes the inferred types of the closure parameters using the following trick: ... */GenericsType[] returnTypeGenerics/** This class node type is very special and should only be used by the static type checker ... */...[] delegates;asArrayDescriptor(...)returnTypeGenerics.lengthList<MethodNode> allMethodsResolveVisitor.EMPTY_STRING_ARRAYExpression strategyExpression genericTypeIndexExpression typeInteger stIntString typeStringClassNode[] resolvedresolved.lengthint expressionsSizeExpression parameterint paramsLengthList<AnnotationNode> targetsAnnotationNode targetAnnotationExpression idMemberExpression actualArgumentClassNode actualTypeint gtiGenericsType[] pTypeGenericspTypeGenerics.lengthint strategySet<ClassNode> allMethodsaddDelegateReceiver(...)List<AnnotationNode> nodesnew Function<Receiver<String>,ClassNode>(...) { ... }new Receiver<String>(...)Expression callArgumentsboolean isThisObjectExpressionboolean isCallOnClosureMethodCallExpression subcallClassNode closureReturnTypetypeCheckClosureCall(...)List<ConstructorNode> nodesnew LinkedList<ConstructorNode>(...)List<MethodNode> accessibleMethodsList<MethodNode> inaccessibleMethodsareCategoryMethodCalls(...)addCategoryMethodCallError(...)ClassNode objMethodNode tmpMethodNode targetMethodCandidateboolean mergeTypeString targetList<FieldNode> nodesClassNode irtgDelegationMetadata mdString dataadjustWithTraits(...)new SecondPassExpression<ClassNode[]>(...)getMathResultType(...)Set<ClassNode> nodesint incomingStrategyint outgoingStrategyList<PropertyNode> nodesnew LinkedList<PropertyNode>(...)getResolveStrategyName(...)List<Expression> argumentExpressionsList<Integer> methodReferencePositionsnew LinkedList<Integer>(...)isAnnotated(...)List<Expression> newArgumentExpressionsExpression argumentExpressionExpression lambdaExpressionExpression methodReferenceExpression/** A special method handling the "withTrait" call for which the type checker knows more than ... *//** Adds various getAt and setAt methods for primitive arrays. ... *//** Helping to create a few standard AST constructs */createVariableDefinition(...)VariableExpression newVariable/** In the case of a <em>Object.with { ... }</em> call, this method is supposed to retrieve ... *//** Given an object expression (a message receiver expression), generate list ... */List<Receiver<String>> ownersList<Receiver<String>> enclosingClassList<ClassNode> temporaryTypesint temporaryTypesCounttypeCheckingContext.lastImplicitItTypeClassNode staticTypeaddTraitType(...)addBoundType(...)addSelfTypes(...)/** This statement should make the code jump to surrounding while loop's start label ... */InWhileLoopWrapper.LOOP_LABEL/** This statement will throw exception which will be caught and redirected to jump to surrounding while loop's start label ... */InWhileLoopWrapper.class//continue _RECUR_HERE_// throw InWhileLoopWrapper.LOOP_EXCEPTIONClassNode traitTypeList<ClassNode> classNodesMap<Object,List<ClassNode>> tempo(...).parameter/** Collect all recursive calls within method */List<Expression> recursiveCalls;MethodNode method;isRecursive(...)new RecursivenessTester(...)/** Exception will be thrown by recursive calls in closures and caught in while loop to continue to LOOP_LABEL *//** Check if there are any recursive calls in a method */boolean hasRecursiveCalls;checkInterfaceStaticCall(...)checkSuperCallFromClosure(...)/** Wrap the body of a method in a while loop, nested in a try-catch. ... */new GotoRecurHereException(...)BlockStatement oldBodyGotoRecurHereException.classWhileStatement whileLoopList<Statement> whileLoopStatementsBlockStatement newBodysetStatementLabel(...)String LOOP_LABEL;GotoRecurHereException LOOP_EXCEPTION;new Function<Object,LinkedList<Object>>(...) { ... }import static DefaultGroovyMethods.invokeMethodimport static DefaultGroovyMethods.transpose/** Test if a method call is recursive if called within a given method node. ... */ASTNode methodASTNode callClass<? extends ASTNode> callClassallParametersAndArgumentsMatchWithDefaultParams(...)formatArgumentList(...)Map<VariableExpression,ClassNode> updatesrestoreTypeBeforeConditional(...)new BiConsumer<VariableExpression,ClassNode>(...) { ... }typeCheckingContext.enclosingBlocksBinaryExpression instanceOfExpressionfindInstanceOfNotReturnExpression(...)findNotInstanceOfReturnExpression(...)visitInstanceofNot(...)BlockStatement currentBlocktypeCheckingContext.blockStatements2TypesStaticMethodCallExpression.classisCallToThis(...)methodParamsMatchCallArgs(...)getTypeCheckingContext(...)visitClosingBlock(...)List<List<ClassNode>> classNodePairsBlockStatement peekBlock/** Check IfStatement matched pattern : ... */NotExpression notExpressionnotReturningBlock(...)pushEnclosingSwitchStatement(...)popEnclosingSwitchStatement(...)ClassNode infboolean lambdanew Function<VariableExpression,List<ClassNode>>(...) { ... }new BiConsumer<VariableExpression,List<ClassNode>>(...) { ... }Map<VariableExpression,ClassNode> assignmentsExpression elementExprExpression sourcecheckCast(...)boolean sourceIsNullExpression trueExpressionClassNode typeOfTrueExpression falseExpressionClassNode typeOfFalsevisitValueExpression(...)checkForTargetType(...)isEmptyCollection(...)MethodCall enclosingMethodCallnew Predicate<List<ClassNode>>(...) { ... }BinaryExpression enclosingExpressionareTypesCallCompatible(...)isTypeSource(...)Map<GenericsTypeName,GenericsType> gt/** Parameter type and calling argument type can both be derived from the other since typing information is ... */ClassNode boxedArgboolean[] returnedClassNode boxedParamStaticTypeCheckingVisitor$2isEmptyList(...)isEmptyMap(...)// Could be a GStringExpression/** Adds explicit return statements to implicit return points in a closure. This is necessary since ... *///Create a dummy method with the closure's code as the method's code. Then user ReturnAdder, which only works for methods.List<CatchStatement> catchStatementsClassNode exceptionTypeClassNode oldValueClassNode oldDITimport static DefaultGroovyMethods.minusList<ClassNode> assignedTypestypeCheckingContext.closureSharedVariablesAssignmentTypesList<ClassNode> temporaryTypesForExpression/** Translates all return statements into an invocation of the next iteration. This can be either ... */recurStatement(...)this.recurStatementString operationNameExpression recursiveCallgetOperationName(...)ClassNode mathResultTypeMap<String,Map<String,Object>> tempMappingnew LinkedHashMap<String,Map<String,Object>>(...)inferSAMTypeGenericsInAssignment(...)ClassNode initialTypegetLiteralResultType(...)isBoolIntrinsicOp(...)BinaryExpression newExpr/** For "{@code List<Type> x = [...]}" or "{@code Set<Type> y = [...]}", etc. ... */BiPredicate<GenericsType,GenericsType> isEqualOrSupernew BiPredicate<GenericsType,GenericsType>(...) { ... }GenericsType[] lgtlgt.lengthisOperationInGroup(...)isFloat(...)isDouble(...)isPowerOperator(...)isBitOperator(...)Map<String,ExpressionStatement> tempDeclarationsnew LinkedHashMap<String,ExpressionStatement>(...)getGroupOperationResultType(...)GenericsType[] samTypeGenericsGenericsType[] closureGenericsParameter[] methodParamsmethodParams.lengthClassNode closureParamTypeClassNode methodParamTypeList<ExpressionStatement> argAssignmentsList<MethodNode> filteredWithGenericsOpcodes.ACC_BRIDGEBlockStatement resultList<Expression> argumentsSet<String> unusedTempsreplaceAllArgUsages(...)isAMethodCalls(...)ExpressionStatement tempDeclarationcreateTempDeclaration(...)ExpressionStatement argAssignmentcreateAssignmentToIterationVariable(...)String argNameboolean category/** Returns methods defined for the specified receiver and adds "non-existing" ... */MethodNode cloneClassNode argAndTempTypeString tempNamecreateVariableAlias(...)addGeneratedMethods(...)MethodNode stubbedList<MethodN    'm    